{
  "taichi-dev/taichi": {
    "setup.py": "# Optional environment variables supported by setup.py:\n#   {DEBUG, RELWITHDEBINFO, MINSIZEREL}\n#     build the C++ taichi_python extension with various build types.\n#\n#   TAICHI_CMAKE_ARGS\n#     extra cmake args for C++ taichi_python extension.\n\nimport glob\nimport multiprocessing\nimport os\nimport platform\nimport shutil\nimport subprocess\nimport sys\nfrom distutils.command.clean import clean\nfrom distutils.dir_util import remove_tree\n\nfrom setuptools import find_packages\nfrom skbuild import setup\nfrom skbuild.command.egg_info import egg_info\n\nroot_dir = os.path.dirname(os.path.abspath(__file__))\n\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Topic :: Software Development :: Compilers\",\n    \"Topic :: Multimedia :: Graphics\",\n    \"Topic :: Games/Entertainment :: Simulation\",\n    \"Intended Audience :: Science/Research\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n]\n\n\ndef get_version():\n    if os.getenv(\"RELEASE_VERSION\"):\n        version = os.environ[\"RELEASE_VERSION\"]\n    else:\n        version_file = os.path.join(os.path.dirname(__file__), \"version.txt\")\n        with open(version_file, \"r\") as f:\n            version = f.read().strip()\n    return version.lstrip(\"v\")\n\n\nproject_name = os.getenv(\"PROJECT_NAME\", \"taichi\")\nversion = get_version()\nTI_VERSION_MAJOR, TI_VERSION_MINOR, TI_VERSION_PATCH = version.split(\".\")\n\ndata_files = glob.glob(\"python/_lib/runtime/*\")\nprint(data_files)\npackages = find_packages(\"python\")\nprint(packages)\n\n# Our python package root dir is python/\npackage_dir = \"python\"\n\n\ndef remove_tmp(taichi_dir):\n    shutil.rmtree(os.path.join(taichi_dir, \"assets\"), ignore_errors=True)\n\n\nclass EggInfo(egg_info):\n    def finalize_options(self, *args, **kwargs):\n        if \"\" not in self.distribution.package_dir:\n            # Issue#4975: skbuild loses the root package dir\n            self.distribution.package_dir[\"\"] = package_dir\n        return super().finalize_options(*args, **kwargs)\n\n\ndef copy_assets():\n    taichi_dir = os.path.join(package_dir, \"taichi\")\n    remove_tmp(taichi_dir)\n\n    shutil.copytree(\"external/assets\", os.path.join(taichi_dir, \"assets\"))\n\n\nclass Clean(clean):\n    def run(self):\n        super().run()\n        self.build_temp = os.path.join(root_dir, \"_skbuild\")\n        if os.path.exists(self.build_temp):\n            remove_tree(self.build_temp, dry_run=self.dry_run)\n        generated_folders = (\n            \"bin\",\n            \"dist\",\n            \"python/taichi/assets\",\n            \"python/taichi/_lib/runtime\",\n            \"python/taichi/_lib/c_api\",\n            \"taichi.egg-info\",\n            \"python/taichi.egg-info\",\n            \"build\",\n        )\n        for d in generated_folders:\n            if os.path.exists(d):\n                remove_tree(d, dry_run=self.dry_run)\n        generated_files = [\"taichi/common/commit_hash.h\", \"taichi/common/version.h\"]\n        generated_files += glob.glob(\"taichi/runtime/llvm/runtime_*.bc\")\n        generated_files += glob.glob(\"python/taichi/_lib/core/*.so\")\n        generated_files += glob.glob(\"python/taichi/_lib/core/*.pyd\")\n        for f in generated_files:\n            if os.path.exists(f):\n                print(f\"removing generated file {f}\")\n                if not self.dry_run:\n                    os.remove(f)\n\n\ndef get_cmake_args():\n    import shlex\n\n    num_threads = os.getenv(\"BUILD_NUM_THREADS\", multiprocessing.cpu_count())\n    cmake_args = shlex.split(os.getenv(\"TAICHI_CMAKE_ARGS\", \"\").strip())\n\n    use_msbuild = False\n    use_xcode = False\n\n    if os.getenv(\"DEBUG\", \"0\") in (\"1\", \"ON\"):\n        cfg = \"Debug\"\n    elif os.getenv(\"RELWITHDEBINFO\", \"0\") in (\"1\", \"ON\"):\n        cfg = \"RelWithDebInfo\"\n    elif os.getenv(\"MINSIZEREL\", \"0\") in (\"1\", \"ON\"):\n        cfg = \"MinSizeRel\"\n    else:\n        cfg = None\n    build_options = []\n    if cfg:\n        build_options.extend([\"--build-type\", cfg])\n    if sys.platform == \"win32\":\n        if os.getenv(\"TAICHI_USE_MSBUILD\", \"0\") in (\"1\", \"ON\"):\n            use_msbuild = True\n        if use_msbuild:\n            build_options.extend([\"-G\", \"Visual Studio 17 2022\"])\n        else:\n            build_options.extend([\"-G\", \"Ninja\", \"--skip-generator-test\"])\n    if sys.platform == \"darwin\":\n        if os.getenv(\"TAICHI_USE_XCODE\", \"0\") in (\"1\", \"ON\"):\n            use_xcode = True\n        if use_xcode:\n            build_options.extend([\"-G\", \"Xcode\", \"--skip-generator-test\"])\n    sys.argv[2:2] = build_options\n\n    cmake_args += [\n        f\"-DTI_VERSION_MAJOR={TI_VERSION_MAJOR}\",\n        f\"-DTI_VERSION_MINOR={TI_VERSION_MINOR}\",\n        f\"-DTI_VERSION_PATCH={TI_VERSION_PATCH}\",\n    ]\n\n    if sys.platform == \"darwin\" and use_xcode:\n        os.environ[\"SKBUILD_BUILD_OPTIONS\"] = f\"-jobs {num_threads}\"\n    elif sys.platform != \"win32\":\n        os.environ[\"SKBUILD_BUILD_OPTIONS\"] = f\"-j{num_threads}\"\n    elif use_msbuild:\n        # /M uses multi-threaded build (similar to -j)\n        os.environ[\"SKBUILD_BUILD_OPTIONS\"] = f\"/M\"\n    if sys.platform == \"darwin\":\n        if platform.machine() == \"arm64\":\n            cmake_args += [\"-DCMAKE_OSX_ARCHITECTURES=arm64\"]\n        else:\n            cmake_args += [\"-DCMAKE_OSX_ARCHITECTURES=x86_64\"]\n    return cmake_args\n\n\n# Control files to be included in package data\nBLACKLISTED_FILES = [\n    \"libSPIRV-Tools-shared.so\",\n    \"libSPIRV-Tools-shared.dll\",\n]\n\nWHITELISTED_FILES = [\n    \"libMoltenVK.dylib\",\n]\n\n\ndef cmake_install_manifest_filter(manifest_files):\n    def should_include(f):\n        basename = os.path.basename(f)\n        if basename in WHITELISTED_FILES:\n            return True\n        if basename in BLACKLISTED_FILES:\n            return False\n        return f.endswith((\".so\", \"pyd\", \".dll\", \".bc\", \".h\", \".dylib\", \".cmake\", \".hpp\"))\n\n    return [f for f in manifest_files if should_include(f)]\n\n\ndef sign_development_for_apple_m1():\n    \"\"\"\n    Apple enforces codesigning for arm64 targets even for local development\n    builds. See discussion here:\n        https://github.com/supercollider/supercollider/issues/5603\n    \"\"\"\n    if sys.platform == \"darwin\" and platform.machine() == \"arm64\":\n        try:\n            for path in glob.glob(\"python/taichi/_lib/core/*.so\"):\n                print(f\"signing {path}..\")\n                subprocess.check_call([\"codesign\", \"--force\", \"--deep\", \"--sign\", \"-\", path])\n            for path in glob.glob(\"python/taichi/_lib/c_api/lib/*.so\"):\n                print(f\"signing {path}..\")\n                subprocess.check_call([\"codesign\", \"--force\", \"--deep\", \"--sign\", \"-\", path])\n        except:\n            print(\"cannot sign python shared library for macos arm64 build\")\n\n\ncopy_assets()\n\nforce_plat_name = os.getenv(\"TAICHI_FORCE_PLAT_NAME\", \"\").strip()\nif force_plat_name:\n    from skbuild.constants import set_skbuild_plat_name\n\n    set_skbuild_plat_name(force_plat_name)\n\nsetup(\n    name=project_name,\n    packages=packages,\n    package_dir={\"\": package_dir},\n    version=version,\n    description=\"The Taichi Programming Language\",\n    author=\"Taichi developers\",\n    author_email=\"yuanmhu@gmail.com\",\n    url=\"https://github.com/taichi-dev/taichi\",\n    python_requires=\">=3.6,<3.12\",\n    install_requires=[\n        \"numpy\",\n        \"colorama\",\n        \"dill\",\n        \"rich\",\n        'astunparse;python_version<\"3.9\"',\n    ],\n    data_files=[\n        (os.path.join(\"_lib\", \"runtime\"), data_files),\n    ],\n    keywords=[\"graphics\", \"simulation\"],\n    license=\"Apache Software License (http://www.apache.org/licenses/LICENSE-2.0)\",\n    include_package_data=True,\n    entry_points={\n        \"console_scripts\": [\n            \"ti=taichi._main:main\",\n        ],\n    },\n    classifiers=classifiers,\n    cmake_args=get_cmake_args(),\n    cmake_process_manifest_hook=cmake_install_manifest_filter,\n    cmdclass={\"egg_info\": EggInfo, \"clean\": Clean},\n    has_ext_modules=lambda: True,\n)\n\nsign_development_for_apple_m1()\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\", \"wheel\",\n    \"numpy\", \"pybind11\", \"cmake\",\n    \"scikit-build\", \"ninja; platform_system != 'Windows'\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nfilterwarnings = [\n    \"ignore:Calling non-taichi function\",\n    \"ignore:`np.int` is a deprecated alias\",\n    \"ignore:Operator \\\"is\\\" in Taichi scope is deprecated\",\n    \"ignore:Operator \\\"is not\\\" in Taichi scope is deprecated\"\n]\n\n[tool.yapf]\nbased_on_style = \"pep8\"\nblank_line_before_nested_class_or_def = false\n",
    "setup.cfg": "[metadata]\nlong_description = file: README.md\nlong_description_content_type = text/markdown; charset=UTF-8\n"
  },
  "vaexio/vaex": {
    "packages/vaex-core/setup.py": "from setuptools import setup\nimport sys\nimport os\nimport imp\nfrom setuptools import Extension\nimport platform\n\nuse_skbuild = len(os.environ.get('VAEX_BUILD_SKBUILD', '')) > 0\n\nif use_skbuild:\n    from skbuild import setup\n    import skbuild.command.build_ext\n\non_rtd = os.environ.get('READTHEDOCS', None) == 'True'\n\ndirname = os.path.dirname(__file__)\npath_version = os.path.join(dirname, \"vaex/core/_version.py\")\nversion = imp.load_source('version', path_version)\n\nname = 'vaex'\nauthor = \"Maarten A. Breddels\"\nauthor_email = \"maartenbreddels@gmail.com\"\nlicense = 'MIT'\nversion = version.__version__\nurl = 'https://www.github.com/maartenbreddels/vaex'\n# TODO: can we do without requests and progressbar2?\n# TODO: after python2 supports frops, future and futures can also be dropped\n# TODO: would be nice to have astropy only as dep in vaex-astro\ninstall_requires_core = [\"numpy>=1.16\", \"aplus\", \"tabulate>=0.8.3\",\n                         \"future>=0.15.2\", \"pyyaml\", \"progressbar2\",\n                         \"requests\", \"six\", \"cloudpickle\", \"pandas\", \"dask!=2022.4.0\",\n                         \"nest-asyncio>=1.3.3\", \"pyarrow>=5.0.0\", \"frozendict!=2.2.0\",\n                         \"blake3\", \"filelock\", \"pydantic>=1.8.0\", \"rich\",\n                        ]\nif sys.version_info[0] == 2:\n    install_requires_core.append(\"futures>=2.2.0\")\ninstall_requires_viz = [\"matplotlib>=1.3.1\", ]\ninstall_requires_astro = [\"kapteyn\"]\n\nif \"MACOSX_DEPLOYMENT_TARGET\" not in os.environ:\n    os.environ[\"MACOSX_DEPLOYMENT_TARGET\"] = \"10.9\"\n\nextra_dev_options = []\n# MB: I like these options during development, the second if for ccache\n# extra_dev_options = ['-fmax-errors=4', '-fdiagnostics-color', '-pedantic-errors']\n\nclass get_numpy_include(object):\n    \"\"\"Helper class to determine the numpy include path\n    The purpose of this class is to postpone importing numpy\n    until it is actually installed, so that the ``get_include()``\n    method can be invoked. \"\"\"\n\n    def __init__(self):\n        pass\n\n    def __str__(self):\n        import numpy as np\n        return np.get_include()\n\nclass get_pybind_include(object):\n    \"\"\"Helper class to determine the pybind11 include path\n    The purpose of this class is to postpone importing pybind11\n    until it is actually installed, so that the ``get_include()``\n    method can be invoked. \"\"\"\n\n    def __init__(self, user=False):\n        self.user = user\n\n    def __str__(self):\n        # this trick does not work anymore it seems, we now just vendor it\n        # import pybind11\n        # return pybind11.get_include(self.user)\n        return 'vendor/pybind11/include'\n\n\nUSE_ABSL = False\nUSE_TSL = True\n\ndefine_macros = []\nif USE_ABSL:\n    define_macros += [('VAEX_USE_ABSL', None)]\nif USE_TSL:\n    define_macros += [('VAEX_USE_TSL', None)]\n\ndll_files = []\nif platform.system().lower() == 'windows':\n    extra_compile_args = [\"/EHsc\"]\n    dll_files = ['pcre.dll', 'pcrecpp.dll', 'vcruntime140_1.dll']\nelse:\n    # TODO: maybe enable these flags for non-wheel/conda builds? [\"-mtune=native\", \"-march=native\"]\n    extra_compile_args = [\"-std=c++11\", \"-O3\", \"-funroll-loops\", \"-Werror=return-type\", \"-Wno-unused-parameter\"]\n    extra_compile_args.append(\"-g\")\n    extra_compile_args += extra_dev_options\nif sys.platform == 'darwin':\n    extra_compile_args.append(\"-mmacosx-version-min=10.9\")\n\n\n# on windows (Conda-forge builds), the dirname is an absolute path\nextension_vaexfast = Extension(\"vaex.vaexfast\", [os.path.relpath(os.path.join(dirname, \"src/vaexfast.cpp\"))],\n                               include_dirs=[get_numpy_include()],\n                               extra_compile_args=extra_compile_args)\nextension_strings = Extension(\"vaex.superstrings\", [\n    os.path.relpath(os.path.join(dirname, \"src/strings.cpp\")),\n    os.path.relpath(os.path.join(dirname, \"src/string_utils.cpp\")),\n    ],\n    include_dirs=[\n        get_numpy_include(),\n        get_pybind_include(),\n        get_pybind_include(user=True),\n        'vendor/string-view-lite/include',\n        'vendor/boost',\n        os.path.join(sys.prefix, 'include'),\n        os.path.join(sys.prefix, 'Library', 'include'), # windows\n        os.path.join(dirname, 'vendor', 'pcre', 'Library', 'include') # windows pcre from conda-forge\n    ],\n    library_dirs=[\n        os.path.join(sys.prefix, 'lib'),\n        os.path.join(sys.prefix, 'Library', 'lib'), # windows\n        os.path.join(dirname, 'vendor', 'pcre', 'Library', 'lib'), # windows pcre from conda-forge\n    ],\n    extra_compile_args=extra_compile_args,\n    libraries=['pcre', 'pcrecpp']\n)\nextension_superutils = Extension(\"vaex.superutils\", [\n        os.path.relpath(os.path.join(dirname, \"src/hash_string.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/hash_primitives_pot.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/hash_object.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/hash_primitives_prime.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/superutils.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/string_utils.cpp\")),\n    ] + ([os.path.relpath(os.path.join(dirname, \"vendor/abseil-cpp/absl/container/internal/raw_hash_set.cc\"))] if USE_ABSL else []),\n    include_dirs=[\n        get_numpy_include(), get_pybind_include(),\n        get_pybind_include(user=True),\n        'vendor/abseil-cpp',\n        'vendor/flat_hash_map',\n        'vendor/sparse-map/include',\n        'vendor/hopscotch-map/include',\n        'vendor/string-view-lite/include',\n    ],\n    extra_compile_args=extra_compile_args,\n    define_macros=define_macros,\n    )\n\nextension_superagg = Extension(\"vaex.superagg\", [\n        os.path.relpath(os.path.join(dirname, \"src/agg_nunique_string.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/agg_minmax.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/agg_nunique.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/agg_sum.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/agg_first.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/agg_list.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/agg_count.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/agg.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/binner_combined.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/binner_ordinal.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/binner_hash.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/binners.cpp\")),\n        os.path.relpath(os.path.join(dirname, \"src/string_utils.cpp\")),\n    ],\n    include_dirs=[\n        get_numpy_include(), get_pybind_include(),\n        get_pybind_include(user=True),\n        'vendor/flat_hash_map',\n        'vendor/sparse-map/include',\n        'vendor/hopscotch-map/include',\n        'vendor/string-view-lite/include'\n    ],\n    extra_compile_args=extra_compile_args,\n    define_macros=define_macros,\n    )\n\nsetup(name=name + '-core',\n      version=version,\n      description='Core of vaex',\n      url=url,\n      author=author,\n      author_email=author_email,\n      setup_requires=['numpy'],\n      install_requires=install_requires_core,\n      license=license,\n      package_data={'vaex': dll_files + ['test/files/*.fits', 'test/files/*.vot', 'test/files/*.hdf5']},\n      packages=['vaex', 'vaex.arrow', 'vaex.core', 'vaex.file', 'vaex.test', 'vaex.ext', 'vaex.misc', 'vaex.datasets'],\n      include_package_data=True,\n      ext_modules=([extension_vaexfast] if on_rtd else [extension_vaexfast, extension_strings, extension_superutils, extension_superagg]) if not use_skbuild else [],\n      zip_safe=False,\n      classifiers=[\n            \"Programming Language :: Python :: 3.6\",\n            \"Programming Language :: Python :: 3.7\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n      ],\n      extras_require={\n          'all': [\"gcsfs>=0.6.2\", \"s3fs\"]\n      },\n      entry_points={\n          'console_scripts': ['vaex = vaex.__main__:main'],\n          'gui_scripts': ['vaexgui = vaex.__main__:main'],  # sometimes in osx, you need to run with this\n          'vaex.dataframe.accessor': [\n              'geo = vaex.geo:DataFrameAccessorGeo',\n              'struct = vaex.struct:DataFrameAccessorStruct',\n          ],\n          'vaex.dataset.opener': [\n              'csv = vaex.csv:DatasetCsvLazy',\n              'arrow = vaex.arrow.opener:ArrowOpener',\n              'parquet = vaex.arrow.opener:ParquetOpener',\n              'feather = vaex.arrow.opener:FeatherOpener',\n          ],\n          'vaex.memory.tracker': [\n              'default = vaex.memory:MemoryTracker'\n          ],\n          'vaex.progressbar': [\n              'vaex = vaex.progress:simple',\n              'simple = vaex.progress:simple',\n              'widget = vaex.progress:widget',\n              'rich = vaex.progress:rich',\n          ],\n          'vaex.file.scheme': [\n              's3 = vaex.file.s3',\n              'fsspec+s3 = vaex.file.s3fs',\n              'arrow+s3 = vaex.file.s3arrow',\n              'gs = vaex.file.gcs',\n              'fsspec+gs = vaex.file.gcs',\n          ]\n      }\n      )\n",
    "packages/vaex-core/pyproject.toml": "[build-system]\n# Minimum requirements for the build system to execute.\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"oldest-supported-numpy\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja\"\n]\n"
  },
  "rapidsai/cudf": {
    "python/cudf/setup.py": "# Copyright (c) 2018-2023, NVIDIA CORPORATION.\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\npackages = find_packages(include=[\"cudf*\", \"udf_cpp*\"])\nsetup(\n    packages=packages,\n    package_data={key: [\"*.pxd\", \"*.hpp\", \"*.cuh\"] for key in packages},\n    zip_safe=False,\n)\n",
    "python/cudf/pyproject.toml": "# Copyright (c) 2021-2023, NVIDIA CORPORATION.\n\n[build-system]\nbuild-backend = \"setuptools.build_meta\"\nrequires = [\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"cython>=0.29,<0.30\",\n    \"ninja\",\n    \"numpy>=1.21,<1.24\",\n    \"protoc-wheel\",\n    \"pyarrow==11.0.0.*\",\n    \"rmm==23.6.*\",\n    \"scikit-build>=0.13.1,<0.17.2\",\n    \"setuptools\",\n    \"wheel\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project]\nname = \"cudf\"\nversion = \"23.06.00\"\ndescription = \"cuDF - GPU Dataframe\"\nreadme = { file = \"README.md\", content-type = \"text/markdown\" }\nauthors = [\n    { name = \"NVIDIA Corporation\" },\n]\nlicense = { text = \"Apache 2.0\" }\nrequires-python = \">=3.9\"\ndependencies = [\n    \"cachetools\",\n    \"cubinlinker\",\n    \"cuda-python>=11.7.1,<12.0\",\n    \"cupy-cuda11x>=12.0.0\",\n    \"fsspec>=0.6.0\",\n    \"numba>=0.56.4,<0.57\",\n    \"numpy>=1.21,<1.24\",\n    \"nvtx>=0.2.1\",\n    \"packaging\",\n    \"pandas>=1.3,<1.6.0dev0\",\n    \"protobuf>=4.21.6,<4.22\",\n    \"ptxcompiler\",\n    \"pyarrow==11.*\",\n    \"rmm==23.6.*\",\n    \"typing_extensions\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Topic :: Database\",\n    \"Topic :: Scientific/Engineering\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"fastavro>=0.22.9\",\n    \"hypothesis\",\n    \"mimesis>=4.1.0\",\n    \"msgpack\",\n    \"pyorc\",\n    \"pytest\",\n    \"pytest-benchmark\",\n    \"pytest-cases\",\n    \"pytest-cov\",\n    \"pytest-xdist\",\n    \"python-snappy>=0.6.0\",\n    \"scipy\",\n    \"tokenizers==0.13.1\",\n    \"transformers==4.24.0\",\n    \"tzdata\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project.urls]\nHomepage = \"https://github.com/rapidsai/cudf\"\nDocumentation = \"https://docs.rapids.ai/api/cudf/stable/\"\n\n[tool.setuptools]\nlicense-files = [\"LICENSE\"]\n\n[tool.isort]\nline_length = 79\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\ncombine_as_imports = true\norder_by_type = true\nknown_dask = [\n    \"dask\",\n    \"distributed\",\n    \"dask_cuda\",\n]\nknown_rapids = [\n    \"rmm\",\n]\nknown_first_party = [\n    \"cudf\",\n]\ndefault_section = \"THIRDPARTY\"\nsections = [\n    \"FUTURE\",\n    \"STDLIB\",\n    \"THIRDPARTY\",\n    \"DASK\",\n    \"RAPIDS\",\n    \"FIRSTPARTY\",\n    \"LOCALFOLDER\",\n]\nskip = [\n    \"thirdparty\",\n    \".eggs\",\n    \".git\",\n    \".hg\",\n    \".mypy_cache\",\n    \".tox\",\n    \".venv\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"__init__.py\",\n]\n"
  },
  "halide/Halide": {
    "setup.py": "import pybind11\nfrom setuptools import find_packages\nfrom skbuild import setup\nfrom pathlib import Path\n\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README_python.md\").read_text()\n\nsetup(\n    name=\"halide\",\n    version='16.0.0',\n    author=\"The Halide team\",\n    author_email=\"halide-dev@lists.csail.mit.edu\",\n    description=\"Halide is a programming language designed to make it easier \"\n                \"to write high-performance image and array processing code.\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    python_requires=\">=3.8\",\n    packages=find_packages(where=\"python_bindings/src\"),\n    package_dir={\"\": \"python_bindings/src\"},\n    cmake_source_dir=\"python_bindings\",\n    cmake_args=[\n        f\"-Dpybind11_ROOT={pybind11.get_cmake_dir()}\",\n        \"-DCMAKE_REQUIRE_FIND_PACKAGE_pybind11=YES\",\n        \"-DHalide_INSTALL_PYTHONDIR=python_bindings/src\",\n        \"-DCMAKE_INSTALL_RPATH=$<IF:$<PLATFORM_ID:Darwin>,@loader_path,$ORIGIN>\",\n        \"-DHalide_Python_INSTALL_IMPORTED_DEPS=ON\",\n        \"-DWITH_TESTS=NO\",\n        \"-DWITH_TUTORIALS=NO\",\n        \"-DWITH_PYTHON_STUBS=NO\",\n        \"-DCMAKE_PREFIX_PATH=$ENV{CMAKE_PREFIX_PATH}\",\n        \"--no-warn-unused-cli\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools>=43\",\n  \"wheel\",\n  \"scikit-build\",\n  \"pybind11==2.6.2\",\n  \"cmake>=3.22\",\n  \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "opencv/opencv-python": {
    "setup.py": "import io\nimport os\nimport os.path\nimport sys\nimport runpy\nimport subprocess\nimport re\nimport sysconfig\nimport platform\nimport skbuild\nfrom skbuild import cmaker\n\n\ndef main():\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n\n    CI_BUILD = os.environ.get(\"CI_BUILD\", \"False\")\n    is_CI_build = True if CI_BUILD == \"1\" else False\n    cmake_source_dir = \"opencv\"\n    minimum_supported_numpy = \"1.13.3\"\n    build_contrib = get_build_env_var_by_name(\"contrib\")\n    build_headless = get_build_env_var_by_name(\"headless\")\n    build_java = \"ON\" if get_build_env_var_by_name(\"java\") else \"OFF\"\n    build_rolling = get_build_env_var_by_name(\"rolling\")\n\n    install_requires = [\n        'numpy>=1.13.3; python_version<\"3.7\"',\n        'numpy>=1.17.0; python_version>=\"3.7\"', # https://github.com/numpy/numpy/pull/13725\n        'numpy>=1.17.3; python_version>=\"3.8\"',\n        'numpy>=1.19.3; python_version>=\"3.9\"',\n        'numpy>=1.21.2; python_version>=\"3.10\"',\n        'numpy>=1.19.3; python_version>=\"3.6\" and platform_system==\"Linux\" and platform_machine==\"aarch64\"',\n        'numpy>=1.21.0; python_version<=\"3.9\" and platform_system==\"Darwin\" and platform_machine==\"arm64\"',\n        'numpy>=1.21.4; python_version>=\"3.10\" and platform_system==\"Darwin\"',\n        \"numpy>=1.22.0; python_version>='3.11'\"\n    ]\n\n    python_version = cmaker.CMaker.get_python_version()\n    python_lib_path = cmaker.CMaker.get_python_library(python_version).replace(\n        \"\\\\\", \"/\"\n    )\n    python_include_dir = cmaker.CMaker.get_python_include_dir(python_version).replace(\n        \"\\\\\", \"/\"\n    )\n\n    if os.path.exists(\".git\"):\n        import pip._internal.vcs.git as git\n\n        g = git.Git()  # NOTE: pip API's are internal, this has to be refactored\n\n        g.run_command([\"submodule\", \"sync\"])\n\n        if build_rolling:\n            g.run_command(\n                [\"submodule\", \"update\", \"--init\", \"--recursive\", \"--remote\", cmake_source_dir]\n            )\n\n            if build_contrib:\n                g.run_command(\n                    [\"submodule\", \"update\", \"--init\", \"--recursive\", \"--remote\", \"opencv_contrib\"]\n                )\n        else:\n            g.run_command(\n                [\"submodule\", \"update\", \"--init\", \"--recursive\", cmake_source_dir]\n            )\n\n            if build_contrib:\n                g.run_command(\n                    [\"submodule\", \"update\", \"--init\", \"--recursive\", \"opencv_contrib\"]\n                )\n\n    package_version, build_contrib, build_headless, build_rolling = get_and_set_info(\n        build_contrib, build_headless, build_rolling, is_CI_build\n    )\n\n    # https://stackoverflow.com/questions/1405913/python-32bit-or-64bit-mode\n    is64 = sys.maxsize > 2 ** 32\n\n    package_name = \"opencv-python\"\n\n    if build_contrib and not build_headless:\n        package_name = \"opencv-contrib-python\"\n\n    if build_contrib and build_headless:\n        package_name = \"opencv-contrib-python-headless\"\n\n    if build_headless and not build_contrib:\n        package_name = \"opencv-python-headless\"\n\n    if build_rolling:\n        package_name += \"-rolling\"\n\n    long_description = io.open(\"README.md\", encoding=\"utf-8\").read()\n\n    packages = [\"cv2\", \"cv2.data\"]\n\n    package_data = {\n        \"cv2\": [\"*%s\" % sysconfig.get_config_vars().get(\"SO\"), \"version.py\"]\n        + ([\"*.dll\"] if os.name == \"nt\" else [])\n        + [\"LICENSE.txt\", \"LICENSE-3RD-PARTY.txt\"],\n        \"cv2.data\": [\"*.xml\"],\n    }\n\n    # Files from CMake output to copy to package.\n    # Path regexes with forward slashes relative to CMake install dir.\n    rearrange_cmake_output_data = {\n        \"cv2\": (\n            [r\"bin/opencv_videoio_ffmpeg\\d{3}%s\\.dll\" % (\"_64\" if is64 else \"\")]\n            if os.name == \"nt\"\n            else []\n        )\n        +\n        # In Windows, in python/X.Y/<arch>/; in Linux, in just python/X.Y/.\n        # Naming conventions vary so widely between versions and OSes\n        # had to give up on checking them.\n        [\n            r\"python/cv2/python-%s/cv2.*\"\n            % (sys.version_info[0])\n        ]\n        +\n        [\n            r\"python/cv2/__init__.py\"\n        ]\n        +\n        [\n            r\"python/cv2/.*config.*.py\"\n        ],\n        \"cv2.data\": [  # OPENCV_OTHER_INSTALL_PATH\n            (\"etc\" if os.name == \"nt\" else \"share/opencv4\") + r\"/haarcascades/.*\\.xml\"\n        ],\n        \"cv2.gapi\": [\n            \"python/cv2\" + r\"/gapi/.*\\.py\"\n        ],\n        \"cv2.mat_wrapper\": [\n            \"python/cv2\" + r\"/mat_wrapper/.*\\.py\"\n        ],\n        \"cv2.misc\": [\n            \"python/cv2\" + r\"/misc/.*\\.py\"\n        ],\n        \"cv2.utils\": [\n            \"python/cv2\" + r\"/utils/.*\\.py\"\n        ],\n    }\n\n    # Files in sourcetree outside package dir that should be copied to package.\n    # Raw paths relative to sourcetree root.\n    files_outside_package_dir = {\"cv2\": [\"LICENSE.txt\", \"LICENSE-3RD-PARTY.txt\"]}\n\n    ci_cmake_generator = (\n        [\"-G\", \"Visual Studio 14\" + (\" Win64\" if is64 else \"\")]\n        if os.name == \"nt\"\n        else [\"-G\", \"Unix Makefiles\"]\n    )\n\n    cmake_args = (\n        (ci_cmake_generator if is_CI_build else [])\n        + [\n            # skbuild inserts PYTHON_* vars. That doesn't satisfy opencv build scripts in case of Py3\n            \"-DPYTHON3_EXECUTABLE=%s\" % sys.executable,\n            \"-DPYTHON3_INCLUDE_DIR=%s\" % python_include_dir,\n            \"-DPYTHON3_LIBRARY=%s\" % python_lib_path,\n            \"-DBUILD_opencv_python3=ON\",\n            \"-DBUILD_opencv_python2=OFF\",\n            # Disable the Java build by default as it is not needed\n            \"-DBUILD_opencv_java=%s\" % build_java,\n            # Relative dir to install the built module to in the build tree.\n            # The default is generated from sysconfig, we'd rather have a constant for simplicity\n            \"-DOPENCV_PYTHON3_INSTALL_PATH=python\",\n            # Otherwise, opencv scripts would want to install `.pyd' right into site-packages,\n            # and skbuild bails out on seeing that\n            \"-DINSTALL_CREATE_DISTRIB=ON\",\n            # See opencv/CMakeLists.txt for options and defaults\n            \"-DBUILD_opencv_apps=OFF\",\n            \"-DBUILD_opencv_freetype=OFF\",\n            \"-DBUILD_SHARED_LIBS=OFF\",\n            \"-DBUILD_TESTS=OFF\",\n            \"-DBUILD_PERF_TESTS=OFF\",\n            \"-DBUILD_DOCS=OFF\",\n            \"-DPYTHON3_LIMITED_API=ON\",\n            \"-DBUILD_OPENEXR=ON\",\n        ]\n        + (\n            # CMake flags for windows/arm64 build\n            [\"-DCMAKE_GENERATOR_PLATFORM=ARM64\",\n             # Emulated cmake requires following flags to correctly detect\n             # target architecture for windows/arm64 build\n             \"-DOPENCV_WORKAROUND_CMAKE_20989=ON\",\n             \"-DCMAKE_SYSTEM_PROCESSOR=ARM64\"]\n            if platform.machine() == \"ARM64\" and sys.platform == \"win32\"\n            # If it is not defined 'linker flags: /machine:X86' on Windows x64\n            else [\"-DCMAKE_GENERATOR_PLATFORM=x64\"] if is64 and sys.platform == \"win32\"\n            else []\n          )\n        + (\n            [\"-DOPENCV_EXTRA_MODULES_PATH=\" + os.path.abspath(\"opencv_contrib/modules\")]\n            if build_contrib\n            else []\n        )\n    )\n\n    if build_headless:\n        # it seems that cocoa cannot be disabled so on macOS the package is not truly headless\n        cmake_args.append(\"-DWITH_WIN32UI=OFF\")\n        cmake_args.append(\"-DWITH_QT=OFF\")\n        cmake_args.append(\"-DWITH_GTK=OFF\")\n        if is_CI_build:\n            cmake_args.append(\n                \"-DWITH_MSMF=OFF\"\n            )  # see: https://github.com/skvark/opencv-python/issues/263\n\n    if sys.platform.startswith(\"linux\") and not is64 and \"bdist_wheel\" in sys.argv:\n        subprocess.check_call(\"patch -p0 < patches/patchOpenEXR\", shell=True)\n\n    # OS-specific components during CI builds\n    if is_CI_build:\n\n        if (\n            not build_headless\n            and \"bdist_wheel\" in sys.argv\n            and sys.platform.startswith(\"linux\")\n        ):\n            cmake_args.append(\"-DWITH_QT=5\")\n            subprocess.check_call(\"patch -p1 < patches/patchQtPlugins\", shell=True)\n\n            if sys.platform.startswith(\"linux\"):\n                rearrange_cmake_output_data[\"cv2.qt.plugins.platforms\"] = [\n                    (r\"lib/qt/plugins/platforms/libqxcb\\.so\")\n                ]\n\n                # add fonts for Qt5\n                fonts = []\n                for file in os.listdir(\"/usr/share/fonts/dejavu\"):\n                    if file.endswith(\".ttf\"):\n                        fonts.append(\n                            (r\"lib/qt/fonts/dejavu/%s\\.ttf\" % file.split(\".\")[0])\n                        )\n\n                rearrange_cmake_output_data[\"cv2.qt.fonts\"] = fonts\n\n            if sys.platform == \"darwin\":\n                rearrange_cmake_output_data[\"cv2.qt.plugins.platforms\"] = [\n                    (r\"lib/qt/plugins/platforms/libqcocoa\\.dylib\")\n                ]\n\n        if sys.platform.startswith(\"linux\"):\n            cmake_args.append(\"-DWITH_V4L=ON\")\n            cmake_args.append(\"-DWITH_LAPACK=ON\")\n            cmake_args.append(\"-DENABLE_PRECOMPILED_HEADERS=OFF\")\n\n    # https://github.com/scikit-build/scikit-build/issues/479\n    if \"CMAKE_ARGS\" in os.environ:\n        import shlex\n\n        cmake_args.extend(shlex.split(os.environ[\"CMAKE_ARGS\"]))\n        del shlex\n\n    # works via side effect\n    RearrangeCMakeOutput(\n        rearrange_cmake_output_data, files_outside_package_dir, package_data.keys()\n    )\n\n    skbuild.setup(\n        name=package_name,\n        version=package_version,\n        url=\"https://github.com/opencv/opencv-python\",\n        license=\"Apache 2.0\",\n        description=\"Wrapper package for OpenCV python bindings.\",\n        long_description=long_description,\n        long_description_content_type=\"text/markdown\",\n        packages=packages,\n        package_data=package_data,\n        maintainer=\"OpenCV Team\",\n        ext_modules=EmptyListWithLength(),\n        install_requires=install_requires,\n        python_requires=\">=3.6\",\n        classifiers=[\n            \"Development Status :: 5 - Production/Stable\",\n            \"Environment :: Console\",\n            \"Intended Audience :: Developers\",\n            \"Intended Audience :: Education\",\n            \"Intended Audience :: Information Technology\",\n            \"Intended Audience :: Science/Research\",\n            \"License :: OSI Approved :: Apache Software License\",\n            \"Operating System :: MacOS\",\n            \"Operating System :: Microsoft :: Windows\",\n            \"Operating System :: POSIX\",\n            \"Operating System :: Unix\",\n            \"Programming Language :: Python\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: 3 :: Only\",\n            \"Programming Language :: Python :: 3.6\",\n            \"Programming Language :: Python :: 3.7\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n            \"Programming Language :: Python :: 3.11\",\n            \"Programming Language :: C++\",\n            \"Programming Language :: Python :: Implementation :: CPython\",\n            \"Topic :: Scientific/Engineering\",\n            \"Topic :: Scientific/Engineering :: Image Recognition\",\n            \"Topic :: Software Development\",\n        ],\n        cmake_args=cmake_args,\n        cmake_source_dir=cmake_source_dir,\n    )\n\n\nclass RearrangeCMakeOutput(object):\n    \"\"\"\n        Patch SKBuild logic to only take files related to the Python package\n        and construct a file hierarchy that SKBuild expects (see below)\n    \"\"\"\n\n    _setuptools_wrap = None\n\n    # Have to wrap a function reference, or it's converted\n    # into an instance method on attr assignment\n    import argparse\n\n    wraps = argparse.Namespace(_classify_installed_files=None)\n    del argparse\n\n    package_paths_re = None\n    packages = None\n    files_outside_package = None\n\n    def __init__(self, package_paths_re, files_outside_package, packages):\n        cls = self.__class__\n        assert not cls.wraps._classify_installed_files, \"Singleton object\"\n        import skbuild.setuptools_wrap\n\n        cls._setuptools_wrap = skbuild.setuptools_wrap\n        cls.wraps._classify_installed_files = (\n            cls._setuptools_wrap._classify_installed_files\n        )\n        cls._setuptools_wrap._classify_installed_files = (\n            self._classify_installed_files_override\n        )\n\n        cls.package_paths_re = package_paths_re\n        cls.files_outside_package = files_outside_package\n        cls.packages = packages\n\n    def __del__(self):\n        cls = self.__class__\n        cls._setuptools_wrap._classify_installed_files = (\n            cls.wraps._classify_installed_files\n        )\n        cls.wraps._classify_installed_files = None\n        cls._setuptools_wrap = None\n\n    def _classify_installed_files_override(\n        self,\n        install_paths,\n        package_data,\n        package_prefixes,\n        py_modules,\n        new_py_modules,\n        scripts,\n        new_scripts,\n        data_files,\n        cmake_source_dir,\n        cmake_install_reldir,\n    ):\n        \"\"\"\n            From all CMake output, we're only interested in a few files\n            and must place them into CMake install dir according\n            to Python conventions for SKBuild to find them:\n                package\\\n                    file\n                    subpackage\\\n                        etc.\n        \"\"\"\n\n        cls = self.__class__\n\n        # 'relpath'/'reldir' = relative to CMAKE_INSTALL_DIR/cmake_install_dir\n        # 'path'/'dir' = relative to sourcetree root\n        cmake_install_dir = os.path.join(\n            cls._setuptools_wrap.CMAKE_INSTALL_DIR(), cmake_install_reldir\n        )\n        install_relpaths = [\n            os.path.relpath(p, cmake_install_dir) for p in install_paths\n        ]\n        fslash_install_relpaths = [\n            p.replace(os.path.sep, \"/\") for p in install_relpaths\n        ]\n        relpaths_zip = list(zip(fslash_install_relpaths, install_relpaths))\n        del install_relpaths, fslash_install_relpaths\n\n        final_install_relpaths = []\n\n        print(\"Copying files from CMake output\")\n\n        # add lines from the old __init__.py file to the config file\n        with open(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'scripts', '__init__.py'), 'r') as custom_init:\n            custom_init_data = custom_init.read()\n\n        # OpenCV generates config with different name for case with PYTHON3_LIMITED_API=ON\n        config_py = os.path.join(cmake_install_dir, 'python', 'cv2', 'config-%s.%s.py'\n                                 % (sys.version_info[0], sys.version_info[1]))\n        if not os.path.exists(config_py):\n            config_py = os.path.join(cmake_install_dir, 'python', 'cv2', 'config-%s.py' % sys.version_info[0])\n\n        with open(config_py, 'w') as opencv_init_config:\n            opencv_init_config.write(custom_init_data)\n\n        for package_name, relpaths_re in cls.package_paths_re.items():\n            package_dest_reldir = package_name.replace(\".\", os.path.sep)\n            for relpath_re in relpaths_re:\n                found = False\n                r = re.compile(relpath_re + \"$\")\n                for fslash_relpath, relpath in relpaths_zip:\n                    m = r.match(fslash_relpath)\n                    if not m:\n                        continue\n                    found = True\n                    new_install_relpath = os.path.join(\n                        package_dest_reldir, os.path.basename(relpath)\n                    )\n                    cls._setuptools_wrap._copy_file(\n                        os.path.join(cmake_install_dir, relpath),\n                        os.path.join(cmake_install_dir, new_install_relpath),\n                        hide_listing=False,\n                    )\n                    final_install_relpaths.append(new_install_relpath)\n                    del m, fslash_relpath, new_install_relpath\n                else:\n                    # gapi can be missed if ADE was not downloaded (network issue)\n                    if not found and \"gapi\" not in relpath_re:\n                        raise Exception(\"Not found: '%s'\" % relpath_re)\n                del r, found\n\n        del relpaths_zip\n\n        print(\"Copying files from non-default sourcetree locations\")\n\n        for package_name, paths in cls.files_outside_package.items():\n            package_dest_reldir = package_name.replace(\".\", os.path.sep)\n            for path in paths:\n                new_install_relpath = os.path.join(\n                    package_dest_reldir,\n                    # Don't yet have a need to copy\n                    # to subdirectories of package dir\n                    os.path.basename(path),\n                )\n                cls._setuptools_wrap._copy_file(\n                    path,\n                    os.path.join(cmake_install_dir, new_install_relpath),\n                    hide_listing=False,\n                )\n                final_install_relpaths.append(new_install_relpath)\n\n        final_install_paths = [\n            os.path.join(cmake_install_dir, p) for p in final_install_relpaths\n        ]\n\n        return (cls.wraps._classify_installed_files)(\n            final_install_paths,\n            package_data,\n            package_prefixes,\n            py_modules,\n            new_py_modules,\n            scripts,\n            new_scripts,\n            data_files,\n            # To get around a check that prepends source dir to paths and breaks package detection code.\n            cmake_source_dir=\"\",\n            _cmake_install_dir=cmake_install_reldir,\n        )\n\n\ndef get_and_set_info(contrib, headless, rolling, ci_build):\n    # cv2/version.py should be generated by running find_version.py\n    version = {}\n    here = os.path.abspath(os.path.dirname(__file__))\n    version_file = os.path.join(here, \"cv2\", \"version.py\")\n\n    # generate a fresh version.py always when Git repository exists\n    # (in sdists the version.py file already exists)\n    if os.path.exists(\".git\"):\n        old_args = sys.argv.copy()\n        sys.argv = [\"\", str(contrib), str(headless), str(rolling), str(ci_build)]\n        runpy.run_path(\"find_version.py\", run_name=\"__main__\")\n        sys.argv = old_args\n\n    with open(version_file) as fp:\n        exec(fp.read(), version)\n\n    return version[\"opencv_version\"], version[\"contrib\"], version[\"headless\"], version[\"rolling\"]\n\n\ndef get_build_env_var_by_name(flag_name):\n    flag_set = False\n\n    try:\n        flag_set = bool(int(os.getenv(\"ENABLE_\" + flag_name.upper(), None)))\n    except Exception:\n        pass\n\n    if not flag_set:\n        try:\n            flag_set = bool(int(open(flag_name + \".enabled\").read(1)))\n        except Exception:\n            pass\n\n    return flag_set\n\n\n# This creates a list which is empty but returns a length of 1.\n# Should make the wheel a binary distribution and platlib compliant.\nclass EmptyListWithLength(list):\n    def __len__(self):\n        return 1\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools==59.2.0\", \"wheel==0.37.0\", \"cmake>=3.1\", \"pip\",\n  \"scikit-build>=0.13.2\",\n  \"numpy==1.13.3; python_version=='3.6' and platform_machine != 'aarch64' and platform_machine != 'arm64'\",\n  \"numpy==1.17.0; python_version=='3.7' and platform_machine != 'aarch64' and platform_machine != 'arm64'\",\n  \"numpy==1.17.3; python_version=='3.8' and platform_machine != 'aarch64' and platform_machine != 'arm64'\",\n  \"numpy==1.19.3; python_version<='3.9' and sys_platform == 'linux' and platform_machine == 'aarch64'\",\n  \"numpy==1.21.0; python_version<='3.9' and sys_platform == 'darwin' and platform_machine == 'arm64'\",\n  \"numpy==1.19.3; python_version=='3.9' and platform_machine != 'aarch64' and platform_machine != 'arm64'\",\n  \"numpy==1.21.2; python_version=='3.10' and platform_system!='Darwin'\",\n  \"numpy==1.21.4; python_version=='3.10' and platform_system=='Darwin'\",\n  \"numpy==1.22.0; python_version>='3.11'\"\n]\n"
  },
  "cmusphinx/pocketsphinx": {
    "setup.py": "from skbuild import setup\nfrom setuptools import find_packages\n\nsetup(\n    packages=find_packages('cython', exclude=[\"test\"]),\n    package_dir={\"\": \"cython\"},\n    cmake_languages=[\"C\"],\n    install_requires=[\"sounddevice\"],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n         \"wheel\",\n         \"setuptools>=45\",\n     \t \"scikit-build~=0.15\",\n\t \"Cython\",\n         \"cmake\",\n\t \"ninja\"\n]\nbuild-backend = \"setuptools.build_meta\"\n[tool.cibuildwheel]\n# Build the versions found in Ubuntu LTS, the stable PyPy, and 3.10\n# everywhere else\nbuild = [\n      \"pp38*\",\n      \"cp36-manylinux_*\",\n      \"cp38-manylinux_*\",\n      \"cp310-*\",\n      \"cp311-*\"\n]\n# PyPy 3.8 will choke on CPython 3.8 build leftovers...\nbefore-build = \"rm -rf _skbuild\"\n# PyPy builds are broken on Windows, and skip 32-bit and musl\nskip = [\"*musl*\", \"*_i686\", \"*-win32\", \"pp*win*\"]\n",
    "setup.cfg": "[metadata]\nname = pocketsphinx\nversion = 5.0.1\ndescription = Official Python bindings for PocketSphinx\nlong_description = file: cython/README.md\nlong_description_content_type = text/markdown\nauthor = David Huggins-Daines\nauthor_email = dhdaines@gmail.com\nlicense = MIT\nplatforms = any\nurl = https://github.com/cmusphinx/pocketsphinx\nproject_urls =\n    Source  = https://github.com/cmusphinx/pocketsphinx\n    Tracker = https://github.com/cmusphinx/pocketsphinx/issues\nkeywords = asr, speech\nclassifiers =\n    Development Status :: 3 - Alpha\n    Programming Language :: C\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.7\n    License :: OSI Approved :: MIT License\n    Operating System :: OS Independent\n[isort]\nprofile=black\n[flake8]\nextend-ignore = E203\nmax-line-length = 88\n"
  },
  "rapidsai/cuml": {
    "python/setup.py": "#\n# Copyright (c) 2018-2023, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nimport glob\nimport os\nimport shutil\nimport sys\nfrom pathlib import Path\n\nfrom setuptools import find_packages\n\nfrom skbuild import setup\n\n\n##############################################################################\n# - Helper functions\ndef get_cli_option(name):\n    if name in sys.argv:\n        print(\"-- Detected \" + str(name) + \" build option.\")\n        return True\n\n    else:\n        return False\n\n\ndef clean_folder(path):\n    \"\"\"\n    Function to clean all Cython and Python artifacts and cache folders. It\n    cleans the folder as well as its direct children recursively.\n\n    Parameters\n    ----------\n    path : String\n        Path to the folder to be cleaned.\n    \"\"\"\n    shutil.rmtree(path + \"/__pycache__\", ignore_errors=True)\n\n    folders = glob.glob(path + \"/*/\")\n    for folder in folders:\n        shutil.rmtree(folder + \"/__pycache__\", ignore_errors=True)\n\n        clean_folder(folder)\n\n        cython_exts = glob.glob(folder + \"/*.cpp\")\n        cython_exts.extend(glob.glob(folder + \"/*.cpython*\"))\n        for file in cython_exts:\n            os.remove(file)\n\n\n##############################################################################\n# - Print of build options used by setup.py  --------------------------------\n\nclean_artifacts = get_cli_option(\"clean\")\n\n\n##############################################################################\n# - Clean target -------------------------------------------------------------\n\nif clean_artifacts:\n    print(\"-- Cleaning all Python and Cython build artifacts...\")\n\n    # Reset these paths since they may be deleted below\n    treelite_path = False\n\n    try:\n        setup_file_path = str(Path(__file__).parent.absolute())\n        shutil.rmtree(setup_file_path + \"/.pytest_cache\", ignore_errors=True)\n        shutil.rmtree(\n            setup_file_path + \"/_external_repositories\", ignore_errors=True\n        )\n        shutil.rmtree(setup_file_path + \"/cuml.egg-info\", ignore_errors=True)\n        shutil.rmtree(setup_file_path + \"/__pycache__\", ignore_errors=True)\n\n        clean_folder(setup_file_path + \"/cuml\")\n        shutil.rmtree(setup_file_path + \"/build\", ignore_errors=True)\n        shutil.rmtree(setup_file_path + \"/_skbuild\", ignore_errors=True)\n        shutil.rmtree(setup_file_path + \"/dist\", ignore_errors=True)\n\n    except IOError:\n        pass\n\n    # need to terminate script so cythonizing doesn't get triggered after\n    # cleanup unintendedly\n    sys.argv.remove(\"clean\")\n\n    if \"--all\" in sys.argv:\n        sys.argv.remove(\"--all\")\n\n    if len(sys.argv) == 1:\n        sys.exit(0)\n\n\n##############################################################################\n# - Python package generation ------------------------------------------------\n\npackages = find_packages(include=[\"cuml*\"])\nsetup(\n    packages=packages,\n    package_data={key: [\"*.pxd\"] for key in packages},\n    zip_safe=False,\n)\n",
    "python/pyproject.toml": "# Copyright (c) 2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nrequires = [\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"cuda-python>=11.7.1,<12.0\",\n    \"cython>=0.29,<0.30\",\n    \"ninja\",\n    \"pylibraft==23.6.*\",\n    \"rmm==23.6.*\",\n    \"scikit-build>=0.13.1,<0.17.2\",\n    \"setuptools\",\n    \"treelite==3.2.0\",\n    \"treelite_runtime==3.2.0\",\n    \"wheel\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../dependencies.yaml and run `rapids-dependency-file-generator`.\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nmarkers = [\n  \"unit: Quickest tests focused on accuracy and correctness\",\n  \"quality: More intense tests than unit with increased runtimes\",\n  \"stress: Longest running tests focused on stressing hardware compute resources\",\n  \"mg: Multi-GPU tests\",\n  \"memleak: Test that checks for memory leaks\",\n  \"no_bad_cuml_array_check: Test that should not check for bad CumlArray uses\",\n]\n\ntestpaths = \"cuml/tests\"\n\nfilterwarnings = [\n  \"error::FutureWarning:cuml[.*]\", # Catch uses of deprecated positional args in testing\n  \"ignore:[^.]*ABCs[^.]*:DeprecationWarning:patsy[.*]\",\n  \"ignore:(.*)alias(.*):DeprecationWarning:hdbscan[.*]\",\n]\n\n[project]\nname = \"cuml\"\nversion = \"23.06.00\"\ndescription = \"cuML - RAPIDS ML Algorithms\"\nreadme = { file = \"README.md\", content-type = \"text/markdown\" }\nauthors = [\n    { name = \"NVIDIA Corporation\" },\n]\nlicense = { text = \"Apache 2.0\" }\nrequires-python = \">=3.9\"\ndependencies = [\n    \"cudf==23.6.*\",\n    \"cupy-cuda11x>=12.0.0\",\n    \"dask-cuda==23.6.*\",\n    \"dask-cudf==23.6.*\",\n    \"dask==2023.3.2\",\n    \"distributed==2023.3.2.1\",\n    \"joblib>=0.11\",\n    \"numba>=0.56.4,<0.57\",\n    \"raft-dask==23.6.*\",\n    \"scipy\",\n    \"seaborn\",\n    \"treelite==3.2.0\",\n    \"treelite_runtime==3.2.0\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../dependencies.yaml and run `rapids-dependency-file-generator`.\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"dask-glm @ git+https://github.com/dask/dask-glm@main\",\n    \"dask-ml\",\n    \"hdbscan @ git+https://github.com/scikit-learn-contrib/hdbscan.git@master\",\n    \"hypothesis>=6.0,<7\",\n    \"nltk\",\n    \"numpydoc\",\n    \"pynndescent==0.5.8\",\n    \"pytest\",\n    \"pytest-benchmark\",\n    \"pytest-cases\",\n    \"pytest-cov\",\n    \"pytest-xdist\",\n    \"scikit-learn==1.2\",\n    \"statsmodels\",\n    \"umap-learn==0.5.3\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project.urls]\nHomepage = \"https://github.com/rapidsai/cuml\"\nDocumentation = \"https://docs.rapids.ai/api/cuml/stable/\"\n\n[tool.setuptools]\nlicense-files = [\"LICENSE\"]\n\n[tool.black]\nline-length = 79\ntarget-version = [\"py39\"]\ninclude = '\\.py?$'\nforce-exclude = '''\n_stop_words\\.py |\n_version\\.py |\nversioneer\\.py |\n/(\n    \\.eggs |\n    \\.git |\n    \\.hg |\n    \\.mypy_cache |\n    \\.tox |\n    \\.venv |\n    _build |\n    _thirdparty |\n    buck-out |\n    build |\n    dist |\n    thirdparty\n)/\n'''\n"
  },
  "OGRECave/ogre": {
    "setup.py": "import os\nimport sys\nimport os.path\nimport re\nimport skbuild\nfrom skbuild import cmaker\n\n# This creates a list which is empty but returns a length of 1.\n# Should make the wheel a binary distribution and platlib compliant.\nclass EmptyListWithLength(list):\n    def __len__(self):\n        return 1\n\ndef cmake_process_manifest_hook(cmake_manifest):\n    return [name for name in cmake_manifest\n            if os.path.splitext(name)[1] not in (\".a\", \".h\", \".i\", \".pc\", \".cmake\", \".lib\")\n            or \"media/\" in name.replace(\"\\\\\", \"/\").lower()]\n\ndef main():\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n\n    os.makedirs(\"Ogre\", exist_ok=True)\n\n    cmaker.CMaker.check_for_bad_installs = lambda: None # barks at our self-built deps\n\n    long_description = open(\"README.md\", encoding=\"utf-8\").read()\n    long_description = long_description.replace(\"![](Other\", \"![](https://raw.githubusercontent.com/OGRECave/ogre/master/Other\")\n    long_description = long_description.replace(\"](Docs\", \"](https://github.com/OGRECave/ogre/blob/master/Docs\")\n\n    cmake_source_dir = \".\"\n    cmake_args = [\n        \"-DOGRE_LIB_DIRECTORY=Ogre\",  # install into Python package\n        \"-DOGRE_BITES_STATIC_PLUGINS=ON\",\n        \"-DOGRE_NODELESS_POSITIONING=OFF\",\n        \"-DOGRE_BUILD_DEPENDENCIES=ON\",\n        \"-DOGRE_INSTALL_DEPENDENCIES=ON\",\n        \"-DOGRE_BUILD_SAMPLES=OFF\",\n        \"-DOGRE_BUILD_TOOLS=OFF\",\n        \"-DOGRE_BUILD_COMPONENT_CSHARP=OFF\",\n        \"-DOGRE_BUILD_COMPONENT_JAVA=OFF\",\n        \"-DOGRE_BUILD_COMPONENT_PROPERTY=OFF\",\n        \"-DOGRE_BUILD_RENDERSYSTEM_GL=ON\",\n        \"-DOGRE_BUILD_RENDERSYSTEM_GL3PLUS=ON\",\n        \"-DOGRE_BUILD_RENDERSYSTEM_GLES2=ON\",\n        \"-DOGRE_BUILD_RENDERSYSTEM_TINY=ON\",\n        \"-DOGRE_BUILD_PLUGIN_ASSIMP=ON\",\n        \"-DOGRE_BUILD_PLUGIN_FREEIMAGE=OFF\",\n        \"-DOGRE_BUILD_PLUGIN_EXRCODEC=OFF\",\n        \"-DOGRE_BUILD_PLUGIN_CG=OFF\",\n        \"-DOGRE_BUILD_PLUGIN_BSP=OFF\",\n        \"-DOGRE_BUILD_PLUGIN_PCZ=OFF\",\n        # not yet wrapped components\n        \"-DOGRE_BUILD_COMPONENT_MESHLODGENERATOR=OFF\",\n        \"-DOGRE_BUILD_COMPONENT_VOLUME=OFF\"\n    ]\n\n    if sys.platform == \"win32\":\n        cmake_args += [\"-DSWIG_EXECUTABLE=C:/ProgramData/chocolatey/bin/swig.exe\",\n                       \"-DOGRE_BIN_DIRECTORY=Ogre\", # direct dlls into python package\n                       \"-DOGRE_CFG_INSTALL_PATH=bin\", # but keep config files in bin, relative to Media\n                       \"-DOGRE_BUILD_RENDERSYSTEM_D3D9=OFF\", # do not require old runtime\n                       \"-DOGRE_BUILD_RENDERSYSTEM_VULKAN=ON\",\n                       \"-DOGRE_BUILD_PLUGIN_GLSLANG=ON\"\n                       ]\n    elif sys.platform == \"linux\":\n        cmake_args += [\"-DOGRE_GLSUPPORT_USE_EGL=ON\",\n                       \"-DOGRE_BUILD_RENDERSYSTEM_VULKAN=ON\",\n                       \"-DOGRE_BUILD_PLUGIN_GLSLANG=ON\",\n                       \"-DCMAKE_CXX_FLAGS=-s\", # strip assimp\n                       \"-DCMAKE_INSTALL_RPATH=$ORIGIN;$ORIGIN/OGRE\"]\n    elif sys.platform == \"darwin\":\n        cmake_args += [\"-DOGRE_BUILD_LIBS_AS_FRAMEWORKS=OFF\",\n                       \"-DCMAKE_INSTALL_RPATH=@loader_path;@loader_path/OGRE\"]\n\n    version = re.search(\"project\\(OGRE VERSION (\\S+)\\)\", open(\"CMakeLists.txt\").read()).group(1)\n    # version += \".dev0\"\n\n    skbuild.setup(\n        name=\"ogre-python\",\n        version=version,\n        url=\"https://www.ogre3d.org\",\n        project_urls={\n            'Documentation': 'https://ogrecave.github.io/ogre/api/latest/manual.html',\n            'Source code': 'https://github.com/OGRECave/ogre',\n            'Issues': 'https://github.com/OGRECave/ogre/issues',\n            \"Funding\": \"https://www.patreon.com/ogre1\"\n        },\n        license=\"MIT\",\n        description=\"Object-Oriented Graphics Rendering Engine - python package\",\n        long_description=long_description,\n        long_description_content_type=\"text/markdown\",\n        packages=[\"Ogre\"],\n        package_data={},\n        maintainer=\"Pavel Rojtberg\",\n        ext_modules=EmptyListWithLength(),\n        python_requires=\">=3.6\",\n        classifiers=[\n            \"Development Status :: 5 - Production/Stable\",\n            \"Environment :: Console\",\n            \"Intended Audience :: Developers\",\n            \"Intended Audience :: Education\",\n            \"Intended Audience :: Information Technology\",\n            \"Intended Audience :: Science/Research\",\n            \"License :: OSI Approved :: MIT License\",\n            \"Operating System :: MacOS\",\n            \"Operating System :: Microsoft :: Windows\",\n            \"Operating System :: POSIX\",\n            \"Operating System :: Unix\",\n            \"Programming Language :: Python\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: 3 :: Only\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: C++\",\n            \"Programming Language :: Python :: Implementation :: CPython\",\n            \"Topic :: Scientific/Engineering\",\n            \"Topic :: Multimedia :: Graphics :: 3D Rendering\",\n            \"Topic :: Software Development\",\n        ],\n        cmake_args=cmake_args,\n        cmake_source_dir=cmake_source_dir,\n        cmake_process_manifest_hook=cmake_process_manifest_hook\n    )\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"pip\", \"swig\"]\n"
  },
  "benfred/implicit": {
    "setup.py": "import io\nimport os.path\n\nfrom packaging.version import Version\nfrom setuptools import find_packages\nfrom skbuild import setup\nfrom skbuild.cmaker import get_cmake_version\nfrom skbuild.exceptions import SKBuildError\n\ntry:\n    import numpy.distutils  # noqa\nexcept ImportError:\n    pass\n\n# Add CMake as a build requirement if cmake is not installed or is too low a version\nsetup_requires = []\ntry:\n    if Version(get_cmake_version()) < Version(\"3.17\"):\n        setup_requires.append(\"cmake>=3.17\")\nexcept SKBuildError:\n    setup_requires.append(\"cmake>=3.17\")\n\n\ndef read(file_name):\n    \"\"\"Read a text file and return the content as a string.\"\"\"\n    file_path = os.path.join(os.path.dirname(__file__), file_name)\n    with io.open(file_path, encoding=\"utf-8\") as f:\n        return f.read()\n\n\ndef exclude_non_implicit_cmake_files(cmake_manifest):\n    # we seem to be picking up a bunch of unrelated files from thrust/spdlog/rmm\n    # filter the cmake manifest down to things from this package only\n    return [f for f in cmake_manifest if \"implicit\" in f]\n\n\nsetup(\n    name=\"implicit\",\n    version=\"0.6.2\",\n    description=\"Collaborative Filtering for Implicit Feedback Datasets\",\n    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    url=\"http://github.com/benfred/implicit/\",\n    author=\"Ben Frederickson\",\n    author_email=\"ben@benfrederickson.com\",\n    license=\"MIT\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Natural Language :: English\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Cython\",\n        \"Operating System :: OS Independent\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n    ],\n    keywords=(\n        \"Matrix Factorization, Implicit Alternating Least Squares, \"\n        \"Collaborative Filtering, Recommender Systems\"\n    ),\n    packages=find_packages(),\n    install_requires=[\"numpy\", \"scipy>=0.16\", \"tqdm>=4.27\"],\n    setup_requires=setup_requires,\n    cmake_process_manifest_hook=exclude_non_implicit_cmake_files,\n)\n",
    "pyproject.toml": "[tool.black]\n\nline-length = 100\n\n[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build>=0.13.1\",\n    \"Cython>=0.24\",\n    \"scipy>=0.16\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\n# skip testing in the cibuildwheel phase, will install the wheels later\n# and verify\ntest-command = \"\"\nskip = [\"pp*\", \"*musl*\",  \"*-manylinux_i686\", \"*win32\"]\n\n[[tool.cibuildwheel.overrides]]\nselect = \"*-manylinux_x86_64*\"\nbefore-all = \"ci/install_cuda.sh\"\n\n# auditwheel includes cuda libraries, just skip it\n[tool.cibuildwheel.linux]\nrepair-wheel-command = \"\"\n\n[tool.cibuildwheel.linux.environment]\nCUDACXX = \"/usr/local/cuda/bin/nvcc\"\n\n# Build `universal2` and `arm64` wheels on an Intel runner.\n# Note that the `arm64` wheel and the `arm64` part of the `universal2`\n# wheel cannot be tested in this configuration.\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"universal2\", \"arm64\"]\n\n\n\n[tool.pytest.ini_options]\nfilterwarnings = ['ignore::implicit.utils.ParameterWarning']\n",
    "setup.cfg": "[bumpversion]\ncurrent_version = 0.6.2\ncommit = True\ntag = True\n\n[metadata]\ndescription-file = README.md\n\n[flake8]\nmax-line-length = 100\nexclude = build,.eggs,.tox\nignore = E203,W503\n\n[isort]\nmulti_line_output = 3\ninclude_trailing_comma = True\nforce_grid_wrap = 0\nuse_parentheses = True\nensure_newline_before_comments = True\nknown_first_party = implicit\nknown_third_party = scipy,annoy,numpy,cython,pandas\nline_length = 100\nskip = build,.eggs,.tox\n\n[codespell]\nskip = ./.git,./.github,./build,./dist,./docs/build,.*egg-info.*,*.csv,*.tsv\nignore-words-list = als,coo,nd,unparseable,compiletime\n\n[bumpversion:file:implicit/__init__.py]\n\n[bumpversion:file:setup.py]\n"
  },
  "surge-synthesizer/surge": {
    "src/surge-python/setup.py": "\"\"\"\nPython package details for surgepy.\n\nSurgepy can be built and installed as a Python package by running\n\n    $ python3 -m pip install <REPO_DIR>/src/surge-python\n\nwhere <REPO_DIR> is the surge repo.\n\nThis uses scikit-build, a tool for packaging Python extensions built\nwith CMake. For more information see https://scikit-build.readthedocs.io\n\"\"\"\nfrom skbuild import setup\n\n\ndef just_surgepy(cmake_manifest):\n    return [x for x in cmake_manifest if \"surgepy\" in x]\n\n\nsetup(\n    name=\"surgepy\",\n    version=\"0.1.0\",\n    description=\"Python bindings for Surge XT synth\",\n    license=\"GPLv3\",\n    python_requires=\">=3.7\",\n    install_requires=[\"numpy\"],\n    packages=[\"surgepy\"],\n    cmake_source_dir=\"../..\",\n    cmake_args=[\n        \"-DSURGE_BUILD_PYTHON_BINDINGS=TRUE\",\n        \"-DSURGE_SKIP_JUCE_FOR_RACK=TRUE\",\n        \"-DSURGE_SKIP_ODDSOUND_MTS=TRUE\",\n        \"-DSURGE_SKIP_VST3=TRUE\",\n        \"-DSURGE_SKIP_ALSA=TRUE\",\n        \"-DSURGE_SKIP_STANDALONE=TRUE\",\n    ],\n    cmake_process_manifest_hook=just_surgepy,\n)\n",
    "src/surge-python/pyproject.toml": "# Further python package details for surgepy\n# See also: setup.py\n[build-system]\nrequires = [\n    \"setuptools\",\n    \"scikit-build>=0.13\",\n    \"cmake\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\n\n[tool.cibuildwheel]\ncontainer-engine = \"podman\"\nbuild-verbosity = 3\nbuild = [\n    \"cp37-manylinux_x86_64\",\n    \"cp38-manylinux_x86_64\",\n    \"cp39-manylinux_x86_64\",\n    \"cp310-manylinux_x86_64\",\n    \"cp311-manylinux_x86_64\",\n]\ntest-requires = \"pytest\"\ntest-command = \"pytest {project}/src/surge-python/\"\n"
  },
  "maxbachmann/RapidFuzz": {
    "setup.py": "from __future__ import annotations\n\nimport os\n\n\ndef show_message(*lines):\n    print(\"=\" * 74)\n    for line in lines:\n        print(line)\n    print(\"=\" * 74)\n\n\nwith open(\"README.md\", encoding=\"utf8\") as f:\n    readme = f.read()\n\nsetup_args = {\n    \"name\": \"rapidfuzz\",\n    \"version\": \"3.0.0\",\n    \"extras_require\": {\"full\": [\"numpy\"]},\n    \"url\": \"https://github.com/maxbachmann/RapidFuzz\",\n    \"author\": \"Max Bachmann\",\n    \"author_email\": \"pypi@maxbachmann.de\",\n    \"description\": \"rapid fuzzy string matching\",\n    \"long_description\": readme,\n    \"long_description_content_type\": \"text/markdown\",\n    \"license\": \"MIT\",\n    \"classifiers\": [\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"License :: OSI Approved :: MIT License\",\n    ],\n    \"packages\": [\"rapidfuzz\", \"rapidfuzz.distance\", \"rapidfuzz.__pyinstaller\"],\n    \"entry_points\": {\n        \"pyinstaller40\": [\n            \"hook-dirs = rapidfuzz.__pyinstaller:get_hook_dirs\",\n            \"tests = rapidfuzz.__pyinstaller:get_PyInstaller_tests\",\n        ],\n    },\n    \"package_dir\": {\n        \"\": \"src\",\n    },\n    \"package_data\": {\n        \"rapidfuzz\": [\"*.pyi\", \"py.typed\", \"__init__.pxd\", \"rapidfuzz.h\"],\n        \"rapidfuzz.distance\": [\"*.pyi\"],\n    },\n    \"python_requires\": \">=3.7\",\n}\n\n\ndef run_setup(with_binary):\n    if with_binary:\n        from skbuild import setup\n\n        setup(**setup_args)\n    else:\n        from setuptools import setup\n\n        setup(**setup_args)\n\n\n# when packaging only build wheels which include the C extension\npackaging = \"1\" in {\n    os.environ.get(\"CIBUILDWHEEL\", \"0\"),\n    os.environ.get(\"CONDA_BUILD\", \"0\"),\n    os.environ.get(\"PIWHEELS_BUILD\", \"0\"),\n    os.environ.get(\"RAPIDFUZZ_BUILD_EXTENSION\", \"0\"),\n}\nif packaging:\n    run_setup(True)\nelse:\n    try:\n        run_setup(True)\n    except BaseException:\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups are not enabled.\",\n            \"Failure information, if any, is above.\",\n            \"Retrying the build without the C extension now.\",\n        )\n        run_setup(False)\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups are not enabled.\",\n            \"Plain-Python build succeeded.\",\n        )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build~=0.17.0\",\n    \"Cython==3.0.0b2\"\n]\nbuild-backend = \"backend\"\nbackend-path = [\"_custom_build\"]\n\n[tool.black]\nline-length = 120\n\n[tool.mypy]\nfiles = [\"src\"]\npython_version = \"3.7\"\nwarn_unused_configs = true\nshow_error_codes = true\nenable_error_code = [\"ignore-without-code\", \"redundant-expr\", \"truthy-bool\"]\nstrict = true\ndisallow_untyped_defs = false\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\ntestpaths = [\"tests\"]\naddopts = [\"-ra\", \"--showlocals\", \"--strict-markers\", \"--strict-config\"]\nnorecursedirs = [\"_skbuild\"]\nxfail_strict = true\nlog_cli_level = \"info\"\n\n[tool.pylint]\npy-version = \"3.7\"\n\n[tool.pylint.reports]\noutput-format = \"colorized\"\n\n[tool.pylint.messages_control]\ndisable = [\n  \"design\",\n  \"fixme\",\n  \"imports\",\n  \"line-too-long\",\n  \"imports\",\n  \"invalid-name\",\n  \"protected-access\",\n  \"missing-module-docstring\",\n]\n\n\n[tool.ruff]\nselect = [\n  \"E\", \"F\", \"W\", # flake8\n  \"B\",           # flake8-bugbear\n  \"I\",           # isort\n  \"ARG\",         # flake8-unused-arguments\n  \"C4\",          # flake8-comprehensions\n  \"EM\",          # flake8-errmsg\n  \"ICN\",         # flake8-import-conventions\n  \"ISC\",         # flake8-implicit-str-concat\n  \"G\",           # flake8-logging-format\n  \"PGH\",         # pygrep-hooks\n  \"PIE\",         # flake8-pie\n  \"PL\",          # pylint\n  \"PT\",          # flake8-pytest-style\n  \"PTH\",         # flake8-use-pathlib\n  \"RET\",         # flake8-return\n  \"RUF\",         # Ruff-specific\n  \"SIM\",         # flake8-simplify\n  \"T20\",         # flake8-print\n  \"UP\",          # pyupgrade\n  \"YTT\",         # flake8-2020\n  \"EXE\",         # flake8-executable\n  \"NPY\",         # NumPy specific rules\n  \"PD\",          # pandas-vet\n]\nextend-ignore = [\n  \"PLR\",    # Design related pylint codes\n  \"E501\",   # Line too long\n  \"PT004\",  # Use underscore for non-returning fixture (use usefixture instead)\n  \"PTH123\", # use pathlib instead of builtin open\n]\ntarget-version = \"py37\"\nsrc = [\"src\"]\nunfixable = [\n  \"T20\",  # Removes print statements\n  \"F841\", # Removes unused variables\n]\nexclude = []\nflake8-unused-arguments.ignore-variadic-names = true\nisort.required-imports = [\"from __future__ import annotations\"]\n\n[tool.ruff.per-file-ignores]\n\"tests/**\" = [\"T20\"]\n\"bench/**\" = [\"T20\"]\n\"_custom_build/backend.py\" = [\"T20\"]\n\"setup.py\" = [\"T20\"]\n"
  },
  "pyutils/line_profiler": {
    "setup.py": "#!/usr/bin/env python\nfrom os.path import exists\nimport sys\nimport os\nimport warnings\nimport setuptools\n\n\ndef _choose_build_method():\n    DISABLE_C_EXTENSIONS = os.environ.get(\"DISABLE_C_EXTENSIONS\", \"\").lower()\n    LINE_PROFILER_BUILD_METHOD = os.environ.get(\"LINE_PROFILER_BUILD_METHOD\", \"auto\").lower()\n\n    if DISABLE_C_EXTENSIONS in {\"true\", \"on\", \"yes\", \"1\"}:\n        LINE_PROFILER_BUILD_METHOD = 'setuptools'\n\n    if LINE_PROFILER_BUILD_METHOD == 'auto':\n        try:\n            import Cython  # NOQA\n        except ImportError:\n            try:\n                import skbuild  # NOQA\n                import cmake  # NOQA\n                import ninja  # NOQA\n            except ImportError:\n                # The main fallback disables c-extensions\n                LINE_PROFILER_BUILD_METHOD = 'setuptools'\n            else:\n                # This should never be hit\n                LINE_PROFILER_BUILD_METHOD = 'scikit-build'\n        else:\n            # Use plain cython by default\n            LINE_PROFILER_BUILD_METHOD = 'cython'\n\n    return LINE_PROFILER_BUILD_METHOD\n\n\ndef parse_version(fpath):\n    \"\"\"\n    Statically parse the version number from a python file\n    \"\"\"\n    value = static_parse(\"__version__\", fpath)\n    return value\n\n\ndef static_parse(varname, fpath):\n    \"\"\"\n    Statically parse the a constant variable from a python file\n    \"\"\"\n    import ast\n\n    if not exists(fpath):\n        raise ValueError(\"fpath={!r} does not exist\".format(fpath))\n    with open(fpath, \"r\") as file_:\n        sourcecode = file_.read()\n    pt = ast.parse(sourcecode)\n\n    class StaticVisitor(ast.NodeVisitor):\n        def visit_Assign(self, node):\n            for target in node.targets:\n                if getattr(target, \"id\", None) == varname:\n                    self.static_value = node.value.s\n\n    visitor = StaticVisitor()\n    visitor.visit(pt)\n    try:\n        value = visitor.static_value\n    except AttributeError:\n        value = \"Unknown {}\".format(varname)\n        warnings.warn(value)\n    return value\n\n\ndef parse_description():\n    \"\"\"\n    Parse the description in the README file\n\n    CommandLine:\n        pandoc --from=markdown --to=rst --output=README.rst README.md\n        python -c \"import setup; print(setup.parse_description())\"\n    \"\"\"\n    from os.path import dirname, join, exists\n\n    readme_fpath = join(dirname(__file__), \"README.rst\")\n    # This breaks on pip install, so check that it exists.\n    if exists(readme_fpath):\n        with open(readme_fpath, \"r\") as f:\n            text = f.read()\n        return text\n    return \"\"\n\n\ndef parse_requirements(fname=\"requirements.txt\", versions=False):\n    \"\"\"\n    Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        versions (bool | str, default=False):\n            If true include version specs.\n            If strict, then pin to the minimum version.\n\n    Returns:\n        List[str]: list of requirements items\n    \"\"\"\n    from os.path import exists, dirname, join\n    import re\n\n    require_fpath = fname\n\n    def parse_line(line, dpath=\"\"):\n        \"\"\"\n        Parse information from a line in a requirements text file\n\n        line = 'git+https://a.com/somedep@sometag#egg=SomeDep'\n        line = '-e git+https://a.com/somedep@sometag#egg=SomeDep'\n        \"\"\"\n        # Remove inline comments\n        comment_pos = line.find(\" #\")\n        if comment_pos > -1:\n            line = line[:comment_pos]\n\n        if line.startswith(\"-r \"):\n            # Allow specifying requirements in other files\n            target = join(dpath, line.split(\" \")[1])\n            for info in parse_require_file(target):\n                yield info\n        else:\n            # See: https://www.python.org/dev/peps/pep-0508/\n            info = {\"line\": line}\n            if line.startswith(\"-e \"):\n                info[\"package\"] = line.split(\"#egg=\")[1]\n            else:\n                if \";\" in line:\n                    pkgpart, platpart = line.split(\";\")\n                    # Handle platform specific dependencies\n                    # setuptools.readthedocs.io/en/latest/setuptools.html\n                    # #declaring-platform-specific-dependencies\n                    plat_deps = platpart.strip()\n                    info[\"platform_deps\"] = plat_deps\n                else:\n                    pkgpart = line\n                    platpart = None\n\n                # Remove versioning from the package\n                pat = \"(\" + \"|\".join([\">=\", \"==\", \">\"]) + \")\"\n                parts = re.split(pat, pkgpart, maxsplit=1)\n                parts = [p.strip() for p in parts]\n\n                info[\"package\"] = parts[0]\n                if len(parts) > 1:\n                    op, rest = parts[1:]\n                    version = rest  # NOQA\n                    info[\"version\"] = (op, version)\n            yield info\n\n    def parse_require_file(fpath):\n        dpath = dirname(fpath)\n        with open(fpath, \"r\") as f:\n            for line in f.readlines():\n                line = line.strip()\n                if line and not line.startswith(\"#\"):\n                    for info in parse_line(line, dpath=dpath):\n                        yield info\n\n    def gen_packages_items():\n        if exists(require_fpath):\n            for info in parse_require_file(require_fpath):\n                parts = [info[\"package\"]]\n                if versions and \"version\" in info:\n                    if versions == \"strict\":\n                        # In strict mode, we pin to the minimum version\n                        if info[\"version\"]:\n                            # Only replace the first >= instance\n                            verstr = \"\".join(info[\"version\"]).replace(\">=\", \"==\", 1)\n                            parts.append(verstr)\n                    else:\n                        parts.extend(info[\"version\"])\n                if not sys.version.startswith(\"3.4\"):\n                    # apparently package_deps are broken in 3.4\n                    plat_deps = info.get(\"platform_deps\")\n                    if plat_deps is not None:\n                        parts.append(\";\" + plat_deps)\n                item = \"\".join(parts)\n                yield item\n\n    packages = list(gen_packages_items())\n    return packages\n\n\nlong_description = \"\"\"\\\nline_profiler will profile the time individual lines of code take to execute.\nThe profiler is implemented in C via Cython in order to reduce the overhead of\nprofiling.\n\nAlso included is the script kernprof.py which can be used to conveniently\nprofile Python applications and scripts either with line_profiler or with the\nfunction-level profiling tools in the Python standard library.\n\"\"\"\n\nVERSION = parse_version('line_profiler/line_profiler.py')\nNAME = 'line_profiler'\n\n\nif __name__ == '__main__':\n    setupkw = {}\n\n    LINE_PROFILER_BUILD_METHOD = _choose_build_method()\n    if LINE_PROFILER_BUILD_METHOD == 'setuptools':\n        setup = setuptools.setup\n    elif LINE_PROFILER_BUILD_METHOD == 'scikit-build':\n        import skbuild  # NOQA\n        setup = skbuild.setup\n    elif LINE_PROFILER_BUILD_METHOD == 'cython':\n        # no need to try importing cython because an import\n        # was already attempted in _choose_build_method\n        import multiprocessing\n        from setuptools import Extension\n        from Cython.Build import cythonize\n\n        def run_cythonize(force=False):\n            return cythonize(\n                Extension(\n                    name=\"line_profiler._line_profiler\",\n                    sources=[\"line_profiler/_line_profiler.pyx\", \"line_profiler/timers.c\", \"line_profiler/unset_trace.c\"],\n                    language=\"c++\",\n                    define_macros=[(\"CYTHON_TRACE\", (1 if os.getenv(\"DEV\") == \"true\" else 0))],\n                ),\n                compiler_directives={\"language_level\": 3, \"infer_types\": True, \"linetrace\": (True if os.getenv(\"DEV\") == \"true\" else False)},\n                include_path=[\"line_profiler/python25.pxd\"],\n                force=force,\n                nthreads=multiprocessing.cpu_count(),\n            )\n\n        setupkw.update(dict(ext_modules=run_cythonize()))\n        setup = setuptools.setup\n    else:\n        raise Exception('Unknown build method')\n\n    setupkw[\"install_requires\"] = parse_requirements(\"requirements/runtime.txt\")\n    setupkw[\"extras_require\"] = {\n        \"all\": parse_requirements(\"requirements.txt\"),\n        \"tests\": parse_requirements(\"requirements/tests.txt\"),\n        \"ipython\": parse_requirements('requirements/ipython.txt'),\n        'build': parse_requirements('requirements/build.txt'),\n        \"runtime-strict\": parse_requirements(\"requirements/runtime.txt\", versions=\"strict\"),\n        \"all-strict\": parse_requirements(\"requirements.txt\", versions=\"strict\"),\n        \"tests-strict\": parse_requirements(\"requirements/tests.txt\", versions=\"strict\"),\n        \"ipython-strict\": parse_requirements('requirements/ipython.txt', versions=\"strict\"),\n        'build-strict': parse_requirements('requirements/build.txt', versions=\"strict\"),\n    }\n    setupkw['entry_points'] = {\n        'console_scripts': [\n            'kernprof=kernprof:main',\n        ],\n    }\n    setupkw[\"name\"] = NAME\n    setupkw[\"version\"] = VERSION\n    setupkw[\"author\"] = \"Robert Kern\"\n    setupkw[\"author_email\"] = \"robert.kern@enthought.com\"\n    setupkw['url'] = 'https://github.com/pyutils/line_profiler'\n    setupkw[\"description\"] = \"Line-by-line profiler\"\n    setupkw[\"long_description\"] = long_description\n    setupkw[\"long_description_content_type\"] = \"text/x-rst\"\n    setupkw[\"license\"] = \"BSD\"\n    setupkw[\"packages\"] = list(setuptools.find_packages())\n    setupkw[\"py_modules\"] = ['kernprof', 'line_profiler']\n    setupkw[\"python_requires\"] = \">=3.6\"\n    setupkw['license_files'] = ['LICENSE.txt', 'LICENSE_Python.txt']\n    setupkw['keywords'] = ['timing', 'timer', 'profiling', 'profiler', 'line_profiler']\n    setupkw[\"classifiers\"] = [\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: OS Independent',\n        'Programming Language :: C',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Topic :: Software Development',\n    ]\n    setup(**setupkw)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=41.0.1\",\n    \"Cython==3.0.0a11            ; python_version < '4.0'  and python_version >= '3.12' \",\n    \"Cython>=0.29.24,<=3.0.0a11  ; python_version < '3.12' \",\n]\nbuild-backend = \"setuptools.build_meta\"  # comment out to disable pep517\n\n[tool.coverage.run]\nbranch = true\n\n[tool.coverage.report]\nexclude_lines =[\n    \"pragma: no cover\",\n    \".*  # pragma: no cover\",\n    \".*  # nocover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if 0:\",\n    \"if trace is not None\",\n    \"verbose = .*\",\n    \"^ *raise\",\n    \"^ *pass *$\",\n    \"if _debug:\",\n    \"if __name__ == .__main__.:\",\n    \".*if six.PY2:\"\n]\n\nomit =[\n    \"*/setup.py\"\n]\n\n[tool.cibuildwheel]\nbuild = \"cp36-* cp37-* cp38-* cp39-* cp310-* cp311-*\"\nbuild-frontend = \"build\"\nbuild-verbosity = 1\ntest-requires = [ \"-r requirements/tests.txt\",]\ntest-command = \"python {project}/run_tests.py\"\n\n[tool.mypy]\nignore_missing_imports = true\n\n[tool.xcookie]\ntags = [ \"pyutils\", \"binpy\", \"github\",]\nmod_name = \"line_profiler\"\nrepo_name = \"line_profiler\"\nrel_mod_parent_dpath = \".\"\nos = [ \"all\", \"linux\", \"osx\", \"win\",]\nmin_python = 3.6\nauthor = \"Robert Kern\"\nauthor_email = \"robert.kern@enthought.com\"\ndescription = \"Line-by-line profiler\"\nurl = \"https://github.com/pyutils/line_profiler\"\nlicense = \"BSD\"\ndev_status = \"stable\"\n\n[tool.pytest.ini_options]\naddopts = \"--ignore-glob=setup.py --ignore-glob=dev\"\nnorecursedirs = \".git ignore build __pycache__ dev _skbuild\"\nfilterwarnings = [\n    \"default\",\n]\n"
  },
  "pytorch/torchrec": {
    "contrib/dynamic_embedding/setup.py": "#!/usr/bin/env python3\n# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nimport os\nimport sys\n\nimport torch\nfrom setuptools import find_packages\n\nfrom skbuild import setup\n\nextra_cmake_args = []\n\nif sys.platform == \"linux\":\n    _nvcc_paths = (\n        []\n        if os.getenv(\"CMAKE_CUDA_COMPILER\") is None\n        else [os.getenv(\"CMAKE_CUDA_COMPILER\")]\n    ) + [\n        \"/usr/bin/nvcc\",\n        \"/usr/local/bin/nvcc\",\n        \"/usr/local/cuda/bin/nvcc\",\n        \"/usr/cuda/bin/nvcc\",\n    ]\n    for _nvcc_path in _nvcc_paths:\n        try:\n            os.stat(_nvcc_path)\n            extra_cmake_args.append(f\"-DCMAKE_CUDA_COMPILER={_nvcc_path}\")\n            break\n        except FileNotFoundError:\n            pass\n    else:\n        raise RuntimeError(f\"Cannot find nvcc in [{','.join(_nvcc_paths)}]\")\n\n    if os.getenv(\"CUDA_TOOLKIT_ROOT_DIR\") is None:\n        extra_cmake_args.append(\n            f'-DCUDA_TOOLKIT_ROOT_DIR={os.path.abspath(os.path.join(os.path.dirname(_nvcc_path), \"..\"))}'\n        )\n    else:\n        extra_cmake_args.append(\n            f\"-DCUDA_TOOLKIT_ROOT_DIR={os.getenv('CUDA_TOOLKIT_ROOT_DIR')}\"\n        )\n\nsetup(\n    name=\"torchrec_dynamic_embedding\",\n    package_dir={\"\": \"src\"},\n    packages=find_packages(\"src\"),\n    cmake_args=[\n        \"-DCMAKE_BUILD_TYPE=Release\",\n        f\"-DTDE_TORCH_BASE_DIR={os.path.dirname(torch.__file__)}\",\n        \"-DTDE_WITH_TESTING=OFF\",\n    ]\n    + extra_cmake_args,\n    cmake_install_dir=\"src\",\n    version=\"0.0.1\",\n)\n"
  },
  "mitsuba-renderer/mitsuba3": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sys, re, os, pathlib\n\ntry:\n    from skbuild import setup\n    import pybind11\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\n\nwith open(os.path.join(\"include/mitsuba/mitsuba.h\")) as f:\n    mi_version_regex = re.compile(\n        r\"^\\s*#\\s*define\\s+MI_VERSION_([A-Z]+)\\s+(.*)$\", re.MULTILINE)\n    matches = dict(mi_version_regex.findall(f.read()))\n    mitsuba_version = \"{MAJOR}.{MINOR}.{PATCH}\".format(**matches)\n\nwith open(os.path.join(\"ext/drjit/include/drjit/fwd.h\")) as f:\n    drjit_version_regex = re.compile(\n        r\"^\\s*#\\s*define\\s+DRJIT_VERSION_([A-Z]+)\\s+(.*)$\", re.MULTILINE)\n    matches = dict(drjit_version_regex.findall(f.read()))\n    drjit_version = \"{MAJOR}.{MINOR}.{PATCH}\".format(**matches)\n\nwith open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nlong_description = long_description[long_description.find('## Introduction'):]\nmi_cmake_toolchain_file = os.environ.get(\"MI_CMAKE_TOOLCHAIN_FILE\", \"\")\nmi_drjit_cmake_dir = os.environ.get(\"MI_DRJIT_CMAKE_DIR\", \"\")\nmi_srgb_coeff_file = os.environ.get(\"MI_SRGB_COEFF_FILE\", \"\")\nmi_python_stubs_dir = os.environ.get(\"MI_PYTHON_STUBS_DIR\", \"\")\npathlib.Path(\"./mitsuba\").mkdir(exist_ok=True)\n\nsetup(\n    name=\"mitsuba\",\n    version=mitsuba_version,\n    author=\"Realistic Graphics Lab (RGL), EPFL\",\n    author_email=\"wenzel.jakob@epfl.ch\",\n    description=\"3: A Retargetable Forward and Inverse Renderer\",\n    url=\"https://github.com/mitsuba-renderer/mitsuba3\",\n    license=\"BSD\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    cmake_args=[\n        '-DCMAKE_INSTALL_LIBDIR=mitsuba',\n        '-DCMAKE_INSTALL_BINDIR=mitsuba',\n        '-DCMAKE_INSTALL_INCLUDEDIR=mitsuba/include',\n        '-DCMAKE_INSTALL_DATAROOTDIR=mitsuba/data',\n        f'-DCMAKE_TOOLCHAIN_FILE={mi_cmake_toolchain_file}',\n        f'-DMI_DRJIT_CMAKE_DIR:STRING={mi_drjit_cmake_dir}',\n        f'-DMI_SRGB_COEFF_FILE:STRING={mi_srgb_coeff_file}',\n        f'-DMI_PYTHON_STUBS_DIR:STRING={mi_python_stubs_dir}'\n    ],\n    install_requires=[f\"drjit=={drjit_version}\"],\n    packages=['mitsuba'],\n    entry_points={\n        'console_scripts': [\n            'mitsuba = mitsuba.cli:_main',\n        ]\n    },\n    python_requires=\">=3.8\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"pybind11>=2.10.1\", \"drjit==0.4.2\"]\n\n[tool.pytest.ini_options]\nnorecursedirs = [ \"ext\" ]\n"
  },
  "rapidsai/cugraph": {
    "python/cugraph/setup.py": "# Copyright (c) 2018-2023, NVIDIA CORPORATION.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\nfrom setuptools import find_packages, Command\nfrom skbuild import setup\n\n\nclass CleanCommand(Command):\n    \"\"\"Custom clean command to tidy up the project root.\"\"\"\n\n    user_options = [\n        (\"all\", None, None),\n    ]\n\n    def initialize_options(self):\n        self.all = None\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        setupFileDir = os.path.dirname(os.path.abspath(__file__))\n        os.chdir(setupFileDir)\n        os.system(\"rm -rf build\")\n        os.system(\"rm -rf dist\")\n        os.system(\"rm -rf dask-worker-space\")\n        os.system('find . -name \"__pycache__\" -type d -exec rm -rf {} +')\n        os.system(\"rm -rf *.egg-info\")\n        os.system('find . -name \"*.cpp\" -type f -delete')\n        os.system('find . -name \"*.cpython*.so\" -type f -delete')\n        os.system(\"rm -rf _skbuild\")\n\n\npackages = find_packages(include=[\"cugraph*\"])\nsetup(\n    packages=packages,\n    package_data={key: [\"*.pxd\", \"*.yaml\"] for key in packages},\n    cmdclass={\"clean\": CleanCommand},\n    zip_safe=False,\n)\n",
    "python/cugraph/pyproject.toml": "# Copyright (c) 2022, NVIDIA CORPORATION.\n\n[build-system]\n\nrequires = [\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"cython>=0.29,<0.30\",\n    \"ninja\",\n    \"pylibcugraph==23.6.*\",\n    \"pylibraft==23.6.*\",\n    \"rmm==23.6.*\",\n    \"scikit-build>=0.13.1,<0.17.2\",\n    \"setuptools\",\n    \"wheel\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"cugraph/tests\"]\n\n[project]\nname = \"cugraph\"\nversion = \"23.06.00\"\ndescription = \"cuGraph - RAPIDS GPU Graph Analytics\"\nreadme = { file = \"README.md\", content-type = \"text/markdown\" }\nauthors = [\n    { name = \"NVIDIA Corporation\" },\n]\nlicense = { text = \"Apache 2.0\" }\nrequires-python = \">=3.9\"\ndependencies = [\n    \"cudf==23.6.*\",\n    \"cupy-cuda11x>=12.0.0\",\n    \"dask-cuda==23.6.*\",\n    \"dask-cudf==23.6.*\",\n    \"dask==2023.3.2\",\n    \"distributed==2023.3.2.1\",\n    \"numba>=0.56.4,<0.57\",\n    \"pylibcugraph==23.6.*\",\n    \"raft-dask==23.6.*\",\n    \"rmm==23.6.*\",\n    \"ucx-py==0.32.*\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"aiohttp\",\n    \"fsspec[http]>=0.6.0\",\n    \"networkx>=2.5.1\",\n    \"numpy>=1.21,<1.24\",\n    \"pandas\",\n    \"pytest\",\n    \"pytest-benchmark\",\n    \"pytest-cov\",\n    \"pytest-xdist\",\n    \"python-louvain\",\n    \"requests\",\n    \"scikit-learn>=0.23.1\",\n    \"scipy\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project.urls]\nHomepage = \"https://github.com/rapidsai/cugraph\"\nDocumentation = \"https://docs.rapids.ai/api/cugraph/stable/\"\n\n[tool.setuptools]\nlicense-files = [\"LICENSE\"]\n",
    "python/pylibcugraph/setup.py": "# Copyright (c) 2018-2023, NVIDIA CORPORATION.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\nfrom setuptools import find_packages, Command\nfrom skbuild import setup\n\n\nclass CleanCommand(Command):\n    \"\"\"Custom clean command to tidy up the project root.\"\"\"\n\n    user_options = [\n        (\"all\", None, None),\n    ]\n\n    def initialize_options(self):\n        self.all = None\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        setupFileDir = os.path.dirname(os.path.abspath(__file__))\n        os.chdir(setupFileDir)\n        os.system(\"rm -rf build\")\n        os.system(\"rm -rf dist\")\n        os.system(\"rm -rf dask-worker-space\")\n        os.system('find . -name \"__pycache__\" -type d -exec rm -rf {} +')\n        os.system(\"rm -rf *.egg-info\")\n        os.system('find . -name \"*.cpp\" -type f -delete')\n        os.system('find . -name \"*.cpython*.so\" -type f -delete')\n        os.system(\"rm -rf _skbuild\")\n\n\ndef exclude_libcxx_symlink(cmake_manifest):\n    return list(\n        filter(\n            lambda name: not (\"include/rapids/libcxx/include\" in name), cmake_manifest\n        )\n    )\n\n\npackages = find_packages(include=[\"pylibcugraph*\"])\nsetup(\n    packages=packages,\n    package_data={key: [\"*.pxd\"] for key in packages},\n    cmake_process_manifest_hook=exclude_libcxx_symlink,\n    cmdclass={\"clean\": CleanCommand},\n    zip_safe=False,\n)\n",
    "python/pylibcugraph/pyproject.toml": "# Copyright (c) 2022, NVIDIA CORPORATION.\n\n[build-system]\n\nrequires = [\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"cython>=0.29,<0.30\",\n    \"ninja\",\n    \"pylibraft==23.6.*\",\n    \"rmm==23.6.*\",\n    \"scikit-build>=0.13.1,<0.17.2\",\n    \"setuptools\",\n    \"wheel\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"pylibcugraph/tests\"]\n\n[project]\nname = \"pylibcugraph\"\nversion = \"23.06.00\"\ndescription = \"pylibcugraph - Python bindings for the libcugraph cuGraph C/C++/CUDA library\"\nreadme = { file = \"README.md\", content-type = \"text/markdown\" }\nauthors = [\n    { name = \"NVIDIA Corporation\" },\n]\nlicense = { text = \"Apache 2.0\" }\nrequires-python = \">=3.9\"\ndependencies = [\n    \"pylibraft==23.6.*\",\n    \"rmm==23.6.*\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"cudf==23.6.*\",\n    \"networkx>=2.5.1\",\n    \"numpy>=1.21,<1.24\",\n    \"pandas\",\n    \"pytest\",\n    \"pytest-benchmark\",\n    \"pytest-cov\",\n    \"pytest-xdist\",\n    \"scipy\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project.urls]\nHomepage = \"https://github.com/rapidsai/cugraph\"\nDocumentation = \"https://docs.rapids.ai/api/cugraph/stable/\"\n\n[tool.setuptools]\nlicense-files = [\"LICENSE\"]\n"
  },
  "mitsuba-renderer/nanogui": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sys, re, os\n\ntry:\n    from skbuild import setup\n    import nanobind\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nVERSION_REGEX = re.compile(\n    r\"^\\s*#\\s*define\\s+NANOGUI_VERSION_([A-Z]+)\\s+(.*)$\", re.MULTILINE)\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\n\nwith open(os.path.join(\"include/nanogui/common.h\")) as f:\n    matches = dict(VERSION_REGEX.findall(f.read()))\n    nanogui_version = \"{MAJOR}.{MINOR}.{PATCH}\".format(**matches)\n\nlong_description = \\\n'''NanoGUI is a minimalistic cross-platform widget library for OpenGL 3+, GLES\n2/3, and Metal. It supports automatic layout generation, stateful C++ lambdas\ncallbacks, a variety of useful widget types and Retina-capable rendering on\nApple devices thanks to NanoVG by Mikko Mononen. Python bindings of all\nfunctionality are provided using nanobind.'''\n\nsetup(\n    name=\"nanogui\",\n    version=nanogui_version,\n    author=\"Wenzel Jakob\",\n    author_email=\"wenzel.jakob@epfl.ch\",\n    description='A minimalistic GUI library for OpenGL, GLES 2, and Metal',\n    url=\"https://github.com/mitsuba-renderer/nanogui\",\n    license=\"BSD\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    cmake_args=[\n        '-DCMAKE_INSTALL_LIBDIR=nanogui',\n        '-DCMAKE_INSTALL_BINDIR=nanogui',\n        '-DCMAKE_INSTALL_INCLUDEDIR=nanogui/include',\n        '-DCMAKE_INSTALL_DATAROOTDIR=nanogui/share',\n        '-DNANOGUI_BUILD_EXAMPLES=OFF'\n    ],\n    packages=['nanogui']\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"nanobind>=0.0.8\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "abetlen/llama-cpp-python": {
    "setup.py": "from skbuild import setup\n\nfrom pathlib import Path\n\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text(encoding=\"utf-8\")\n\nsetup(\n    name=\"llama_cpp_python\",\n    description=\"A Python wrapper for llama.cpp\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    version=\"0.1.50\",\n    author=\"Andrei Betlen\",\n    author_email=\"abetlen@gmail.com\",\n    license=\"MIT\",\n    package_dir={\"llama_cpp\": \"llama_cpp\", \"llama_cpp.server\": \"llama_cpp/server\"},\n    packages=[\"llama_cpp\", \"llama_cpp.server\"],\n    install_requires=[\n        \"typing-extensions>=4.5.0\",\n    ],\n    extras_require={\n        \"server\": [\"uvicorn>=0.21.1\", \"fastapi>=0.95.0\", \"sse-starlette>=1.3.3\"],\n    },\n    python_requires=\">=3.7\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n)\n",
    "pyproject.toml": "[tool.poetry]\nname = \"llama_cpp_python\"\nversion = \"0.1.50\"\ndescription = \"Python bindings for the llama.cpp library\"\nauthors = [\"Andrei Betlen <abetlen@gmail.com>\"]\nlicense = \"MIT\"\nreadme = \"README.md\"\nhomepage = \"https://github.com/abetlen/llama-cpp-python\"\nrepository = \"https://github.com/abetlen/llama-cpp-python\"\npackages = [{include = \"llama_cpp\"}]\ninclude = [\n    \"LICENSE.md\",\n]\n\n[tool.poetry.dependencies]\npython = \"^3.8.1\"\ntyping-extensions = \"^4.5.0\"\n\n\n[tool.poetry.group.dev.dependencies]\nblack = \"^23.3.0\"\ntwine = \"^4.0.2\"\nmkdocs = \"^1.4.3\"\nmkdocstrings = {extras = [\"python\"], version = \"^0.21.2\"}\nmkdocs-material = \"^9.1.12\"\npytest = \"^7.3.1\"\nhttpx = \"^0.24.0\"\n\n[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13\",\n    \"cmake>=3.18\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "deepmodeling/deepmd-kit": {
    "setup.py": "\"\"\"Setup script for DeePMD-kit package.\"\"\"\n\nimport os\nimport sys\n\nfrom packaging.version import (\n    Version,\n)\nfrom skbuild import (\n    setup,\n)\nfrom wheel.bdist_wheel import (\n    bdist_wheel,\n)\n\ntopdir = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, os.path.join(topdir, \"backend\"))\n\nfrom find_tensorflow import (\n    find_tensorflow,\n    get_tf_requirement,\n    get_tf_version,\n)\n\ncmake_args = []\nextra_scripts = []\n# get variant option from the environment varibles, available: cpu, cuda, rocm\ndp_variant = os.environ.get(\"DP_VARIANT\", \"cpu\").lower()\nif dp_variant == \"cpu\" or dp_variant == \"\":\n    pass\nelif dp_variant == \"cuda\":\n    cmake_args.append(\"-DUSE_CUDA_TOOLKIT:BOOL=TRUE\")\n    cuda_root = os.environ.get(\"CUDA_TOOLKIT_ROOT_DIR\")\n    if cuda_root:\n        cmake_args.append(f\"-DCUDA_TOOLKIT_ROOT_DIR:STRING={cuda_root}\")\nelif dp_variant == \"rocm\":\n    cmake_args.append(\"-DUSE_ROCM_TOOLKIT:BOOL=TRUE\")\n    rocm_root = os.environ.get(\"ROCM_ROOT\")\n    if rocm_root:\n        cmake_args.append(f\"-DCMAKE_HIP_COMPILER_ROCM_ROOT:STRING={rocm_root}\")\n    hipcc_flags = os.environ.get(\"HIP_HIPCC_FLAGS\")\n    if hipcc_flags:\n        cmake_args.append(f\"-DHIP_HIPCC_FLAGS:STRING={hipcc_flags}\")\nelse:\n    raise RuntimeError(\"Unsupported DP_VARIANT option: %s\" % dp_variant)\n\nif os.environ.get(\"DP_BUILD_TESTING\", \"0\") == \"1\":\n    cmake_args.append(\"-DBUILD_TESTING:BOOL=TRUE\")\nif os.environ.get(\"DP_ENABLE_NATIVE_OPTIMIZATION\", \"0\") == \"1\":\n    cmake_args.append(\"-DENABLE_NATIVE_OPTIMIZATION:BOOL=TRUE\")\ndp_lammps_version = os.environ.get(\"DP_LAMMPS_VERSION\", \"\")\ndp_ipi = os.environ.get(\"DP_ENABLE_IPI\", \"0\")\nif dp_lammps_version != \"\" or dp_ipi == \"1\":\n    cmake_args.append(\"-DBUILD_CPP_IF:BOOL=TRUE\")\n    cmake_args.append(\"-DUSE_TF_PYTHON_LIBS:BOOL=TRUE\")\nelse:\n    cmake_args.append(\"-DBUILD_CPP_IF:BOOL=FALSE\")\n\nif dp_lammps_version != \"\":\n    cmake_args.append(f\"-DLAMMPS_VERSION={dp_lammps_version}\")\nif dp_ipi == \"1\":\n    cmake_args.append(\"-DENABLE_IPI:BOOL=TRUE\")\n    extra_scripts.append(\"dp_ipi = deepmd.entrypoints.ipi:dp_ipi\")\n\n\ntf_install_dir, _ = find_tensorflow()\ntf_version = get_tf_version(tf_install_dir)\n# TODO: change to \"tf_version == \"\" or\" after tensorflow 2.12 is released\nif tf_version != \"\" and Version(tf_version) >= Version(\"2.12\"):\n    find_libpython_requires = []\nelse:\n    find_libpython_requires = [\"find_libpython\"]\n\n\nclass bdist_wheel_abi3(bdist_wheel):\n    def get_tag(self):\n        python, abi, plat = super().get_tag()\n        if python.startswith(\"cp\"):\n            return \"py37\", \"none\", plat\n        return python, abi, plat\n\n\n# TODO: migrate packages and entry_points to pyproject.toml after scikit-build supports it\n# See also https://scikit-build.readthedocs.io/en/latest/usage.html#setuptools-options\nsetup(\n    packages=[\n        \"deepmd\",\n        \"deepmd/descriptor\",\n        \"deepmd/fit\",\n        \"deepmd/infer\",\n        \"deepmd/loss\",\n        \"deepmd/utils\",\n        \"deepmd/loggers\",\n        \"deepmd/cluster\",\n        \"deepmd/entrypoints\",\n        \"deepmd/op\",\n        \"deepmd/model\",\n        \"deepmd/train\",\n        \"deepmd/nvnmd\",\n        \"deepmd/nvnmd/data\",\n        \"deepmd/nvnmd/descriptor\",\n        \"deepmd/nvnmd/entrypoints\",\n        \"deepmd/nvnmd/fit\",\n        \"deepmd/nvnmd/utils\",\n    ],\n    cmake_args=[\n        f\"-DTENSORFLOW_ROOT:PATH={tf_install_dir}\",\n        \"-DBUILD_PY_IF:BOOL=TRUE\",\n        *cmake_args,\n    ],\n    cmake_source_dir=\"source\",\n    cmake_minimum_required_version=\"3.16\",\n    extras_require={\n        \"test\": [\"dpdata>=0.1.9\", \"ase\", \"pytest\", \"pytest-cov\", \"pytest-sugar\"],\n        \"docs\": [\n            \"sphinx>=3.1.1\",\n            \"recommonmark\",\n            \"sphinx_rtd_theme>=1.0.0rc1\",\n            \"sphinx_markdown_tables\",\n            \"myst-parser\",\n            \"breathe\",\n            \"exhale\",\n            \"numpydoc\",\n            \"ase\",\n            \"deepmodeling-sphinx>=0.1.0\",\n            \"dargs>=0.3.4\",\n            \"sphinx-argparse\",\n            \"pygments-lammps\",\n        ],\n        \"lmp\": [\n            \"lammps-manylinux-2-28~=2022.6.23.3.0; platform_system=='Linux'\",\n            \"lammps~=2022.6.23.3.0; platform_system!='Linux'\",\n            *find_libpython_requires,\n        ],\n        \"ipi\": [\n            \"i-PI\",\n            *find_libpython_requires,\n        ],\n        **get_tf_requirement(tf_version),\n        \"cu11\": [\n            \"nvidia-cuda-runtime-cu11\",\n            \"nvidia-cublas-cu11\",\n            \"nvidia-cufft-cu11\",\n            \"nvidia-curand-cu11\",\n            \"nvidia-cusolver-cu11\",\n            \"nvidia-cusparse-cu11\",\n            \"nvidia-cudnn-cu11\",\n        ],\n        \"cu12\": [\n            \"nvidia-cuda-runtime-cu12\",\n            \"nvidia-cublas-cu12\",\n            \"nvidia-cufft-cu12\",\n            \"nvidia-curand-cu12\",\n            \"nvidia-cusolver-cu12\",\n            \"nvidia-cusparse-cu12\",\n            \"nvidia-cudnn-cu12\",\n        ],\n    },\n    entry_points={\n        \"console_scripts\": [\"dp = deepmd.entrypoints.main:main\", *extra_scripts],\n        \"lammps.plugins\": [\"deepmd = deepmd.lmp:get_op_dir\"],\n    },\n    cmdclass={\n        \"bdist_wheel\": bdist_wheel_abi3,\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=61\",\n    \"setuptools_scm[toml]>=6.2\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    # see https://github.com/scikit-build/scikit-build/releases/tag/0.13.1\n    \"ninja; platform_system!='Windows'\",\n]\nbuild-backend = \"dp_backend\"\nbackend-path = [\"backend\"]\n\n[project]\nname = \"deepmd-kit\"\ndynamic = [\"version\", \"optional-dependencies\", \"entry-points\"]\ndescription = \"A deep learning package for many-body potential energy representation and molecular dynamics\"\nauthors = [\n  {name = \"DeepModeling\"},\n  {name = \"Han Wang\", email = \"wang_han@iapcm.ac.cn\"},\n]\nlicense = {file = \"LICENSE\"}\nclassifiers = [\n    \"Programming Language :: Python :: 3.7\",\n    \"License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)\",\n]\ndependencies = [\n    'numpy',\n    'scipy',\n    'pyyaml',\n    'dargs >= 0.2.9',\n    'python-hostlist >= 1.21',\n    'typing_extensions; python_version < \"3.7\"',\n    'importlib_metadata>=1.4; python_version < \"3.8\"',\n    'h5py',\n    'wcmatch',\n    'packaging',\n]\nrequires-python = \">=3.7\"\nreadme = \"README.md\"\nkeywords = [\"deepmd\"]\n\n[project.urls]\nHomepage = \"https://github.com/deepmodeling/deepmd-kit\"\ndocumentation = \"https://docs.deepmodeling.com/projects/deepmd-kit\"\nrepository = \"https://github.com/deepmodeling/deepmd-kit\"\n\n[tool.setuptools_scm]\nwrite_to = \"deepmd/_version.py\"\n\n[tool.cibuildwheel]\ntest-command = [\n    \"dp -h\",\n]\ntest-extras = [\"cpu\"]\nbuild = [\"cp310-*\"]\nskip = [\"*-win32\", \"*-manylinux_i686\", \"*-musllinux*\"]\n# TODO: bump to \"latest\" tag when CUDA supports GCC 12\nmanylinux-x86_64-image = \"quay.io/pypa/manylinux_2_28_x86_64:2022-11-19-1b19e81\"\nmanylinux-aarch64-image = \"quay.io/pypa/manylinux_2_28_aarch64:2022-11-19-1b19e81\"\n\n[tool.cibuildwheel.macos]\nenvironment = { PIP_PREFER_BINARY=\"1\", DP_LAMMPS_VERSION=\"stable_23Jun2022_update3\", DP_ENABLE_IPI=\"1\" }\nbefore-all = [\"brew install mpich\"]\nrepair-wheel-command = \"delocate-wheel --require-archs {delocate_archs} -w {dest_dir} -v {wheel} --ignore-missing-dependencies\"\ntest-extras = [\"cpu\", \"test\", \"lmp\", \"ipi\"]\ntest-command = [\n    \"dp -h\",\n    \"dp_ipi\",\n    \"pytest {project}/source/tests/test_lammps.py\"\n]\n\n[tool.cibuildwheel.linux]\nrepair-wheel-command = \"auditwheel repair --exclude libtensorflow_framework.so.2 --exclude libtensorflow_framework.so.1 --exclude libtensorflow_framework.so --exclude _pywrap_tensorflow_internal.so --exclude libtensorflow_cc.so.2 -w {dest_dir} {wheel}\"\nenvironment-pass = [\"CIBW_BUILD\", \"DP_VARIANT\"]\nenvironment = { PIP_PREFER_BINARY=\"1\", DP_VARIANT=\"cuda\", DP_LAMMPS_VERSION=\"stable_23Jun2022_update3\", DP_ENABLE_IPI=\"1\", MPI_HOME=\"/usr/lib64/mpich\", PATH=\"/usr/lib64/mpich/bin:$PATH\" }\nbefore-all = [\n    \"\"\"{ if [ \"$(uname -m)\" = \"x86_64\" ] ; then curl https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.run -O && bash cuda_11.8.0_520.61.05_linux.run --silent --toolkit; fi }\"\"\",\n    \"yum install -y mpich-devel\",\n]\n\n[tool.cibuildwheel.windows]\nenvironment = { PIP_PREFER_BINARY=\"1\" }\n\n\n# selectively turn of lintner warnings, always include reasoning why any warning should\n#\u00a0be silenced\n\n# W504 - line break after binary operator - there is conflict between W503 and W504 in\n# some lintners. One recomends line bread after and one before binary operator so we\n#\u00a0swith W504 off and recomend this coding style:\n#\u00a0a = (b +     ->\u00a0instead of -> a = (b\n#      c)                            + c)\n[tool.autopep8]\nignore = \"W504\"\n\n# D413 - Missing blank line after last section - makes no sense only adds empy lines in\n#\u00a0docstrings\n#\u00a0D416 - Section name should end with a colon - only applicable to RST type docstrings,\n# we are using numpy style\n#\u00a0D203 - 1 blank line required before class docstring - only adds unnecessary empty space\n# D107 - Missing docstring in __init__ - Nupmy style documents __init__ parameters in\n# class docstring\n#\u00a0D213 - Multi-line docstring summary should start at the second line - unnecessary waste\n# of space, start on the first line\n[tool.pydocstyle]\nignore = \"D413, D416, D203, D107, D213\"\n\n[tool.isort]\nprofile = \"black\"\nforce_grid_wrap = 1\n\n[tool.ruff]\ntarget-version = \"py37\"\nselect = [\n    \"E\", # errors\n    \"F\", # pyflakes\n    \"D\", # pydocstyle\n    \"UP\", # pyupgrade\n]\nignore = [\n    \"E501\", # line too long\n    \"F841\", # local variable is assigned to but never used\n    \"E741\", # ambiguous variable name\n    \"E402\", # module level import not at top of file\n    \"D413\", # missing blank line after last section\n    \"D416\", # section name should end with a colon\n    \"D203\", # 1 blank line required before class docstring\n    \"D107\", # missing docstring in __init__\n    \"D213\", # multi-line docstring summary should start at the second line\n    \"D100\", # TODO: missing docstring in public module\n    \"D101\", # TODO: missing docstring in public class\n    \"D102\", # TODO: missing docstring in public method\n    \"D103\", # TODO: missing docstring in public function\n    \"D104\", # TODO: missing docstring in public package\n    \"D105\", # TODO: missing docstring in magic method\n    \"D205\", # 1 blank line required between summary line and description\n    \"D401\", # TODO: first line should be in imperative mood\n    \"D404\", # TODO: first word of the docstring should not be This\n]\nignore-init-module-imports = true\n"
  },
  "NVIDIA/VideoProcessingFramework": {
    "setup.py": "\"\"\"\n\n\"\"\"\n\nimport sys\nimport os\n\nfrom pkg_resources import VersionConflict, require\n\ntry:\n    require(\"setuptools>=42\")\nexcept VersionConflict:\n    print(\"Error: version of setuptools is too old (<42)!\")\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    import skbuild\n\n    PytorchNvCodec = \"PytorchNvCodec @ git+https://github.com/NVIDIA/VideoProcessingFramework.git#subdirectory=src/PytorchNvCodec/\"\n    skbuild.setup(\n        name=\"PyNvCodec\",\n        version=\"2.0\",\n        description=\"Video Processing Library with full NVENC/NVDEC hardware acceleration\",\n        author=\"NVIDIA\",\n        license=\"Apache 2.0\",\n        install_requires=[\"numpy\"],\n        extras_require={\n            # , \"PyOpenGL-accelerate\" # does not compile on 3.10\n            \"dev\": [\"pycuda\", \"pyopengl\", \"torch\", \"torchvision\", \"opencv-python\", \"onnx\", \"tensorrt\", f\"PytorchNvCodec @ file://{os.getcwd()}/src/PytorchNvCodec/\"],\n            \"samples\": [\"pycuda\", \"pyopengl\", \"torch\", \"torchvision\", \"opencv-python\", \"onnx\", \"tensorrt\", PytorchNvCodec],\n            \"tests\": [\"pycuda\", \"pyopengl\", \"torch\", \"torchvision\", \"opencv-python\", PytorchNvCodec],\n            \"torch\": [\"torch\", \"torchvision\", \"opencv-python\", PytorchNvCodec],\n            \"tensorrt\": [\"torch\", \"torchvision\", PytorchNvCodec],\n        },\n        packages=[\"PyNvCodec\"],\n        package_data={\"PyNvCodec\": [\"__init__.pyi\"]},\n        package_dir={\"\": \"src\"},\n        cmake_install_dir=\"src\",\n    )\n",
    "pyproject.toml": "[build-system]        \nrequires = [\n  \"setuptools>=42\",\n  \"scikit-build\",\n  \"numpy\",\n  ## out-comment not install cmake/ninja via pip\n  \"cmake>=3.21\",\n  \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\naddopts = \"-ra -q\"\ntestpaths = [\n    \"tests\",\n]\n"
  },
  "pytorch/FBGEMM": {
    "fbgemm_gpu/setup.py": "# Copyright (c) Meta Platforms, Inc. and affiliates.\n# All rights reserved.\n#\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree.\n\n\nimport argparse\nimport os\nimport random\nimport re\nimport subprocess\nimport sys\n\nfrom datetime import date\nfrom typing import List, Optional\n\nimport setuptools_git_versioning as gitversion\nimport torch\nfrom skbuild import setup\n\n\ndef generate_package_version(package_name: str):\n    print(\"[SETUP.PY] Generating the package version ...\")\n\n    if \"nightly\" in package_name:\n        # Use date stamp for nightly versions\n        print(\"[SETUP.PY] Package is for NIGHTLY; using timestamp for the versioning\")\n        today = date.today()\n        version = f\"{today.year}.{today.month}.{today.day}\"\n\n    elif \"test\" in package_name:\n        # Use date stamp for nightly versions\n        print(\"[SETUP.PY] Package is for TEST: using random number for the versioning\")\n        version = (f\"0.0.{random.randint(0, 1000)}\",)\n\n    else:\n        # Use git tag / branch / commit info to generate a PEP-440-compliant version string\n        print(\"[SETUP.PY] Package is for RELEASE: using git info for the versioning\")\n        print(\n            f\"[SETUP.PY] TAG: {gitversion.get_tag()}, BRANCH: {gitversion.get_branch()}, SHA: {gitversion.get_sha()}\"\n        )\n        # Remove the local version identifier, if any (e.g. 0.4.0rc0.post0+git.6a63116c.dirty => 0.4.0rc0.post0)\n        # Then remove post0 (keep postN for N > 0) (e.g. 0.4.0rc0.post0 => 0.4.0rc0)\n        version = re.sub(\".post0$\", \"\", gitversion.version_from_git().split(\"+\")[0])\n\n    print(f\"[SETUP.PY] Setting the package version: {version}\")\n    return version\n\n\ndef get_cxx11_abi():\n    try:\n        import torch\n\n        value = int(torch._C._GLIBCXX_USE_CXX11_ABI)\n    except ImportError:\n        value = 0\n    return \"-DGLIBCXX_USE_CXX11_ABI=\" + str(value)\n\n\ndef parse_args(argv: List[str]) -> argparse.Namespace:\n    parser = argparse.ArgumentParser(description=\"fbgemm_gpu setup\")\n    parser.add_argument(\n        \"--cpu_only\",\n        dest=\"cpu_only\",\n        action=\"store_true\",\n        help=\"build for cpu-only (no GPU support)\",\n    )\n    parser.add_argument(\n        \"--package_name\",\n        type=str,\n        default=\"fbgemm_gpu\",\n        help=\"the name of this output wheel\",\n    )\n    parser.add_argument(\n        \"--nvml_lib_path\",\n        type=str,\n        default=None,\n        help=\"Certain operations require the nvml lib (libnvidia-ml.so). If you installed\"\n        \" this in a custom location (through cudatoolkit-dev), provide the path here.\",\n    )\n    return parser.parse_known_args(argv)\n\n\ndef nvcc_ok(cuda_home: str, major: int, minor: int) -> bool:\n    if not cuda_home:\n        return False\n\n    nvcc_path = f\"{cuda_home}/bin/nvcc\"\n    if not os.path.exists(nvcc_path):\n        return False\n\n    try:\n        # Extract version from version string - inspired my NVIDIA/apex\n        output = subprocess.check_output([nvcc_path, \"-V\"], text=True)\n        fragments = output.split()\n        version = fragments[fragments.index(\"release\") + 1]\n        version_fragments = version.split(\".\")\n        major_nvcc = int(version_fragments[0])\n        minor_nvcc = int(version_fragments[1].split(\",\")[0])\n        result = major == major_nvcc and minor == minor_nvcc\n    except BaseException:\n        result = False\n\n    return result\n\n\ndef find_cuda(major: int, minor: int) -> Optional[str]:\n    cuda_home = os.environ.get(\"CUDA_BIN_PATH\")\n    if nvcc_ok(cuda_home, major, minor):\n        return cuda_home\n\n    cuda_nvcc = os.environ.get(\"CUDACXX\")\n\n    if cuda_nvcc and os.path.exists(cuda_nvcc):\n        cuda_home = os.path.dirname(os.path.dirname(cuda_nvcc))\n        if nvcc_ok(cuda_home, major, minor):\n            return cuda_home\n\n    # Search standard installation location with version first\n    cuda_home = f\"/usr/local/cuda-{major}.{minor}\"\n    if nvcc_ok(cuda_home, major, minor):\n        return cuda_home\n\n    cuda_home = \"/usr/local/cuda\"\n    if nvcc_ok(cuda_home, major, minor):\n        return cuda_home\n\n    try:\n        # Try to find nvcc with which\n        with open(os.devnull, \"w\") as devnull:\n            nvcc = (\n                subprocess.check_output([\"which\", \"nvcc\"], stderr=devnull)\n                .decode()\n                .rstrip(\"\\r\\n\")\n            )\n            cuda_home = os.path.dirname(os.path.dirname(nvcc))\n\n    except Exception:\n        cuda_home = None\n\n    if nvcc_ok(cuda_home, major, minor):\n        return cuda_home\n\n    return None\n\n\ndef main(argv: List[str]) -> None:\n    # Handle command line args before passing to main setup() method.\n    args, unknown = parse_args(argv)\n    print(\"args: \", args)\n    if len(unknown) != 0 and (len(unknown) != 1 or unknown[0] != \"clean\"):\n        print(\"unknown: \", unknown)\n\n    if not args.cpu_only:\n        cub_include_path = os.getenv(\"CUB_DIR\", None)\n        if cub_include_path is None:\n            print(\n                \"CUDA CUB directory environment variable not set.  Using default CUB location.\"\n            )\n            if torch.version.cuda is not None:\n                cuda_version = torch.version.cuda.split(\".\")\n                cuda_home = find_cuda(int(cuda_version[0]), int(cuda_version[1]))\n            else:\n                cuda_home = False\n\n            if cuda_home:\n                print(f\"Using CUDA = {cuda_home}\")\n                os.environ[\"CUDA_BIN_PATH\"] = cuda_home\n                os.environ[\"CUDACXX\"] = f\"{cuda_home}/bin/nvcc\"\n\n    # Get the long description from the relevant file\n    cur_dir = os.path.dirname(os.path.realpath(__file__))\n\n    with open(os.path.join(cur_dir, \"README.md\"), encoding=\"utf-8\") as f:\n        long_description = f.read()\n\n    torch_root = os.path.dirname(torch.__file__)\n\n    os.environ[\"CMAKE_BUILD_PARALLEL_LEVEL\"] = str(os.cpu_count() // 2)\n\n    cmake_args = [f\"-DCMAKE_PREFIX_PATH={torch_root}\"]\n    cmake_args.append(get_cxx11_abi())\n    if args.cpu_only:\n        cmake_args.append(\"-DFBGEMM_CPU_ONLY=ON\")\n    if args.nvml_lib_path:\n        cmake_args.append(f\"-DNVML_LIB_PATH={args.nvml_lib_path}\")\n\n    package_version = generate_package_version(args.package_name)\n\n    # Repair command line args for setup.\n    sys.argv = [sys.argv[0]] + unknown\n\n    setup(\n        # Metadata\n        name=args.package_name,\n        version=package_version,\n        author=\"FBGEMM Team\",\n        author_email=\"packages@pytorch.org\",\n        long_description=long_description,\n        long_description_content_type=\"text/markdown\",\n        url=\"https://github.com/pytorch/fbgemm\",\n        license=\"BSD-3\",\n        keywords=[\n            \"PyTorch\",\n            \"Recommendation Models\",\n            \"High Performance Computing\",\n            \"GPU\",\n            \"CUDA\",\n        ],\n        packages=[\"fbgemm_gpu\"],\n        cmake_args=cmake_args,\n        # PyPI package information.\n        classifiers=[\n            \"Development Status :: 4 - Beta\",\n            \"Intended Audience :: Developers\",\n            \"Intended Audience :: Science/Research\",\n            \"License :: OSI Approved :: BSD License\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n            \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n        ],\n    )\n\n\nif __name__ == \"__main__\":\n    print(sys.argv)\n    main(sys.argv[1:])\n"
  },
  "adobe-type-tools/afdko": {
    "setup.py": "import distutils.command.build_scripts\nimport io\nimport os\nimport platform\nimport sys\nfrom distutils import log\nfrom distutils.dep_util import newer\nfrom distutils.util import convert_path\nfrom distutils.util import get_platform\n\nimport setuptools.command.install\n\nfrom skbuild import setup\n\ntry:\n    from wheel.bdist_wheel import bdist_wheel\n\n    class CustomBDistWheel(bdist_wheel):\n        \"\"\"Mark the wheel as python 3, yet platform-specific,\n        since it contains native C executables.\n        \"\"\"\n\n        def finalize_options(self):\n            bdist_wheel.finalize_options(self)\n            self.root_is_pure = False\n\n        def get_tag(self):\n            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n\nexcept ImportError:\n    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n          \"installed. Try the command 'pip install wheel'.\")\n    sys.exit(1)\n\n\nclass InstallPlatlib(setuptools.command.install.install):\n    \"\"\"This is to force installing all the modules to the non-pure, platform-\n    specific lib directory, even though we haven't defined any 'ext_modules'.\n\n    The distutils 'install' command, in 'finalize_options' method, picks\n    either 'install_platlib' or 'install_purelib' based on whether the\n    'self.distribution.ext_modules' list is not empty.\n\n    Without this hack, auditwheel would flag the afdko wheel as invalid since\n    it contains native executables inside the pure lib folder.\n\n    TODO Remove this hack if/when in the future we install extension modules.\n    \"\"\"\n\n    def finalize_options(self):\n        setuptools.command.install.install.finalize_options(self)\n        self.install_lib = self.install_platlib\n\n\nclass CustomBuildScripts(distutils.command.build_scripts.build_scripts):\n\n    def copy_scripts(self):\n        \"\"\"Copy each script listed in 'self.scripts' *as is*, without\n        attempting to adjust the !# shebang. The default build_scripts command\n        in python3 calls tokenize to detect the text encoding, treating all\n        scripts as python scripts. But all our 'scripts' are native C\n        executables, thus the python3 tokenize module fails with SyntaxError\n        on them. Here we just skip the if branch where distutils attempts\n        to adjust the shebang.\n        \"\"\"\n        self.mkpath(self.build_dir)\n        outfiles = []\n        updated_files = []\n        for script in self.scripts:\n            script = convert_path(script)\n            outfile = os.path.join(self.build_dir, os.path.basename(script))\n            outfiles.append(outfile)\n\n            if not self.force and not newer(script, outfile):\n                log.debug(\"afdko: not copying %s (up-to-date)\", script)\n                continue\n\n            try:\n                f = open(script, \"rb\")\n            except OSError:\n                if not self.dry_run:\n                    raise\n                f = None\n            else:\n                first_line = f.readline()\n                if not first_line:\n                    f.close()\n                    self.warn(\"afdko: %s is an empty file (skipping)\" % script)\n                    continue\n\n            if f:\n                f.close()\n            updated_files.append(outfile)\n            self.copy_file(script, outfile)\n\n        return outfiles, updated_files\n\n\ndef _get_scripts():\n    script_names = [\n        'detype1', 'makeotfexe', 'mergefonts', 'rotatefont',\n        'sfntdiff', 'sfntedit', 'spot', 'tx', 'type1'\n    ]\n    if platform.system() == 'Windows':\n        extension = '.exe'\n    else:\n        extension = ''\n\n    scripts = [f'bin/{script_name}{extension}'\n               for script_name in script_names]\n    return scripts\n\n\ndef _get_console_scripts():\n    script_entries = [\n        ('buildcff2vf', 'buildcff2vf:main'),\n        ('buildmasterotfs', 'buildmasterotfs:main'),\n        ('comparefamily', 'comparefamily:main'),\n        ('checkoutlinesufo', 'checkoutlinesufo:main'),\n        ('makeotf', 'makeotf:main'),\n        ('makeinstancesufo', 'makeinstancesufo:main'),\n        ('otc2otf', 'otc2otf:main'),\n        ('otf2otc', 'otf2otc:main'),\n        ('otf2ttf', 'otf2ttf:main'),\n        ('ttfcomponentizer', 'ttfcomponentizer:main'),\n        ('ttfdecomponentizer', 'ttfdecomponentizer:main'),\n        ('ttxn', 'ttxn:main'),\n        ('charplot', 'proofpdf:charplot'),\n        ('digiplot', 'proofpdf:digiplot'),\n        ('fontplot', 'proofpdf:fontplot'),\n        ('fontplot2', 'proofpdf:fontplot2'),\n        ('fontsetplot', 'proofpdf:fontsetplot'),\n        ('hintplot', 'proofpdf:hintplot'),\n        ('waterfallplot', 'proofpdf:waterfallplot'),\n    ]\n    scripts_path = 'afdko'\n    scripts = [f'{name} = {scripts_path}.{entry}'\n               for name, entry in script_entries]\n    return scripts\n\n\ndef _get_requirements():\n    with io.open(\"requirements.txt\", encoding=\"utf-8\") as requirements:\n        return [rl.replace(\"==\", \">=\") for rl in requirements.readlines()]\n\n\ndef main():\n    classifiers = [\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Topic :: Software Development :: Build Tools',\n        'License :: OSI Approved :: Apache Software License',\n        'Programming Language :: Python :: 3.8',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX :: Linux',\n    ]\n\n    # concatenate README and NEWS into long_description so they are\n    # displayed on the afdko project page on PyPI\n    # Copied from fonttools setup.py\n    with io.open(\"README.md\", encoding=\"utf-8\") as readme:\n        long_description = readme.read()\n    long_description += '\\n'\n    with io.open(\"NEWS.md\", encoding=\"utf-8\") as changelog:\n        long_description += changelog.read()\n\n    platform_name = get_platform()\n\n    setup(name=\"afdko\",\n          use_scm_version=True,\n          description=\"Adobe Font Development Kit for OpenType\",\n          long_description=long_description,\n          long_description_content_type='text/markdown',\n          url='https://github.com/adobe-type-tools/afdko',\n          author='Adobe Type team & friends',\n          author_email='afdko@adobe.com',\n          license='Apache License, Version 2.0',\n          classifiers=classifiers,\n          keywords='font development tools',\n          platforms=[platform_name],\n          package_dir={'': 'python'},\n          packages=['afdko', 'afdko.pdflib'],\n          include_package_data=True,\n          package_data={\n              'afdko': [\n                  'resources/*.txt',\n                  'resources/Adobe-CNS1/*',\n                  'resources/Adobe-GB1/*',\n                  'resources/Adobe-Japan1/*',\n                  'resources/Adobe-Korea1/*'\n              ],\n          },\n          zip_safe=False,\n          python_requires='>=3.8',\n          setup_requires=[\n              'wheel',\n              'setuptools_scm',\n              'scikit-build',\n              'cmake',\n              'ninja'\n          ],\n          tests_require=[\n              'pytest',\n          ],\n          install_requires=_get_requirements(),\n          scripts=_get_scripts(),\n          entry_points={\n              'console_scripts': _get_console_scripts(),\n          },\n          cmdclass={\n              'build_scripts': CustomBuildScripts,\n              'bdist_wheel': CustomBDistWheel,\n              'install': InstallPlatlib,\n          },\n          )\n\n\nif __name__ == '__main__':\n    main()\n",
    "pyproject.toml": "[build-system]\nrequires = [\n\t\"setuptools\",\n\t\"wheel\",\n\t\"setuptools_scm\",\n\t\"scikit-build\",\n\t\"cmake\",\n\t\"ninja\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\n",
    "setup.cfg": "[metadata]\nlicense_file = LICENSE.md\n\n[tool:pytest]\nfilterwarnings =\n\tignore:tostring:DeprecationWarning\n\tignore:fromstring:DeprecationWarning\n\tignore:The py23 module:DeprecationWarning\n"
  },
  "YannickJadoul/Parselmouth": {
    "setup.py": "# Copyright (C) 2017-2022  Yannick Jadoul\n#\n# This file is part of Parselmouth.\n#\n# Parselmouth is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Parselmouth is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Parselmouth.  If not, see <http://www.gnu.org/licenses/>\n\nimport io\nimport os\nimport re\nimport shlex\nimport sys\n\ntry:\n\tfrom skbuild import setup\nexcept ImportError:\n\tprint(\"Please update pip to pip 10 or greater, or a manually install the PEP 518 requirements in pyproject.toml\", file=sys.stderr)\n\traise\n\n\ndef find_version(*file_paths):\n\twith io.open(os.path.join(os.path.dirname(__file__), \"src\", \"version.h\"), encoding='utf8') as f:\n\t\tversion_file = f.read()\n\tversion_match = re.search(r\"^#define PARSELMOUTH_VERSION ([0-9a-z.]+)$\", version_file, re.M)\n\tif version_match:\n\t\treturn version_match.group(1)\n\traise RuntimeError(\"Unable to find version string.\")\n\n\nsetup(\n\tversion=find_version(),\n\tpackages=[''],\n\tpackage_dir={'': \"src\"},\n\tcmake_args=shlex.split(os.environ.get('PARSELMOUTH_EXTRA_CMAKE_ARGS', '')),\n\tcmake_install_dir=\"src\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"cmake>=3.18\",\n    \"scikit-build>=0.13\",\n]\nbuild-backend = \"setuptools.build_meta\"\n",
    "setup.cfg": "[metadata]\nname = praat-parselmouth\n# version = <see setup.py>\ndescription = Praat in Python, the Pythonic way\nlong_description = file: res/README_PyPI.md\nlong_description_content_type = text/markdown\nurl = https://github.com/YannickJadoul/Parselmouth\nauthor = Yannick Jadoul\nauthor_email = Yannick.Jadoul@ai.vub.ac.be\nproject_urls =\n    Bug Tracker = https://github.com/YannickJadoul/Parselmouth/issues\n    Documentation = https://parselmouth.readthedocs.io/\n    Source Code = https://github.com/YannickJadoul/Parselmouth\nkeywords = praat, speech, signal processing, phonetics\nlicense = GPLv3\nlicense_file = LICENSE\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Developers\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\n    Operating System :: MacOS :: MacOS X\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Operating System :: Unix\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Topic :: Scientific/Engineering\n    Topic :: Software Development :: Libraries :: Python Modules\n\n[options]\npython_requires = >=3.6\ninstall_requires =\n    numpy>=1.7.0\nzip_safe = False\n\n[check-manifest]\nignore =\n    .clang-format\n    .readthedocs.yml\n    binder\n    binder/*\n"
  },
  "freebsd/freebsd-ports": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "PRBonn/kiss-icp": {
    "python/setup.py": "# MIT License\n#\n# Copyright (c) 2022 Ignacio Vizzo, Tiziano Guadagnino, Benedikt Mersch, Cyrill\n# Stachniss.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nsetup(\n    packages=find_packages(),\n    cmake_install_dir=\"kiss_icp/pybind/\",\n    cmake_install_target=\"install_python_bindings\",\n    entry_points={\"console_scripts\": [\"kiss_icp_pipeline=kiss_icp.tools.cmd:run\"]},\n    install_requires=[\n        \"natsort\",\n        \"numpy\",\n        \"plyfile\",\n        \"pydantic\",\n        \"pyquaternion\",\n        \"rich\",\n        \"tqdm\",\n        \"typer[all]>=0.6.0\",\n    ],\n    extras_require={\n        \"visualizer\": [\n            \"open3d>=0.13\",\n        ],\n        \"all\": [\n            \"PyYAML\",\n            \"open3d>=0.13\",\n            \"ouster-sdk>=0.7.1\",\n            \"pyntcloud\",\n            \"trimesh\",\n        ],\n    },\n)\n",
    "python/pyproject.toml": "[build-system]\nrequires = [\n    \"cmake\",\n    \"ninja\",\n    \"scikit-build>=0.17.4\",\n    \"setuptools<66.0.0\", # https://github.com/pypa/setuptools/issues/3772\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 100\n\n[tool.isort]\nprofile = \"black\"\n\n[tool.pylint.format]\nmax-line-length = \"100\"\n\n[tool.cibuildwheel]\narchs = [\"auto64\"]\nskip = [\"*-musllinux*\",  \"pp*\"]\n\n[tool.cibuildwheel.macos]\nenvironment = \"MACOSX_DEPLOYMENT_TARGET=10.14\"\narchs = [\"auto64\", \"arm64\"]\n",
    "python/setup.cfg": "[metadata]\nname = kiss_icp\nversion = 0.2.9\nauthor = Ignacio Vizzo\nauthor_email = ignaciovizzo@gmail.com\ndescription = Simple yet effective 3D LiDAR-Odometry registration pipeline\nlong_description = file:README.md,\nlong_description_content_type = text/markdown\nurl = https://github.com/PRBonn/kiss-icp\nlicense = MIT\nlicense_files = LICENSE\nkeywords  =  SLAM, LiDAR, Odometry, Localization,\nclassifiers  =\n  Operating System :: Unix\n  Operating System :: MacOS\n  Operating System :: Microsoft :: Windows\n  Programming Language :: C++\n  Programming Language :: Python :: 3\n  Programming Language :: Python :: 3.7\n  Programming Language :: Python :: 3.8\n  Programming Language :: Python :: 3.9\n  Programming Language :: Python :: 3.10\n  Programming Language :: Python :: 3.11\n  Intended Audience :: Developers\n  Intended Audience :: Education\n  Intended Audience :: Other Audience\n  Intended Audience :: Science/Research\n  License :: OSI Approved :: MIT License\n"
  },
  "NVIDIA-Merlin/HugeCTR": {
    "sparse_operation_kit/setup.py": "\"\"\"\n Copyright (c) 2021, NVIDIA CORPORATION.\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\"\"\"\nimport os\nimport sys\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nREQUIRED_PACKAGES = [\n    \"horovod>=0.26.1\",\n    \"scikit-build >= 0.16.3\",\n]\n\n\ndef _GetSOKVersion():\n    _version_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"sparse_operation_kit/core/\"\n    )\n    sys.path.append(_version_path)\n    from _version import __version__\n\n    version = __version__\n    del __version__\n    sys.path.pop(-1)\n    return version\n\n\ndef get_cmake_args():\n    gpu_capabilities = [\"70\", \"75\", \"80\", \"90\"]\n    if os.getenv(\"SOK_COMPILE_GPU_SM\"):\n        gpu_capabilities = os.getenv(\"SOK_COMPILE_GPU_SM\")\n        gpu_capabilities = str(gpu_capabilities).strip().split(\";\")\n\n    use_nvtx = \"OFF\"\n    if os.getenv(\"SOK_COMPILE_USE_NVTX\"):\n        use_nvtx = \"ON\" if os.getenv(\"SOK_COMPILE_USE_NVTX\") in [\"1\", \"ON\", \"On\", \"on\"] else \"OFF\"\n\n    dedicated_cuda_stream = \"ON\"\n    if os.getenv(\"SOK_COMPILE_ASYNC\"):\n        dedicated_cuda_stream = (\n            \"OFF\" if os.getenv(\"SOK_COMPILE_ASYNC\") in [\"0\", \"OFF\", \"Off\", \"off\"] else \"ON\"\n        )\n\n    unit_test = \"OFF\"\n    if os.getenv(\"SOK_COMPILE_UNIT_TEST\"):\n        unit_test = \"ON\" if os.getenv(\"SOK_COMPILE_UNIT_TEST\") in [\"1\", \"ON\", \"On\", \"on\"] else \"OFF\"\n\n    cmake_build_type = \"Release\"\n    if os.getenv(\"SOK_COMPILE_BUILD_TYPE\"):\n        cmake_build_type = (\n            \"Debug\"\n            if os.getenv(\"SOK_COMPILE_BUILD_TYPE\") in [\"DEBUG\", \"debug\", \"Debug\"]\n            else \"Release\"\n        )\n\n    enable_deeprec = \"OFF\"\n    if os.getenv(\"ENABLE_DEEPREC\"):\n        enable_deeprec = (\n            \"OFF\" if os.getenv(\"ENABLE_DEEPREC\") in [\"0\", \"OFF\", \"Off\", \"off\"] else \"ON\"\n        )\n    cmake_args = [\n        \"-DSM='{}'\".format(\";\".join(gpu_capabilities)),\n        \"-DUSE_NVTX={}\".format(use_nvtx),\n        \"-DSOK_ASYNC={}\".format(dedicated_cuda_stream),\n        \"-DSOK_UNIT_TEST={}\".format(unit_test),\n        \"-DCMAKE_BUILD_TYPE={}\".format(cmake_build_type),\n        \"-DENABLE_DEEPREC={}\".format(enable_deeprec),\n    ]\n    return cmake_args\n\n\n# We haven't found a proper way to maintain the directory structure of\n# the parent folder(i.e. HugeCTR) when using skbuild to make pip package,\n# so we use a workaround here: copy the content of parent folder into\n# sparse_operation_kit/ before making pip package.\nos.system(\"cp -r ../HugeCTR ./\")\nos.system(\"mkdir third_party\")\nos.system(\"cp -r ../third_party/json ./third_party/\")\n\n\nsetup(\n    name=\"merlin-sok\",\n    version=_GetSOKVersion(),\n    author=\"NVIDIA\",\n    author_email=\"hugectr-dev@exchange.nvidia.com\",\n    url=\"https://github.com/NVIDIA-Merlin/HugeCTR/tree/master/sparse_operation_kit\",\n    description=\"SparseOperationKit (SOK) is a python package wrapped GPU accelerated\"\n    \" operations dedicated for sparse training / inference cases.\",\n    long_description=\"SparseOperationKit (SOK) is a python package wrapped GPU accelerated \"\n    \"operations dedicated for sparse training / inference cases. \"\n    \"It is designed to be compatible with common DeepLearning (DL) frameworks, \"\n    \"for instance, TensorFlow. \"\n    \"Most of the algorithm implementations in SOK are extracted from HugeCTR, \"\n    \"which is a GPU-accelerated recommender framework designed to distribute \"\n    \"training across multiple GPUs and nodes and estimate Click-Through Rates (CTRs). \"\n    \"If you are looking for a very efficient solution for CTRs, please check HugeCTR.\",\n    extras_require={\"tensorflow\": \"tensorflow>=1.15\"},\n    license=\"Apache 2.0\",\n    platforms=[\"Linux\"],\n    install_requires=REQUIRED_PACKAGES,\n    python_requires=\">=3\",  # TODO: make it compatible with python2.7\n    packages=find_packages(),\n    cmake_args=get_cmake_args(),\n)\n",
    "sparse_operation_kit/pyproject.toml": "# Copyright (c) 2021, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\n# we're adding 'ninja' build as a build dependency, since this allows us to automatically\n# parallelize compilation over all available CPU cores, versus just generating unix\n# makefiles with cmake\nrequires = [\"setuptools\", \"wheel\", \"scikit-build>=0.13.1\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n",
    "hps_tf/setup.py": "\"\"\"\n Copyright (c) 2023, NVIDIA CORPORATION.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n\"\"\"\n\nimport os\nimport sys\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\ndef _GetHPSVersion():\n    _version_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"hierarchical_parameter_server/core/\"\n    )\n    sys.path.append(_version_path)\n    from _version import __version__\n\n    version = __version__\n    del __version__\n    sys.path.pop(-1)\n    return version\n\n\ndef get_cmake_args():\n    gpu_capabilities = [\"70\", \"75\", \"80\", \"90\"]\n    if os.getenv(\"HPS_COMPILE_GPU_SM\"):\n        gpu_capabilities = os.getenv(\"HPS_COMPILE_GPU_SM\")\n        gpu_capabilities = str(gpu_capabilities).strip().split(\";\")\n\n    cmake_build_type = \"Release\"\n    if os.getenv(\"HPS_COMPILE_BUILD_TYPE\"):\n        cmake_build_type = (\n            \"Debug\"\n            if os.getenv(\"HPS_COMPILE_BUILD_TYPE\") in [\"DEBUG\", \"debug\", \"Debug\"]\n            else \"Release\"\n        )\n\n    cmake_args = [\n        \"-DSM='{}'\".format(\";\".join(gpu_capabilities)),\n        \"-DCMAKE_BUILD_TYPE={}\".format(cmake_build_type),\n        \"-DHPS_ASYNC_OP=ON\",\n    ]\n    return cmake_args\n\n\nsetup(\n    name=\"merlin-hps\",\n    version=_GetHPSVersion(),\n    author=\"NVIDIA\",\n    author_email=\"hugectr-dev@exchange.nvidia.com\",\n    url=\"https://github.com/NVIDIA-Merlin/HugeCTR/tree/master/hps_tf\",\n    description=\"HierarchicalParameterServer (HPS)\",\n    long_description=\"HierarchicalParameterServer (HPS)\",\n    extras_require={\"tensorflow\": \"tensorflow>=1.15\"},\n    license=\"Apache 2.0\",\n    platforms=[\"Linux\"],\n    python_requires=\">=3\",\n    packages=find_packages(),\n    cmake_args=get_cmake_args(),\n)\n",
    "hps_tf/pyproject.toml": "#\n# Copyright (c) 2023, NVIDIA CORPORATION.\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n# \n#      http://www.apache.org/licenses/LICENSE-2.0\n# \n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n[build-system]\n# we're adding 'ninja' build as a build dependency, since this allows us to automatically\n# parallelize compilation over all available CPU cores, versus just generating unix\n# makefiles with cmake\nrequires = [\"setuptools\", \"wheel\", \"scikit-build>=0.13.1\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\""
  },
  "scikit-hep/awkward": {
    "header-only/examples/cython/setup.py": "from skbuild import setup  # This line replaces 'from setuptools import setup'\n\nsetup(\n    name=\"demo\",\n    version=\"0.0.1\",\n    license=\"MIT\",\n    packages=[\"demo\"],\n    python_requires=\">=3.7\",\n    install_requires=[\"awkward>=2.0.0\", \"numpy\"],\n)\n",
    "header-only/examples/cython/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13\",\n    \"cmake>=3.18\",\n    \"cython\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "cntools/libsurvive": {
    "setup.py": "import platform\nfrom setuptools import dist, find_packages\ndist.Distribution().fetch_build_eggs(['wheel', 'cmake_setuptools'])\n\ndist.Distribution().fetch_build_eggs(['cmake_setuptools', 'scikit-build'])\n\nfrom skbuild import setup    \nimport os\nimport subprocess\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n      long_description = f.read()\n\n\nversion = subprocess.check_output([\"git\", \"describe\", \"--tags\", \"--long\"]).strip().decode('utf-8').replace(\"-\", \".\")[1:]\nversion = version[:version.rfind(\"g\")-1]\n\ncmake_args=['-DPYTHON_GENERATED_DIR=\"'+ os.path.dirname(os.path.abspath(__file__))+'/bindings/python/pysurvive/\"',\n            \"-DDOWNLOAD_EIGEN=ON\",\n            \"-DUSE_EIGEN=ON\",\n\t    \"-DBUILD_APPLICATIONS=OFF\",\n            \"-DLIB_INSTALL_DIR=bindings/python/pysurvive/\"]\n\nif platform.system() != 'Windows':\n      cmake_args.append('-DUSE_EIGEN=ON')\n\nsetup(name='pysurvive',\n      version=version,\n      long_description=long_description,\n      long_description_content_type='text/markdown',\n      description='Libsurvive is a set of tools and libraries that enable 6 dof tracking on lighthouse and vive based systems that is completely open source and can run on any device. It currently supports both SteamVR 1.0 and SteamVR 2.0 generation of devices and should support any tracked object commercially available.',\n      url='https://github.com/cntools/libsurvive',\n      packages=['pysurvive'],\n      package_dir={'pysurvive': 'bindings/python/pysurvive'},\n      package_data={'pysurvive': ['images/*']},\n      install_requires=['gooey'],\n      include_package_data=False,\n      license='MIT',\n      cmake_args=cmake_args\n      )\n"
  },
  "uber/h3-py": {
    "setup.py": "import os\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\nabout = {}\nwith open(os.path.join(here, 'src', 'h3', '_version.py')) as f:\n    exec(f.read(), about)\n\n\ndef long_desc():\n    here = os.path.abspath(os.path.dirname(__file__))\n    fname = os.path.join(here, 'readme.md')\n    with open(fname) as f:\n        long_description = f.read()\n\n    return long_description\n\n\nsetup(\n    name = 'h3',\n    version = about['__version__'],\n    description = about['__description__'],\n    long_description = long_desc(),\n    long_description_content_type = 'text/markdown',\n    license = about['__license__'],\n    author = about['__author__'],\n    author_email = about['__author_email__'],\n    url = about['__url__'],\n    classifiers = about['__classifiers__'],\n    include_package_data=True,\n    packages = find_packages(\n        'src',\n        exclude = [\"*.tests\", \"*.tests.*\", \"tests.*\", \"tests\"],\n    ),\n    package_dir = {'': 'src'},\n    cmake_languages = ('C'),\n    extras_require={\n        'numpy': ['numpy'],\n        'test': ['pytest', 'pytest-cov', 'flake8', 'pylint'],\n        'all': ['numpy', 'pytest', 'pytest-cov', 'flake8', 'pylint'],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    'scikit-build',\n    'cython',\n    'cmake',\n]\n"
  },
  "mpi4py/mpi4py": {
    "setup.py": "#!/usr/bin/env python\n# Author:  Lisandro Dalcin\n# Contact: dalcinl@gmail.com\n\n__doc__ = \\\n\"\"\"\nPython bindings for MPI\n\"\"\"\n\nimport os\nimport sys\nimport glob\n\ntopdir = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, os.path.join(topdir, 'conf'))\n\n# --------------------------------------------------------------------\n# Metadata\n# --------------------------------------------------------------------\n\ndef get_name():\n    return 'mpi4py'\n\ndef get_version():\n    import getversion\n    try:\n        return get_version.result\n    except AttributeError:\n        pass\n    version = getversion.version()\n    get_version.result = version\n    return version\n\ndef description():\n    return __doc__.strip()\n\ndef long_description():\n    filelist = ('DESCRIPTION.rst', 'CITATION.rst', 'INSTALL.rst')\n    template = \"See `{0} <{0}>`_.\\n\\n\"\n    template += \".. include:: {0}\\n\"\n    text = template.format(filelist[0])\n    for filename in filelist:\n        with open(os.path.join(topdir, filename)) as f:\n            includeline = template.format(filename)\n            text = text.replace(includeline, f.read())\n    return text\n\ndef homepage():\n    return 'https://mpi4py.github.io'\n\ndef github(*args):\n    base = 'https://github.com/mpi4py/mpi4py'\n    return '/'.join((base,) + args)\n\ndef readthedocs(*args):\n    base = 'https://mpi4py.readthedocs.io'\n    return '/'.join((base,) + args)\n\ndef download_url():\n    version = get_version().partition('+')[0]\n    if '.dev' in version:\n        path = 'tarball'\n        archive = 'master'\n    else:\n        path = 'releases/download/{0}'.format(version)\n        archive = 'mpi4py-{0}.tar.gz'.format(version)\n    return github(path, archive)\n\ndef documentation_url():\n    version = get_version().partition('+')[0]\n    language = 'en'\n    location = 'latest' if '.dev' in version else version\n    return readthedocs(language, location, '')\n\nclassifiers = \"\"\"\nDevelopment Status :: 5 - Production/Stable\nIntended Audience :: Developers\nIntended Audience :: Science/Research\nLicense :: OSI Approved :: BSD License\nOperating System :: MacOS\nOperating System :: MacOS :: MacOS X\nOperating System :: Microsoft :: Windows\nOperating System :: POSIX\nOperating System :: POSIX :: BSD\nOperating System :: POSIX :: Linux\nOperating System :: Unix\nProgramming Language :: C\nProgramming Language :: Cython\nProgramming Language :: Python\nProgramming Language :: Python :: 3\nProgramming Language :: Python :: 3.6\nProgramming Language :: Python :: 3.7\nProgramming Language :: Python :: 3.8\nProgramming Language :: Python :: 3.9\nProgramming Language :: Python :: 3.10\nProgramming Language :: Python :: 3.11\nProgramming Language :: Python :: 3.12\nProgramming Language :: Python :: Implementation :: CPython\nProgramming Language :: Python :: Implementation :: PyPy\nTopic :: Scientific/Engineering\nTopic :: Software Development :: Libraries :: Python Modules\nTopic :: System :: Distributed Computing\n\"\"\"\n\nkeywords = \"\"\"\nscientific computing\nparallel computing\nmessage passing interface\nMPI\n\"\"\"\n\nplatforms = \"\"\"\nPOSIX\nLinux\nmacOS\nFreeBSD\nWindows\n\"\"\"\n\nmetadata = {\n    'name'             : get_name(),\n    'version'          : get_version(),\n    'description'      : description(),\n    'long_description' : long_description(),\n    'url'              : homepage(),\n    'download_url'     : download_url(),\n    'classifiers'      : classifiers.strip().split('\\n'),\n    'keywords'         : keywords.strip().split('\\n'),\n    'platforms'        : platforms.strip().split('\\n'),\n    'license'          : 'BSD-2-Clause',\n    'author'           : 'Lisandro Dalcin',\n    'author_email'     : 'dalcinl@gmail.com',\n}\n\nrequire_python = (3, 6)\nmaxknow_python = (3, 11)\n\nmetadata_extra = {\n    'project_urls': {\n        \"Source Code\"   : github(),\n        \"Bug Tracker\"   : github('issues'),\n        \"Discussions\"   : github('discussions'),\n        \"Documentation\" : documentation_url(),\n    },\n    'python_requires': '>=' + '.'.join(map(str, require_python)),\n    'long_description_content_type': 'text/x-rst',\n}\n\n# --------------------------------------------------------------------\n# Extension modules\n# --------------------------------------------------------------------\n\ndef sources():\n    # mpi4py.MPI\n    MPI = dict(\n        source='mpi4py/MPI.pyx',\n        depends=[\n            'mpi4py/*.pyx',\n            'mpi4py/*.pxd',\n            'mpi4py/MPI/*.pyx',\n            'mpi4py/MPI/*.pxd',\n            'mpi4py/MPI/*.pxi',\n        ],\n        workdir='src',\n    )\n    #\n    return [MPI]\n\n\ndef extensions():\n    import mpidistutils\n    # MPI extension module\n    MPI = dict(\n        name='mpi4py.MPI',\n        sources=['src/mpi4py/MPI.c'],\n        depends=(\n            glob.glob('src/*.h') +\n            glob.glob('src/lib-mpi/*.h') +\n            glob.glob('src/lib-mpi/config/*.h') +\n            glob.glob('src/lib-mpi/compat/*.h')\n        ),\n        include_dirs = ['src'],\n        define_macros=[\n            ('MPICH_SKIP_MPICXX', 1),\n            ('OMPI_SKIP_MPICXX', 1),\n        ],\n        configure=mpidistutils.configure_mpi,\n    )\n    if sys.version_info[:2] > maxknow_python:\n        MPI['define_macros'].extend([\n            ('CYTHON_FAST_PYCALL', 0),\n            ('CYTHON_FAST_THREAD_STATE', 0),\n            ('CYTHON_USE_DICT_VERSIONS', 0),\n            ('CYTHON_USE_PYLONG_INTERNALS', 0),\n            ('CYTHON_USE_PYLIST_INTERNALS', 0),\n            ('CYTHON_USE_UNICODE_INTERNALS', 0),\n        ])\n    #\n    return [MPI]\n\n\ndef executables():\n    import mpidistutils\n    # MPI-enabled Python interpreter\n    pyexe = dict(\n        name='python-mpi',\n        optional=True,\n        package='mpi4py',\n        dest_dir='bin',\n        sources=['src/python.c'],\n        configure=mpidistutils.configure_pyexe,\n    )\n    #\n    return [pyexe]\n\n\n# --------------------------------------------------------------------\n# Setup\n# --------------------------------------------------------------------\n\npackage_info = dict(\n    packages = [\n        'mpi4py',\n        'mpi4py.futures',\n        'mpi4py.util',\n    ],\n    package_data = {\n        'mpi4py' : [\n            '*.pxd',\n            'MPI*.h',\n            'include/mpi4py/*.h',\n            'include/mpi4py/*.i',\n            'include/mpi4py/*.pxi',\n            'py.typed',\n            '*.pyi',\n            '*/*.pyi',\n        ],\n    },\n    package_dir = {'' : 'src'},\n)\nif sys.version_info < (3, 7):\n    del package_info['package_data']['mpi4py'][-3:]\n\n\ndef run_setup():\n    \"\"\"\n    Call setuptools.setup(*args, **kwargs)\n    \"\"\"\n    try:\n        import setuptools\n    except ImportError:\n        setuptools = None\n    from mpidistutils import setup\n    from mpidistutils import Extension  as Ext\n    from mpidistutils import Executable as Exe\n    #\n    from mpidistutils import build_src\n    build_src.sources = sources()\n    #\n    builder_args = dict(\n        ext_modules = [Ext(**ext) for ext in extensions()],\n        executables = [Exe(**exe) for exe in executables()],\n    )\n    if setuptools:\n        builder_args['zip_safe'] = False\n        metadata.update(metadata_extra)\n    #\n    setup_args = dict(i for d in (\n        metadata,\n        package_info,\n        builder_args,\n    ) for i in d.items())\n    #\n    setup(**setup_args)\n\n\ndef run_skbuild():\n    \"\"\"\n    Call setuptools.setup(*args, **kwargs)\n    \"\"\"\n    from setuptools import setup\n    #\n    builder_args = dict(\n        cmake_source_dir = '.',\n    )\n    metadata.update(metadata_extra)\n    #\n    setup_args = dict(i for d in (\n        metadata,\n        package_info,\n        builder_args,\n    ) for i in d.items())\n    #\n    setup(**setup_args)\n\n\n# --------------------------------------------------------------------\n\n\ndef main():\n    try:\n        import builder\n        name = builder.get_build_backend_name()\n    except RuntimeError as exc:\n        sys.exit(exc)\n\n    if name == 'setuptools':\n        run_setup()\n    if name == 'skbuild':\n        run_skbuild()\n\n\nif __name__ == '__main__':\n    if sys.version_info < require_python:\n        raise SystemExit(\n            \"error: requires Python version \" +\n            metadata_extra['python_requires']\n        )\n    main()\n\n\n# --------------------------------------------------------------------\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools >= 42\", \"build\"]\nbuild-backend = \"builder\"\nbackend-path = [\"conf\"]\n",
    "setup.cfg": "[config]\n# mpicc   = mpicc\n# mpicxx  = mpicxx\n# mpifort = mpifort\n# mpif90  = mpif90\n# mpif77  = mpif77\n\n[build]\ndebug = 0\n# compiler = mingw32\n\n[sdist]\nforce_manifest = 1\n\n[nosetests]\nwhere = test\n\n[tool:pytest]\ntestpaths = test\n\n[coverage:run]\nparallel = True\nbranch = True\nsource = mpi4py\n[coverage:paths]\nsource =\n  src/mpi4py\n  */mpi4py\n"
  },
  "rordenlab/dcm2niix": {
    "setup.py": "\"\"\"Compile source code and setup Python 3 package\"\"\"\nimport re\nfrom pathlib import Path\n\nfrom setuptools_scm import get_version\nfrom skbuild import setup\n\n__version__ = get_version(root=\".\", relative_to=__file__)\nbuild_ver = \".\".join(__version__.split(\".\")[:3]).split(\".dev\")[0]\nfor i in (Path(__file__).resolve().parent / \"_skbuild\").rglob(\"CMakeCache.txt\"):\n    i.write_text(re.sub(\"^//.*$\\n^[^#].*pip-build-env.*$\", \"\", i.read_text(), flags=re.M))\nsetup(use_scm_version=True, packages=[\"dcm2niix\"],\n      cmake_languages=(\"CXX\",), cmake_minimum_required_version=\"3.18\")\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"setuptools_scm[toml]>=3.4\",\n            \"scikit-build>=0.11.0\", \"cmake>=3.18\", \"ninja\"]\n\n[tool.setuptools_scm]\nwrite_to = \"dcm2niix/_dist_ver.py\"\nwrite_to_template = \"__version__ = '{version}'\\n\"\n",
    "setup.cfg": "[metadata]\nname=dcm2niix\ndescription=DCM2NIIX Python package\nlong_description=file: README.md\nlong_description_content_type=text/markdown\nlicense_file=license.txt\nurl=https://github.com/rordenlab/dcm2niix\nproject_urls=\n    Changelog=https://github.com/rordenlab/dcm2niix/releases\n    Documentation=https://www.nitrc.org/plugins/mwiki/index.php/dcm2nii:MainPage\nauthor=Li X, Morgan PS, Ashburner J, Smith J, Rorden C\nmaintainer=Casper da Costa-Luis\nmaintainer_email=imaging@cdcl.ml\nkeywords=research, jpeg, dicom, neuroscience, mri, neuroimaging, nifti, dcm, nii, nitrc, bids, dcm2niix, mricrogl\nclassifiers=\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Education\n    Intended Audience :: Healthcare Industry\n    Intended Audience :: Science/Research\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3 :: Only\n    Topic :: Scientific/Engineering :: Medical Science Apps.\n[options]\nsetup_requires=\n    setuptools>=42\n    wheel\n    setuptools_scm[toml]\n    scikit-build>=0.11.0\n    cmake>=3.18\n    ninja\npython_requires=>=3.6\n[options.entry_points]\nconsole_scripts=\n    dcm2niix=dcm2niix:main\n"
  },
  "sfepy/sfepy": {
    "setup.py": "#!/usr/bin/env python\n\"\"\"SfePy: Simple finite elements in Python\n\nSfePy (simple finite elements in Python) is a software, distributed\nunder the BSD license, for solving systems of coupled partial\ndifferential equations by the finite element method. The code is based\non NumPy and SciPy packages.\n\"\"\"\nimport glob\nimport os\n\nfrom skbuild import setup\nfrom setuptools import find_packages\n\nimport sys\nsys.path.append('./tools')\nfrom build_helpers import INFO, cmdclass, log, package_check\n\nfrom sfepy import config, version\n\nDOCLINES = __doc__.split(\"\\n\")\n\nVERSION = INFO.__version__\n\nCLASSIFIERS = \"\"\"\\\nDevelopment Status :: 3 - Alpha\nIntended Audience :: Science/Research\nIntended Audience :: Developers\nLicense :: OSI Approved :: BSD License\nProgramming Language :: C\nProgramming Language :: Python\nTopic :: Software Development\nTopic :: Scientific/Engineering\nOperating System :: POSIX\nOperating System :: MacOS :: MacOS X\nOperating System :: Microsoft :: Windows\n\"\"\"\n\nDOWNLOAD_URL = \"http://sfepy.org/doc-devel/downloads.html\"\n\n# BEFORE importing distutils, remove MANIFEST. distutils doesn't properly\n# update it when the contents of directories change.\nif os.path.exists('MANIFEST'): os.remove('MANIFEST')\n\n\ndef _cython_version(pkg_name):\n    from Cython.Compiler.Version import version\n\n    return version\n\n\ndef _igakit_version(pkg_name):\n    return '0.1'\n\n\ndef _pymetis_version(pkg_name):\n    import pymetis\n\n    return pymetis.version\n\n\ndef _scikit_umfpack_version(pkg_name):\n    try:\n        import scikits.umfpack; scikits.umfpack\n        try:\n            return scikits.umfpack.__version__\n\n        except AttributeError:\n            return '<0.3.1'\n\n    except:\n        return None\n\n\ndef check_versions(show_only=False):\n    # Cython is a build dependency.\n    package_check('cython', INFO.CYTHON_MIN_VERSION,\n                  version_getter=_cython_version,\n                  show_only=show_only)\n\n    # Check hard and soft dependencies.\n    package_check('numpy', INFO.NUMPY_MIN_VERSION,\n                  show_only=show_only)\n    package_check('scipy', INFO.SCIPY_MIN_VERSION,\n                  show_only=show_only)\n    package_check('matplotlib', INFO.MATPLOTLIB_MIN_VERSION,\n                  show_only=show_only)\n    package_check('pyparsing', INFO.PYPARSING_MIN_VERSION,\n                  show_only=show_only)\n    package_check('tables', INFO.PYTABLES_MIN_VERSION,\n                  show_only=show_only)\n    package_check('sympy', INFO.SYMPY_MIN_VERSION, optional=True,\n                  messages={'opt suffix' : '; some tests are going to fail!'},\n                  show_only=show_only)\n    package_check('igakit', INFO.IGAKIT_MIN_VERSION, optional=True,\n                  version_getter=_igakit_version,\n                  show_only=show_only)\n    package_check('petsc4py', INFO.PETSC4PY_MIN_VERSION, optional=True,\n                  show_only=show_only)\n    package_check('mpi4py', INFO.MPI4PY_MIN_VERSION, optional=True,\n                  show_only=show_only)\n    package_check('slepc4py', INFO.SLEPC4PY_MIN_VERSION, optional=True,\n                  show_only=show_only)\n    package_check('pymetis', INFO.PYMETIS_MIN_VERSION, optional=True,\n                  version_getter=_pymetis_version,\n                  show_only=show_only)\n    package_check('scikits.umfpack', INFO.SCIKIT_UMFPACK_MIN_VERSION,\n                  optional=True,\n                  version_getter=_scikit_umfpack_version,\n                  show_only=show_only)\n    package_check('meshio', INFO.MESHIO_MIN_VERSION,\n                  show_only=show_only)\n    package_check('psutil', INFO.PSUTIL_MIN_VERSION, optional=True,\n                  show_only=show_only)\n    package_check('pyvista', INFO.PYVISTA_MIN_VERSION, optional=True,\n                  show_only=show_only)\n    package_check('opt_einsum', INFO.OPT_EINSUM_MIN_VERSION, optional=True,\n                  show_only=show_only)\n    package_check('jax', INFO.JAX_MIN_VERSION, optional=True,\n                  show_only=show_only)\n    package_check('dask', INFO.DASK_MIN_VERSION, optional=True,\n                  show_only=show_only)\n\n\ndef data_dir_walk(dir_name: str, prefix: str) -> list:\n    \"\"\"\n    Generate instructions for setup() to add all files in a tree rooted at `dirname`\n    as data_files.\n    \"\"\"\n    data_files = []\n    for root, dirs, files in os.walk(dir_name):\n        full_paths = [os.path.join(root, fname) for fname in files]\n        data_files.append((os.path.join(prefix, root), full_paths))\n\n    return data_files\n\n\ndef compose_data_files() -> list:\n    data_files = [\n        ('sfepy', ['LICENSE', 'VERSION']),\n    ]\n    test_files = [('sfepy/tests', glob.glob('sfepy/tests/*.py'))]\n    mesh_data_files = data_dir_walk('meshes', 'sfepy')\n    example_files = data_dir_walk('examples', 'sfepy')\n\n    return data_files + test_files + mesh_data_files + example_files\n\n\ndef cmake_bool(py_bool: bool) -> str:\n    return \"ON\" if py_bool else \"OFF\"\n\n\ndef compose_cmake_args() -> list:\n    conf = config.Config()\n    cmake_args = [f'-DCMAKE_C_FLAGS={\" \".join(conf.compile_flags())}']\n\n    # Debug flags are always added explicitly, so they won't be taken from cmake cache.\n    debug_flags = set(conf.debug_flags())\n    cmake_args.append(f\"-DDEBUG_FMF={cmake_bool('DEBUG_FMF' in debug_flags)}\")\n    cmake_args.append(f\"-DDEBUG_MESH={cmake_bool('DEBUG_MESH' in debug_flags)}\")\n\n    # On Azure CI images, Ninja isn't found automaticvally. Since this is harmless\n    # on other platforms, we specify it here.\n    # See https://conda-forge.org/docs/maintainer/maintainer_faq.html#mfaq-windows-cmake\n    cmake_args.extend([\"-G\", \"Ninja\"])\n\n    return cmake_args\n\n\ndef setup_package():\n    # Write the version file.\n    fd = open('VERSION', 'w')\n    fd.write(VERSION)\n    fd.close()\n\n    # Create version.h file.\n    # There is probably a way to do it with CMake but we'll get to it later.\n    filename_in = 'sfepy/discrete/common/extmods/version.h.in'\n    filename_out = 'sfepy/discrete/common/extmods/version.h'\n    fdi = open(filename_in, 'r')\n    fdo = open(filename_out, 'w')\n    for line in fdi:\n        if line.find('VERSION \"0.0.0\"') >= 0:\n            aux = line.split()\n            aux[2] = VERSION\n            line = ' '.join(aux) + '\\n'\n        fdo.write(line)\n    fdi.close()\n    fdo.close()\n\n    install_requires = [\n        'matplotlib',\n        'meshio',\n        'numpy',\n        'pyparsing',\n        'pyvista',\n        'scipy',\n        'sympy',\n        'tables',\n    ]\n\n    setup(\n        name='sfepy',\n        version=version.__version__,\n        maintainer=\"Robert Cimrman\",\n        maintainer_email=\"cimrman3@ntc.zcu.cz\",\n        description=DOCLINES[0],\n        long_description=\"\\n\".join(DOCLINES[2:]),\n        url=\"http://sfepy.org\",\n        download_url=DOWNLOAD_URL,\n        license='BSD',\n        classifiers=list(filter(None, CLASSIFIERS.split('\\n'))),\n        platforms=[\"Linux\", \"Mac OS-X\", 'Windows'],\n        entry_points={\n          'console_scripts': [\n              'sfepy-convert=sfepy.scripts.convert_mesh:main',\n              'sfepy-mesh=sfepy.scripts.gen_mesh:main',\n              'sfepy-probe=sfepy.scripts.probe:main',\n              'sfepy-run=sfepy.scripts.simple:main',\n              'sfepy-test=sfepy.scripts.run_tests:main',\n              'sfepy-view=sfepy.scripts.resview:main',\n          ],\n        },\n        install_requires=install_requires,\n        cmdclass=cmdclass,\n        packages=find_packages(),\n        data_files=compose_data_files(),\n        setup_requires=['cython'],\n        cmake_args=compose_cmake_args(),\n        cmake_languages=('C')\n    )\n\n\nif __name__ == '__main__':\n    check_versions()\n    setup_package()\n\n    from sfepy import Config\n    site_config = Config()\n    log.info('\\nUsing Python {}.'.format(site_config.python_version()))\n\n    log.info('\\nRequired and optional packages found:\\n')\n    check_versions(show_only=True)",
    "pyproject.toml": "[build-system]\n# Minimum requirements for the build system to execute.\nrequires = [\n    \"scikit-build>=0.16.7\",\n    \"ninja\",\n    \"setuptools>=46.4\",\n    \"wheel\",\n\t\"Cython>=0.29.30\",\n    \"matplotlib\",\n    \"meshio\",\n    \"numpy==1.20.*; python_version <= '3.9'\", # meshio undeclared constraint.\n    \"oldest-supported-numpy; python_version > '3.9'\",\n    \"pyparsing\",\n    \"scipy\",\n    \"tables\",\n]\n"
  },
  "siliconcompiler/siliconcompiler": {
    "setup.py": "#!/usr/bin/env python3\n\nimport glob\nimport os\nimport shutil\nimport sys\nfrom setuptools import find_packages\n\n# Hack to get version number since it's considered bad practice to import your\n# own package in setup.py. This call defines keys 'version', 'authors', and\n# 'banner' in the `metadata` dict.\nmetadata = {}\nwith open('siliconcompiler/_metadata.py') as f:\n    exec(f.read(), metadata)\n\non_rtd = os.environ.get('READTHEDOCS') == 'True'\n\nif not on_rtd:\n    try:\n        from skbuild import setup\n    except ImportError:\n        print(\n            \"Error finding build dependencies!\\n\"\n            \"If you're installing this project using pip, make sure you're using pip version 10 \"\n            \"or greater.\\n\"\n            \"If you're installing this project by running setup.py, manually install all \"\n            \"dependencies listed in requirements.txt.\",\n            file=sys.stderr\n        )\n        raise\nelse:\n    from setuptools import setup\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as readme:\n    long_desc = readme.read()\n\n\ndef parse_reqs():\n    '''Parse out each requirement category from requirements.txt'''\n    install_reqs = []\n    extras_reqs = {}\n    current_section = None  # default to install\n\n    with open('requirements.txt', 'r') as reqs_file:\n        for line in reqs_file.readlines():\n            line = line.rstrip('\\n')\n            if line.startswith('#:'):\n                # strip off '#:' prefix to read extras name\n                current_section = line[2:]\n                if current_section not in extras_reqs:\n                    extras_reqs[current_section] = []\n            elif not line or line.startswith('#'):\n                # skip blanks and comments\n                continue\n            elif current_section is None:\n                install_reqs.append(line)\n            else:\n                extras_reqs[current_section].append(line)\n\n    return install_reqs, extras_reqs\n\n\n# Let us pass in generic arguments to CMake via an environment variable, since\n# our automated build servers need to pass in a certain argument when building\n# wheels on Windows.\ncmake_args = []\nif 'SC_CMAKEARGS' in os.environ:\n    cmake_args.append(os.environ['SC_CMAKEARGS'])\n\n# Autogenerate list of entry points based on each file in apps/\nentry_points_apps = []\nfor app in os.listdir('siliconcompiler/apps'):\n    name, ext = os.path.splitext(app)\n    if (name.startswith('sc') or name.startswith('sup')) and ext == '.py':\n        cli_name = name.replace('_', '-')\n        entry = f'{cli_name}=siliconcompiler.apps.{name}:main'\n        entry_points_apps.append(entry)\n\n# Remove the _skbuild/ directory before running install procedure. This helps\n# fix very opaque bugs we've run into where the install fails due to some bad\n# state being cached in this directory. This means we won't get caching of build\n# results, but since the leflib is small and compiles quickly, and a user likely\n# won't have to perform many installs anyways, this seems like a worthwhile\n# tradeoff.\nif os.path.isdir('_skbuild'):\n    print(\"Note: removing existing _skbuild/ directory.\")\n    shutil.rmtree('_skbuild')\n\nif not on_rtd:\n    skbuild_args = {\n        'cmake_install_dir': 'siliconcompiler/leflib',\n        'cmake_args': cmake_args\n    }\nelse:\n    skbuild_args = {}\n\n\ndef get_package_data(item, package):\n    '''Used to compensate for poor glob support in package_data'''\n    package_data = []\n    for f in glob.glob(f'{package}/{item}/**/*', recursive=True):\n        if os.path.isfile(f):\n            # strip off directory and add to list\n            package_data.append(f[len(package + '/'):])\n    return package_data\n\n\ninstall_reqs, extras_req = parse_reqs()\n\nsetup(\n    name=\"siliconcompiler\",\n    description=\"A compiler framework that automates translation from source code to silicon.\",\n    long_description=long_desc,\n    long_description_content_type=\"text/markdown\",\n    license='Apache License 2.0',\n    author=\"Andreas Olofsson\",\n    author_email=\"andreas.d.olofsson@gmail.com\",\n    url=\"https://siliconcompiler.com\",\n    project_urls={\n        \"Documentation\": \"https://docs.siliconcompiler.com\",\n        \"Source Code\": \"https://github.com/siliconcompiler/siliconcompiler\",\n        \"Bug Tracker\": \"https://github.com/siliconcompiler/siliconcompiler/issues\",\n        \"Forum\": \"https://github.com/siliconcompiler/siliconcompiler/discussions\"\n    },\n    version=metadata['version'],\n    packages=find_packages(where='.', exclude=['tests*']),\n\n    # TODO: hack to work around weird scikit-build behavior:\n    # https://github.com/scikit-build/scikit-build/issues/590\n    # Once this issue is resolved, we should switch to setting\n    # include_package_data to True instead of manually specifying package_data.\n\n    # include_package_data=True,\n    package_data={\n        'siliconcompiler':\n            [*get_package_data('templates', 'siliconcompiler'),\n             *get_package_data('data', 'siliconcompiler')],\n        'siliconcompiler.tools': get_package_data('.', 'siliconcompiler/tools'),\n        'siliconcompiler.checklists': get_package_data('.', 'siliconcompiler/checklists'),\n    },\n\n    python_requires=\">=3.6\",\n    install_requires=install_reqs,\n    extras_require=extras_req,\n    entry_points={\"console_scripts\": entry_points_apps},\n    **skbuild_args\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42,<64\",\n    \"wheel\",\n    \"cython\",\n    \"scikit-build>=0.12\",\n    \"cmake\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nmarkers = [\n    \"eda: this test requires EDA tools installed to run. By default these tests will be run nightly, not on push.\",\n    \"quick: always run this test on push, even if it requires EDA tools.\",\n    \"remote_test: marker used to pass 'port' variables into remote flow fixtures.\",\n    \"nostrict: don't automatically set [option, strict] parameter for Chip objects in this test.\",\n]\ntestpaths = \"tests\"\ntimeout = \"60\"\n"
  },
  "deepmind/hanabi-learning-environment": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    name='hanabi_learning_environment',\n    version='0.0.1',\n    description='Learning environment for the game of hanabi.',\n    author='deepmind/hanabi-learning-environment',\n    packages=['hanabi_learning_environment', 'hanabi_learning_environment.agents'],\n    install_requires=['cffi']\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n"
  },
  "deeptime-ml/deeptime": {
    "setup.py": "# based on https://github.com/pybind/scikit_build_example/blob/master/setup.py\n\nimport os\nimport sys\n\nfrom setuptools import find_namespace_packages\ntry:\n    import tomllib\nexcept ModuleNotFoundError:\n    import tomli as tomllib\n\nsys.path.insert(0, os.path.dirname(__file__))\nimport versioneer\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"Please update pip, you need pip 10 or greater\", file=sys.stderr)\n    raise\n\nwith open('pyproject.toml', 'rb') as f:\n    pyproject = tomllib.load(f)\n\n\ndef load_long_description():\n    with open(pyproject[\"project\"][\"readme\"], mode='r', encoding=\"utf-8\") as f:\n        return f.read()\n\n\ncmake_args = [\n    f\"-DDEEPTIME_VERSION={versioneer.get_version().split('+')[0]}\",\n    f\"-DDEEPTIME_VERSION_INFO={versioneer.get_version()}\"\n]\n\nexcludes = (\"tests\", \"tests.*\", \"examples\", \"examples.*\", \"docs\", \"docs.*\", \"devtools\", \"devtools.*\")\n\nmetadata = \\\n    dict(\n        long_description=load_long_description(),\n        long_description_content_type='text/markdown',\n        zip_safe=False,\n        packages=find_namespace_packages(where=\".\", exclude=excludes),\n        package_dir={\"deeptime\": \"deeptime\", \"versioneer\": \".\"},\n        cmake_install_dir=\"deeptime/\",\n        cmake_args=cmake_args,\n        include_package_data=True,\n        ext_modules=[],\n        version=versioneer.get_version(),\n        cmdclass=versioneer.get_cmdclass()\n    )\n\nif __name__ == '__main__':\n    setup(**metadata)\n",
    "pyproject.toml": "[project]\nname = \"deeptime\"\nreadme = \"README.md\"\ndescription = \"Python library for analysis of time series data including dimensionality reduction, clustering, and Markov model estimation.\"\nkeywords = [\n    \"markov-model\", \"hidden-markov-model\", \"time-series-analysis\", \"covariance-estimation\",\n    \"koopman-operator\", \"coherent-set-detection\"\n]\nauthors = [\n    {name = 'Moritz Hoffmann'},\n    {name = 'Martin Scherer'},\n    {name = 'Tim Hempel'},\n    {name = 'Andreas Mardt'},\n    {name = 'Maaike Galama'},\n    {name = 'Brian de Silva'},\n    {name = 'Brooke Husic'},\n    {name = 'Stefan Klus'},\n    {name = 'Hao Wu'},\n    {name = 'Nathan Kutz'},\n    {name = 'Steven Brunton'},\n    {name = 'Frank No\u00e9'}\n]\nrequires-python = \">= 3.8\"\ndependencies = [\n    'numpy>=1.20',\n    'scipy>=1.9.0',\n    'scikit-learn>=1.1',\n    'threadpoolctl>=3.1.0'\n]\ndynamic = ['version']\n\n[project.urls]\nhomepage = \"https://deeptime-ml.github.io\"\nrepository = \"https://github.com/deeptime-ml/deeptime\"\ndocumentation = \"https://deeptime-ml.github.io\"\ndownload = \"https://pypi.org/project/deeptime/#files\"\n\n[project.optional-dependencies]\ndeep-learning = ['torch']\nplotting = ['matplotlib', 'networkx']\nunits = ['pint>=0.20']\ntests = [\n    'torch>=1.12.0; platform_system!=\"Darwin\" and python_version<\"3.11\"',\n    'pytest==7.1.2',\n    'pytest-cov==3.0.0',\n    'coverage[toml]',\n    'pytest-xdist==2.5.0',\n    'flaky==3.7.0',\n    'tqdm==4.64.0',\n    \"cython>=0.29.30\",\n    \"pybind11>=2.10.1\",\n    \"networkx\",\n    \"matplotlib\",\n    \"cmake>=3.24\",\n    \"ninja; platform_system!='Windows'\"\n]\ndocs = [\n    \"sphinx\",\n    \"nbsphinx\",\n    \"sphinxcontrib-bibtex\",\n    \"matplotlib\",\n    \"networkx\",\n    \"sphinxcontrib-katex\",\n    \"sphinx-gallery\",\n    \"torch\",\n    \"memory_profiler\",\n    \"mdshare\",\n    \"nbconvert\",\n    \"jupyter\",\n    \"tqdm\"\n]\n\n[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build>=0.16\",\n    \"cython>=0.29.30\",\n    \"pybind11>=2.10.1\",\n    \"numpy>=1.20\",\n    \"cmake>=3.24\",\n    \"tomli; python_version < '3.11'\",\n    \"scipy==1.9.3\",\n    \"ninja; platform_system!='Windows'\",\n    \"versioneer[toml]==0.28\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nfilterwarnings = [\"once\", \"ignore::UserWarning\"]\n\n[tool.versioneer]\nVCS = \"git\"\nstyle = \"pep440\"\nversionfile_source = \"deeptime/_version.py\"\nversionfile_build = \"deeptime/_version.py\"\ntag_prefix = \"v\"\n\n[tool.flake8]\nignore = ['E24', 'E121', 'E123', 'E126', 'E226', 'E704', 'W503', 'W504']\nmax-line-length = 120\n\n[tool.coverage.report]\nexclude_lines = [\"@plotting_function\", \"pragma: no cover\"]\nomit = [\"*/**/setup.py\", \"tests/*\", \"deeptime/_version.py\"]\n\n[tool.coverage.run]\nomit = [\"*/**/setup.py\", \"tests/*\", \"*/**/*.pyx\", \"deeptime/_version.py\"]\n\n[tool.cibuildwheel]\nbuild-verbosity = 1\n"
  },
  "nv-legate/cunumeric": {
    "setup.py": "#!/usr/bin/env python3\n\n# Copyright 2021-2022 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport versioneer\n\nsetup(\n    name=\"cunumeric\",\n    version=versioneer.get_version(),\n    description=\"An Aspiring Drop-In Replacement for NumPy at Scale\",\n    url=\"https://github.com/nv-legate/cunumeric\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"cunumeric*\"],\n    ),\n    package_data={\"cunumeric\": [\"_sphinxext/_templates/*.rst\"]},\n    include_package_data=True,\n    cmdclass=versioneer.get_cmdclass(),\n    install_requires=[\"numpy>=1.22\"],\n    zip_safe=False,\n)\n",
    "pyproject.toml": "# Copyright (c) 2021-2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nrequires = [\n    \"wheel\",\n    \"ninja\",\n    \"setuptools\",\n    \"scikit-build>=0.13.1\",\n    \"cmake>=3.22.1,!=3.23.0,!=3.25.0\",\n]\n\n[tool.pytest.ini_options]\naddopts = \"--capture=sys\"\n\n\n[tool.black]\nline-length = 79\ntarget-version = [\"py36\"]\ninclude = '\\.py?$'\nexclude = '''\n/(\n    \\.eggs |\n    \\.git |\n    \\.mypy_cache |\n    \\.tox |\n    \\.venv |\n    _build |\n    buck-out |\n    build |\n    dist\n)/\n'''\n\n[tool.mypy]\npython_version = \"3.10\"\n\npretty = true\nshow_error_codes = true\nshow_error_context = true\nshow_column_numbers = true\n\nnamespace_packages = true\nignore_missing_imports = false\n\ndisallow_any_unimported = true\ndisallow_any_expr = false\ndisallow_any_decorated = false\ndisallow_any_explicit = false\ndisallow_any_generics = true\ndisallow_subclassing_any = true\n\ndisallow_untyped_calls = true\ndisallow_untyped_defs = true\ndisallow_incomplete_defs = true\ncheck_untyped_defs = true\ndisallow_untyped_decorators = true\nno_implicit_optional = true\nstrict_optional = true\n\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_no_return = true\nwarn_return_any = false\nwarn_unreachable = true\n\nignore_errors = false\n\nallow_untyped_globals = false\nallow_redefinition = false\nimplicit_reexport = true\nstrict_equality = true\n\nwarn_unused_configs = true\n\n[[tool.mypy.overrides]]\n# ignore auto-generated files\n# or files depending on auto-generated field\n# legate files need to be listed here for now\n# since they are included in the type check\nmodule = [\n  \"cunumeric.install_info\",\n  \"cunumeric._version\",\n  \"legate._version\",\n  \"legate.__main__\",\n  \"legate.install_info\",\n]\nignore_errors = true\n",
    "setup.cfg": "# Copyright (c) 2021-2022, NVIDIA CORPORATION.\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = cunumeric/_version.py\nversionfile_build = cunumeric/_version.py\ntag_prefix = v\nparentdir_prefix = cunumeric-\n\n[flake8]\nexclude = __init__.py\nignore =\n    # line break before binary operator\n    W503\n    # whitespace before :\n    E203\n    # undefined, or defined from star imports\n    F405\n\n[isort]\nline_length=79\nmulti_line_output=3\ninclude_trailing_comma=True\nforce_grid_wrap=0\ncombine_as_imports=True\norder_by_type=True\nknown_third_party=\n    numpy\nknown_legion=\n    legion_cffi\n    legion_top\nknown_first_party=\n    cunumeric\ndefault_section=THIRDPARTY\nsections=FUTURE,STDLIB,THIRDPARTY,LEGION,FIRSTPARTY,LOCALFOLDER\nskip=\n    .eggs\n    .git\n    .mypy_cache\n    .tox\n    .venv\n    _build\n    build\n    dist\n    legion\n    __init__.py\n\n[options]\npackages = find:\ninstall_requires =\n    numpy>=1.22\n    # TODO: Add rest of install dependencies\npython_requires = >=3.9,!=3.9.7\n"
  },
  "microsoft/picologging": {
    "setup.py": "from setuptools import find_packages\nfrom skbuild import setup\n\nwith open(\"./README.md\") as fh:\n    long_description = fh.read()\n\n\nsetup(\n    name=\"picologging\",\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    package_data={\n        \"picologging\": [\"py.typed\", \"__init__.pyi\", \"config.pyi\", \"handlers.pyi\"]\n    },\n    version=\"0.9.2\",\n    author=\"Microsoft\",\n    description=\"A fast and lightweight logging library for Python\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/microsoft/picologging\",\n    license=\"MIT License\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: System :: Logging\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    install_requires=[],\n    python_requires=\">=3.7\",\n    extras_require={\n        \"dev\": [\n            \"rich\",\n            \"pytest\",\n            \"pytest-cov\",\n            \"hypothesis\",\n            \"flaky\",\n            \"black\",\n            \"pre-commit\",\n        ]\n    },\n    project_urls={\n        \"Source\": \"https://github.com/microsoft/picologging\",\n        \"Documentation\": \"https://microsoft.github.io/picologging/\",\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=65.4.1\",\n    \"scikit-build>=0.17.0\",\n    \"cmake>=3.18\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\n# skip musl and pypy\nskip = [\"*-musllinux*\", \"pp*\", \"*-win_arm64\"] \ntest-requires = \"pytest\"\ntest-command = \"python -X dev -m pytest {project}/tests\"\ntest-skip = [\"*-win_arm64\", \"*-macosx_universal2:arm64\"]\n\n[tool.cibuildwheel.macos]\nenvironment = { MACOSX_DEPLOYMENT_TARGET = \"10.15\" }\narchs = [\"x86_64\", \"universal2\"]\n\n[tool.cibuildwheel.linux]\narchs = [\"i686\", \"x86_64\", \"aarch64\"]\n\n[tool.cibuildwheel.windows]\narchs = [\"x86\", \"AMD64\", \"ARM64\"]\n\n[tool.pylint.messages_control]\ndisable = \"C0114,C0115,C0116\"\n\n[tool.isort]\nprofile = \"black\"\n"
  },
  "potassco/clingo": {
    "setup.py": "import sys\nimport site\nfrom textwrap import dedent\nfrom skbuild import setup\n\nif not site.ENABLE_USER_SITE and \"--user\" in sys.argv[1:]:\n    site.ENABLE_USER_SITE = True\n\nsetup(\n    version = '5.6.0',\n    name = 'clingo',\n    description = 'CFFI-based bindings to the clingo solver.',\n    long_description = dedent('''\\\n        This package provides CFFI-based bindings to the clingo solver.\n\n        Clingo is part of the [Potassco](https://potassco.org) project for *Answer Set Programming* (ASP).\n        ASP offers a simple and powerful modeling language to describe combinatorial problems as *logic programs*.\n        The *clingo* system then takes such a logic program and computes *answer sets* representing solutions to the given problem.\n        To get an idea, check our [Getting Started](https://potassco.org/doc/start/) page and the [online version](https://potassco.org/clingo/run/) of clingo.\n\n        Please check the the [API documentation](https://potassco.org/clingo/python-api/current/clingo/) on how to use this module.\n        '''),\n    long_description_content_type='text/markdown',\n    author = 'Roland Kaminski',\n    author_email = 'kaminski@cs.uni-potsdam.de',\n    license = 'MIT',\n    url = 'https://github.com/potassco/clingo',\n    install_requires=[ 'cffi' ],\n    cmake_args=[ '-DCLINGO_MANAGE_RPATH=OFF',\n                 '-DCLINGO_BUILD_APPS=OFF',\n                 '-DCLINGO_BUILD_WITH_PYTHON=pip',\n                 '-DCLINGO_BUILD_WITH_LUA=OFF',\n                 '-DPYCLINGO_INSTALL_DIR=libpyclingo' ],\n    packages=[ 'clingo' ],\n    package_data={ 'clingo': [ 'py.typed', 'import__clingo.lib', 'clingo.h', 'clingo.hh' ] },\n    package_dir={ '': 'libpyclingo' },\n    python_requires=\">=3.6\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n"
  },
  "rapidsai/cuspatial": {
    "python/cuspatial/setup.py": "# Copyright (c) 2018-2022, NVIDIA CORPORATION.\nimport versioneer\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nsetup(\n    name=\"cuspatial\",\n    version=versioneer.get_version(),\n    description=(\n        \"cuSpatial: GPU-Accelerated Spatial and Trajectory Data Management and\"\n        \" Analytics Library\"\n    ),\n    url=\"https://github.com/rapidsai/cuspatial\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n    ],\n    packages=find_packages(include=[\"cuspatial\", \"cuspatial.*\"]),\n    package_data={\"cuspatial._lib\": [\"*.pxd\"]},\n    cmdclass=versioneer.get_cmdclass(),\n    install_requires=[\"numba\"],\n    zip_safe=False,\n)\n",
    "python/cuspatial/pyproject.toml": "# Copyright (c) 2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\n\nrequires = [\n    \"wheel\",\n    \"setuptools\",\n    \"cython>=0.29,<0.30\",\n    \"scikit-build>=0.13.1\",\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"ninja\",\n]\n",
    "python/cuspatial/setup.cfg": "# Copyright (c) 2018, NVIDIA CORPORATION.\n\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = cuspatial/_version.py\nversionfile_build = cuspatial/_version.py\ntag_prefix = v\nparentdir_prefix = cuspatial-\n\n[flake8]\nexclude = __init__.py\nignore =\n    # line break before binary operator\n    W503\n    # whitespace before :\n    E203\n\n[isort]\nline_length=79\nmulti_line_output=3\ninclude_trailing_comma=True\nforce_grid_wrap=0\ncombine_as_imports=True\norder_by_type=True\nknown_dask=\n    dask\n    distributed\n    dask_cuda\nknown_rapids=\n    librmm_cffi\n    nvtext\n    cuml\n    cugraph\n    cudf\n    dask_cudf\nknown_first_party=\n    cuspatial\ndefault_section=THIRDPARTY\nsections=FUTURE,STDLIB,THIRDPARTY,DASK,RAPIDS,FIRSTPARTY,LOCALFOLDER\nskip=\n    thirdparty\n    .eggs\n    .git\n    .hg\n    .mypy_cache\n    .tox\n    .venv\n    _build\n    buck-out\n    build\n    dist\n    __init__.py\n"
  },
  "equinor/segyio": {
    "python/setup.py": "import os\nimport sys\nimport skbuild\nimport setuptools\n\nlong_description = \"\"\"\n=======\nSEGY IO\n=======\n\nhttps://segyio.readthedocs.io\n\nIntroduction\n------------\n\nSegyio is a small LGPL licensed C library for easy interaction with SEG Y\nformatted seismic data, with language bindings for Python and Matlab. Segyio is\nan attempt to create an easy-to-use, embeddable, community-oriented library for\nseismic applications. Features are added as they are needed; suggestions and\ncontributions of all kinds are very welcome.\n\nFeature summary\n---------------\n * A low-level C interface with few assumptions; easy to bind to other\n   languages.\n * Read and write binary and textual headers.\n * Read and write traces, trace headers.\n * Easy to use and native-feeling python interface with numpy integration.\n\nProject goals\n-------------\n\nSegyio does necessarily attempt to be the end-all of SEG-Y interactions;\nrather, we aim to lower the barrier to interacting with SEG-Y files for\nembedding, new applications or free-standing programs.\n\nAdditionally, the aim is not to support the full standard or all exotic (but\ncorrectly) formatted files out there. Some assumptions are made, such as:\n\n * All traces in a file are assumed to be of the same sample size.\n * It is assumed all lines have the same number of traces.\n\nThe writing functionality in Segyio is largely meant to *modify* or adapt\nfiles. A file created from scratch is not necessarily a to-spec SEG-Y file, as\nwe only necessarily write the header fields segyio needs to make sense of the\ngeometry. It is still highly recommended that SEG-Y files are maintained and\nwritten according to specification, but segyio does not mandate this.\n\n\"\"\"\n\ndef src(x):\n    root = os.path.dirname( __file__ )\n    return os.path.abspath(os.path.join(root, x))\n\nif 'MAKEFLAGS' in os.environ:\n    # if setup.py is called from cmake, it reads and uses the MAKEFLAGS\n    # environment variable, which in turn gets picked up on by scikit-build.\n    # However, scikit-build uses make install to move the built .so to the\n    # right object, still in the build tree. This make invocation honours\n    # DESTDIR, which leads to unwanted items in the destination tree.\n    #\n    # If the MAKEFLAGS env var is set, remove DESTDIR from it.\n    #\n    # Without this: make install DESTDIR=/tmp\n    # /tmp/src/segyio/python/_skbuild/linux-x86_64-3.5/cmake-install/segyio/_segyio.so\n    # /tmp/usr/local/lib/python2.7/site-packages/segyio/_segyio.so\n    #\n    # with this the _skbuild install is gone\n    makeflags = os.environ['MAKEFLAGS']\n    flags = makeflags.split(' ')\n    flags = [flag for flag in flags if not flag.startswith('DESTDIR=')]\n    os.environ['MAKEFLAGS'] = ' '.join(flags)\n\nskbuild.setup(\n    name = 'segyio',\n    description = 'Simple & fast IO for SEG-Y files',\n    long_description = long_description,\n    author = 'Equinor ASA',\n    author_email = 'jokva@equinor.com',\n    url = 'https://github.com/equinor/segyio',\n    packages = ['segyio', 'segyio.su'],\n    package_data = { 'segyio': ['segyio.dll'], },\n    license = 'LGPL-3.0',\n    platforms = 'any',\n    install_requires = ['numpy >= 1.10'],\n    setup_requires = [\n        'setuptools >= 28',\n        'pytest-runner',\n        'scikit-build',\n    ],\n    tests_require = ['pytest'],\n    cmake_args = [\n        # we can safely pass OSX_DEPLOYMENT_TARGET as it's ignored on\n        # everything not OS X. We depend on C++11, which makes our minimum\n        # supported OS X release 10.9\n        '-DCMAKE_OSX_DEPLOYMENT_TARGET=10.9',\n    ],\n    cmdclass = { 'test': setuptools.command.test.test },\n    classifiers = [\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Other Environment',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)',\n        'Natural Language :: English',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Topic :: Scientific/Engineering',\n        'Topic :: Scientific/Engineering :: Physics',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: Utilities'\n    ],\n)\n",
    "python/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools >= 40\",\n    \"scikit-build\",\n    \"wheel\",\n    \"pybind11\",\n    \"pytest-runner\",\n]\n\n[tool.cibuildwheel]\nbefore-build = [\n    \"\"\"cmake \\\n        -S . \\\n        -B build \\\n        -DCMAKE_BUILD_TYPE=Release \\\n        -DCMAKE_POSITION_INDEPENDENT_CODE=ON \\\n        -DBUILD_TESTING=OFF \\\n        -DBUILD_PYTHON=OFF \\\n        -DBUILD_BIN=OFF \\\n    \"\"\",\n    \"\"\"cmake \\\n        --build build \\\n        --parallel \\\n        --target install \\\n        --config Release \\\n    \"\"\",\n]\n\ntest-requires = \"pytest\"\n\n# Copy out test folder to make sure that tests are runned against the wheel and\n# not the source. Test assumes a relative path to the test-data directory, so\n# copy that too. segyio's python test-suite doesn't follow common naming\n# convensions for filenames. Hence pytest doesn't pick them up by default.\n# If not for powershell on windows we could simply run 'pytest test/*.py'.\n# Instead we copy setup.cfg which embeds the same pattern but doesn't rely on\n# the shell.\ntest-command = [\n    \"\"\"python {project}/.github/utils.py copy -r \\\n        --src {package}/test                     \\\n        --dst tmptest/python/test                \\\n    \"\"\",\n    \"\"\"python {project}/.github/utils.py copy -r \\\n        --src {project}/test-data                \\\n        --dst tmptest/test-data                  \\\n    \"\"\",\n    \"\"\"python {project}/.github/utils.py copy \\\n        --src {package}/setup.cfg             \\\n        --dst tmptest/python/setup.cfg        \\\n    \"\"\",\n    \"\"\"cd tmptest/python\"\"\",\n    \"\"\"pytest test\"\"\",\n    \"\"\"cd ../../\"\"\",\n    \"\"\"python {project}/.github/utils.py remove --paths tmptest\"\"\",\n]\n\n[tool.cibuildwheel.linux]\nmanylinux-x86_64-image = \"manylinux2010\"\n\n[[tool.cibuildwheel.overrides]]\nselect = \"cp311*\"\nmanylinux-x86_64-image = \"manylinux2014\"\n\n[tool.cibuildwheel.macos]\nenvironment = { CXXFLAGS=\"-L/usr/local/lib\" }\n",
    "python/setup.cfg": "[metadata]\nversion = 1.9.11\n\n[aliases]\ntest=pytest\n\n[tool:pytest]\npython_files = test/*.py\n"
  },
  "pfsense/FreeBSD-ports": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "arrayfire/arrayfire-python": {
    "setup.py": "#!/usr/bin/env python\n\n#######################################################\n# Copyright (c) 2015, ArrayFire\n# All rights reserved.\n#\n# This file is distributed under 3-clause BSD license.\n# The complete license agreement can be obtained at:\n# http://arrayfire.com/licenses/BSD-3-Clause\n########################################################\n\nimport os\nimport re\n\n# package can be distributed with arrayfire binaries or\n# just with python wrapper files, the AF_BUILD_LOCAL\n# environment var determines whether to build the arrayfire\n# binaries locally rather than searching in a system install\n\nAF_BUILD_LOCAL_LIBS = os.environ.get('AF_BUILD_LOCAL_LIBS')\nprint(f'AF_BUILD_LOCAL_LIBS={AF_BUILD_LOCAL_LIBS}')\nif AF_BUILD_LOCAL_LIBS:\n    print('Proceeding to build ArrayFire libraries')\nelse:\n    print('Skipping binaries installation, only python files will be installed')\n\nAF_BUILD_CPU = os.environ.get('AF_BUILD_CPU')\nAF_BUILD_CPU = 1 if AF_BUILD_CPU is None else int(AF_BUILD_CPU)\nAF_BUILD_CPU_CMAKE_STR = '-DAF_BUILD_CPU:BOOL=ON' if (AF_BUILD_CPU == 1) else '-DAF_BUILD_CPU:BOOL=OFF'\n\nAF_BUILD_CUDA = os.environ.get('AF_BUILD_CUDA')\nAF_BUILD_CUDA = 1 if AF_BUILD_CUDA is None else int(AF_BUILD_CUDA)\nAF_BUILD_CUDA_CMAKE_STR = '-DAF_BUILD_CUDA:BOOL=ON' if (AF_BUILD_CUDA == 1) else '-DAF_BUILD_CUDA:BOOL=OFF'\n\nAF_BUILD_OPENCL = os.environ.get('AF_BUILD_OPENCL')\nAF_BUILD_OPENCL = 1 if AF_BUILD_OPENCL is None else int(AF_BUILD_OPENCL)\nAF_BUILD_OPENCL_CMAKE_STR = '-DAF_BUILD_OPENCL:BOOL=ON' if (AF_BUILD_OPENCL == 1) else '-DAF_BUILD_OPENCL:BOOL=OFF'\n\nAF_BUILD_UNIFIED = os.environ.get('AF_BUILD_UNIFIED')\nAF_BUILD_UNIFIED = 1 if AF_BUILD_UNIFIED is None else int(AF_BUILD_UNIFIED)\nAF_BUILD_UNIFIED_CMAKE_STR = '-DAF_BUILD_UNIFIED:BOOL=ON' if (AF_BUILD_UNIFIED == 1) else '-DAF_BUILD_UNIFIED:BOOL=OFF'\n\nif AF_BUILD_LOCAL_LIBS:\n    # invoke cmake and build arrayfire libraries to install locally in package\n    from skbuild import setup\n\n    def filter_af_files(cmake_manifest):\n        cmake_manifest = list(filter(lambda name: not (name.endswith('.h') \n            or name.endswith('.cpp')\n            or name.endswith('.hpp')\n            or name.endswith('.cmake')\n            or name.endswith('jpg')\n            or name.endswith('png')\n            or name.endswith('libaf.so') #avoids duplicates due to symlinks\n            or re.match('.*libaf\\.so\\.3\\..*', name) is not None\n            or name.endswith('libafcpu.so')\n            or re.match('.*libafcpu\\.so\\.3\\..*', name) is not None\n            or name.endswith('libafcuda.so')\n            or re.match('.*libafcuda\\.so\\.3\\..*', name) is not None\n            or name.endswith('libafopencl.so')\n            or re.match('.*libafopencl\\.so\\.3\\..*', name) is not None\n            or name.endswith('libforge.so')\n            or re.match('.*libforge\\.so\\.1\\..*', name) is not None\n            or 'examples' in name), cmake_manifest))\n        return cmake_manifest\n\n    print('Building CMAKE with following configurable variables: ')\n    print(AF_BUILD_CPU_CMAKE_STR)\n    print(AF_BUILD_CUDA_CMAKE_STR)\n    print(AF_BUILD_OPENCL_CMAKE_STR)\n    print(AF_BUILD_UNIFIED_CMAKE_STR)\n\n\n    setup(\n        packages=['arrayfire'],\n        cmake_install_dir='',\n        cmake_process_manifest_hook=filter_af_files,\n        include_package_data=False,\n        cmake_args=[AF_BUILD_CPU_CMAKE_STR,\n                    AF_BUILD_CUDA_CMAKE_STR,\n                    AF_BUILD_OPENCL_CMAKE_STR,\n                    AF_BUILD_UNIFIED_CMAKE_STR,\n                    # todo: pass additional args from environ\n                    '-DCMAKE_BUILD_TYPE:STRING=\"RelWithDebInfo\"',\n                    '-DFG_USE_STATIC_CPPFLAGS:BOOL=OFF',\n                    '-DFG_WITH_FREEIMAGE:BOOL=OFF',\n                    '-DCUDA_architecture_build_targets:STRING=All', \n                    '-DAF_BUILD_DOCS:BOOL=OFF',\n                    '-DAF_BUILD_EXAMPLES:BOOL=OFF',\n                    '-DAF_INSTALL_STANDALONE:BOOL=ON',\n                    '-DAF_WITH_IMAGEIO:BOOL=ON',\n                    '-DAF_WITH_LOGGING:BOOL=ON',\n                    '-DBUILD_TESTING:BOOL=OFF',\n                    '-DAF_BUILD_FORGE:BOOL=ON',\n                    '-DAF_INSTALL_LIB_DIR:STRING=arrayfire',\n                    '-DAF_INSTALL_BIN_DIR:STRING=arrayfire',\n                    '-DFG_INSTALL_LIB_DIR:STRING=arrayfire',\n                    '-DAF_WITH_STATIC_MKL=ON',\n                    ]\n    )\n\nelse:\n    # ignores local arrayfire libraries, will search system instead\n    from setuptools import setup\n    setup()\n\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n",
    "setup.cfg": "[metadata]\nname = arrayfire\nversion = 3.8.0\ndescription = Python bindings for ArrayFire\nlicence = BSD\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nmaintainer = ArrayFire\nmaintainer_email = technical@arrayfire.com\nurl = http://arrayfire.com\nclassifiers =\n    Programming Language :: Python\n    Programming Language :: Python :: 2.7\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n\n[options]\npackages = find:\ninstall_requires =\n    scikit-build\npython_requires =\n    >=3.8.0\n\n[options.packages.find]\ninclude = arrayfire\nexclude =\n    examples\n    tests\ninstall_requires =\n    numpy~=1.22.0\n\n[options.extras_require]\ndev =\n    autopep8~=1.6.0\n    isort~=5.10.1\n    flake8~=4.0.1\n    flake8-quotes~=3.2.0\n    mypy~=0.942\ntest =\n    pytest~=7.1.2\n    pytest-cov~=3.0.0\n    pytest-isort~=3.0.0\n    pytest-flake8~=1.1.1\n    pytest-mypy~=0.9.1\n\n[tool:isort]\nline_length = 119\nmulti_line_output = 4\n\n[flake8]\nexclude = venv\napplication-import-names = arrayfire\nimport-order-style = pep8\ninline-quotes = double\nmax-line-length = 119\n\n[mypy]\nexclude = venv\ndisallow_incomplete_defs = true\ndisallow_untyped_defs = true\nignore_missing_imports = true\nshow_error_codes = true\nwarn_return_any = true\n"
  },
  "mitsuba-renderer/drjit": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sys, re, os\n\ntry:\n    from skbuild import setup\n    import pybind11\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nVERSION_REGEX = re.compile(\n    r\"^\\s*#\\s*define\\s+DRJIT_VERSION_([A-Z]+)\\s+(.*)$\", re.MULTILINE)\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\n\nwith open(os.path.join(\"include/drjit/fwd.h\")) as f:\n    matches = dict(VERSION_REGEX.findall(f.read()))\n    drjit_version = \"{MAJOR}.{MINOR}.{PATCH}\".format(**matches)\n\nwith open(os.path.join(this_directory, 'README.rst'), encoding='utf-8') as f:\n    long_description = f.read()\n\nlong_description = long_description[long_description.find('About this project'):]\n\ndrjit_cmake_toolchain_file = os.environ.get(\"DRJIT_CMAKE_TOOLCHAIN_FILE\", \"\")\ndrjit_python_stubs_dir = os.environ.get(\"DRJIT_PYTHON_STUBS_DIR\", \"\")\n\nsetup(\n    name=\"drjit\",\n    version=drjit_version,\n    author=\"Wenzel Jakob\",\n    author_email=\"wenzel.jakob@epfl.ch\",\n    description=\"A Just-In-Time-Compiler for Differentiable Rendering\",\n    url=\"https://github.com/mitsuba-renderer/drjit\",\n    license=\"BSD\",\n    long_description=long_description,\n    long_description_content_type='text/x-rst',\n    cmake_args=[\n        '-DDRJIT_ENABLE_JIT:BOOL=ON',\n        '-DDRJIT_ENABLE_AUTODIFF:BOOL=ON',\n        '-DDRJIT_ENABLE_PYTHON:BOOL=ON',\n        '-DCMAKE_INSTALL_LIBDIR=drjit',\n        '-DCMAKE_INSTALL_BINDIR=drjit',\n        '-DCMAKE_INSTALL_INCLUDEDIR=drjit/include',\n        '-DCMAKE_INSTALL_DATAROOTDIR=drjit/share',\n        f'-DCMAKE_TOOLCHAIN_FILE={drjit_cmake_toolchain_file}',\n        f'-DDRJIT_PYTHON_STUBS_DIR:STRING={drjit_python_stubs_dir}'\n    ],\n    packages=['drjit'],\n    python_requires=\">=3.8\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"pybind11>=2.10.1\"]\n\n[tool.pytest.ini_options]\nnorecursedirs = [ \"ext\" ]\n"
  },
  "Qiskit/qiskit-aer": {
    "setup.py": "# pylint: disable=invalid-name\n\n\"\"\"\nMain setup file for qiskit-aer\n\"\"\"\nimport os\nimport platform\n\nimport setuptools\nfrom skbuild import setup\n\n\nPACKAGE_NAME = os.getenv(\"QISKIT_AER_PACKAGE_NAME\", \"qiskit-aer\")\n\nextras_requirements = {\"dask\": [\"dask\", \"distributed\"]}\n\nrequirements = [\n    \"qiskit-terra>=0.21.0\",\n    \"numpy>=1.16.3\",\n    \"scipy>=1.0\",\n]\n\nVERSION_PATH = os.path.join(os.path.dirname(__file__), \"qiskit_aer\", \"VERSION.txt\")\nwith open(VERSION_PATH, \"r\") as version_file:\n    VERSION = version_file.read().strip()\n\nREADME_PATH = os.path.join(os.path.abspath(os.path.dirname(__file__)), \"README.md\")\nwith open(README_PATH) as readme_file:\n    README = readme_file.read()\n\n\ncmake_args = []\nis_win_32_bit = platform.system() == \"Windows\" and platform.architecture()[0] == \"32bit\"\nif is_win_32_bit:\n    cmake_args.append(\"-DCMAKE_GENERATOR_PLATFORM=Win32\")\n\nsetup(\n    name=PACKAGE_NAME,\n    version=VERSION,\n    packages=setuptools.find_packages(exclude=[\"test*\"]),\n    cmake_source_dir=\".\",\n    description=\"Qiskit Aer - High performance simulators for Qiskit\",\n    long_description=README,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/Qiskit/qiskit-aer\",\n    author=\"AER Development Team\",\n    author_email=\"hello@qiskit.org\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Environment :: Console\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Topic :: Scientific/Engineering\",\n    ],\n    python_requires=\">=3.7\",\n    install_requires=requirements,\n    include_package_data=False,\n    package_data={\"qiskit_aer\": [\"VERSION.txt\"], \"qiskit_aer.library\": [\"*.csv\"]},\n    extras_require=extras_requirements,\n    cmake_args=cmake_args,\n    keywords=\"qiskit aer simulator quantum addon backend\",\n    zip_safe=False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools\",\n  \"conan<2.0.0\",\n  \"scikit-build>=0.11.0\",\n  \"cmake!=3.17.1,!=3.17.0\",\n  \"ninja\",\n  \"pybind11>2.6\",\n  \"oldest-supported-numpy; python_version>'3.7' or platform_machine=='aarch64' or platform_python_implementation=='PyPy'\",\n  \"numpy==1.16.3; python_version<='3.7' and platform_machine!='aarch64' or platform_python_implementation=='PyPy'\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nmanylinux-x86_64-image = \"manylinux2014\"\nmanylinux-i686-image = \"manylinux2014\"\nskip = \"pp* cp36* *musllinux*\"\ntest-skip = \"cp310-win32 cp310-manylinux_i686 cp311-win32 cp311-manylinux_i686\"\ntest-command = \"python {project}/tools/verify_wheels.py\"\n# We need to use pre-built versions of Numpy and Scipy in the tests; they have a\n# tendency to crash if they're installed from source by `pip install`, and since\n# Numpy 1.22 there are no i686 wheels, so we force pip to use older ones without\n# restricting any dependencies that Numpy and Scipy might have.\nbefore-test = \"pip install --only-binary=numpy,scipy numpy scipy\"\n\n[tool.cibuildwheel.linux]\nbefore-all = \"yum install -y openblas-devel\"\n\n[tool.cibuildwheel.windows]\nenvironment = { CMAKE_GENERATOR = \"Visual Studio 16 2019\"}\n\n[[tool.cibuildwheel.overrides]]\nselect = \"cp3{7,8,9,10,11}-manylinux_i686\"\nbefore-all = \"yum install -y wget && bash {project}/tools/install_openblas_i686.sh && bash {project}/tools/install_rust.sh\"\n\n[tool.black]\nline-length = 100\ntarget-version = ['py37', 'py38', 'py39', 'py310', 'py311']\n"
  },
  "Blosc/python-blosc": {
    "setup.py": "########################################################################\n#\n#       License: BSD 3-clause\n#       Created: September 22, 2010\n#       Author:  The Blosc development team\n#\n########################################################################\n\n# flake8: noqa\n\nimport os\nimport sys\n\nfrom skbuild import setup\nfrom textwrap import dedent\n\n\nif __name__ == '__main__':\n\n    try:\n        import cpuinfo\n        cpu_info = cpuinfo.get_cpu_info()\n    except Exception:\n        # newer cpuinfo versions fail to import on unsupported architectures\n        cpu_info = None\n\n    ########### Check versions ##########\n    def exit_with_error(message):\n        print('ERROR: %s' % message)\n        sys.exit(1)\n\n    ########### End of checks ##########\n\n    # Read the long_description from README.rst\n    with open('README.rst') as f:\n        long_description = f.read()\n\n    # Blosc version\n    with open('VERSION') as f:\n        VERSION = f.read().strip()\n\n    # Create the version.py file\n    with open('blosc/version.py', 'w') as f:\n        f.write('__version__ = \"%s\"\\n' % VERSION)\n\n    def cmake_bool(cond):\n        return 'ON' if cond else 'OFF'\n\n    classifiers = dedent(\"\"\"\\\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Developers\n    Intended Audience :: Information Technology\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: BSD License\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3.11\n    Programming Language :: Python :: 3 :: Only\n    Topic :: Software Development :: Libraries :: Python Modules\n    Topic :: System :: Archiving :: Compression\n    Operating System :: Microsoft :: Windows\n    Operating System :: Unix\n    \"\"\")\n\n    setup(name = \"blosc\",\n        version = VERSION,\n        description = 'Blosc data compressor',\n        long_description = long_description,\n        classifiers = [c for c in classifiers.split(\"\\n\") if c],\n        python_requires=\">=3.8\",\n        author = 'The Blosc development team',\n        author_email = 'blosc@blosc.org',\n        maintainer = 'The Blosc development team',\n        maintainer_email = 'blosc@blosc.org',\n        url = 'https://github.com/blosc/python-blosc',\n        license = 'https://opensource.org/licenses/BSD-3-Clause',\n        platforms = ['any'],\n        cmake_args = (\n          ['-DUSE_SYSTEM_BLOSC:BOOL=ON'] if int(os.environ.get('USE_SYSTEM_BLOSC', '0'))\n          else [\n           '-DUSE_SYSTEM_BLOSC:BOOL=OFF',\n           '-DDEACTIVATE_SSE2:BOOL=%s' % cmake_bool(('DISABLE_BLOSC_SSE2' in os.environ) or (cpu_info is None) or ('sse2' not in cpu_info['flags'])),\n           '-DDEACTIVATE_AVX2:BOOL=%s' % cmake_bool(('DISABLE_BLOSC_AVX2' in os.environ) or (cpu_info is None) or ('avx2' not in cpu_info['flags'])),\n           '-DDEACTIVATE_LZ4:BOOL=%s' % cmake_bool(not int(os.environ.get('INCLUDE_LZ4', '1'))),\n           # Snappy is disabled by default\n           '-DDEACTIVATE_SNAPPY:BOOL=%s' % cmake_bool(not int(os.environ.get('INCLUDE_SNAPPY', '0'))),\n           '-DDEACTIVATE_ZLIB:BOOL=%s' % cmake_bool(not int(os.environ.get('INCLUDE_ZLIB', '1'))),\n           '-DDEACTIVATE_ZSTD:BOOL=%s' % cmake_bool(not int(os.environ.get('INCLUDE_ZSTD', '1'))),\n           ]),\n        setup_requires=['scikit-build'],\n        tests_require=['numpy', 'psutil'],\n        packages = ['blosc'],\n        )\nelif __name__ == '__mp_main__':\n    # This occurs from `cpuinfo 4.0.0` using multiprocessing to interrogate the\n    # CPUID flags\n    # https://github.com/workhorsy/py-cpuinfo/issues/108\n    pass\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"scikit-build\", \"cmake\", \"ninja\", \"py-cpuinfo\"]\n"
  },
  "OpenBluetoothToolbox/SimpleBLE": {
    "setup.py": "import argparse\nimport os\nimport pathlib\nimport sys\n\nimport pybind11\nimport skbuild\n\n\ndef exclude_unnecessary_files(cmake_manifest):\n    def is_necessary(name):\n        is_necessary = (\n            name.endswith(\".so\")\n            or name.endswith(\".dylib\")\n            or name.endswith(\"py\")\n            or name.endswith(\"pyd\")\n        )\n        print(f\"Parsing file: {name} - {is_necessary}\")\n        return is_necessary\n\n    return list(filter(is_necessary, cmake_manifest))\n\n\nargparser = argparse.ArgumentParser(add_help=False)\nargparser.add_argument(\n    \"--plain\", help=\"Use Plain SimpleBLE\", required=False, action=\"store_true\"\n)\nargs, unknown = argparser.parse_known_args()\nsys.argv = [sys.argv[0]] + unknown\n\nroot = pathlib.Path(__file__).parent.resolve()\n\n# Generate the version string\n# TODO: Make the dev portion smarter by looking at tags.\nversion_str = (root / \"VERSION\").read_text(encoding=\"utf-8\").strip()\nversion_str += \".dev2\"  # ! Ensure it matches the intended release version!\n\n# Get the long description from the README file\nlong_description = (root / \"simplepyble\" / \"README.rst\").read_text(encoding=\"utf-8\")\n\ncmake_options = []\ncmake_options.append(f\"-Dpybind11_DIR={pybind11.get_cmake_dir()}\")\nif sys.platform == \"win32\":\n    cmake_options.append(\"-DCMAKE_SYSTEM_VERSION=10.0.19041.0\")\nelif sys.platform.startswith(\"darwin\"):\n    cmake_options.append(\"-DCMAKE_OSX_DEPLOYMENT_TARGET=10.15\")\ncmake_options.append(f\"-DPYTHON_EXECUTABLE={sys.executable}\")\ncmake_options.append(f\"-DSIMPLEPYBLE_VERSION={version_str}\")\n\nif args.plain:\n    cmake_options.append(\"-DSIMPLEBLE_PLAIN=ON\")\n\nif 'PIWHEELS_BUILD' in os.environ:\n    cmake_options.append(\"-DLIBFMT_VENDORIZE=OFF\")\n\n# The information here can also be placed in setup.cfg - better separation of\n# logic and declaration, and simpler if you include description/version in a file.\nskbuild.setup(\n    name=\"simplepyble\",\n    version=version_str,\n    author=\"Kevin Dewald\",\n    author_email=\"kevin@dewald.me\",\n    url=\"https://github.com/OpenBluetoothToolbox/SimpleBLE\",\n    description=\"The ultimate fully-fledged cross-platform BLE library, designed for simplicity and ease of use.\",\n    long_description=long_description,\n    long_description_content_type=\"text/x-rst\",\n    packages=[\"simplepyble\"],\n    package_dir={\"\": \"simplepyble/src\"},\n    cmake_source_dir=\"simplepyble\",\n    cmake_args=cmake_options,\n    cmake_process_manifest_hook=exclude_unnecessary_files,\n    cmake_install_dir=\"simplepyble/src/simplepyble\",\n    setup_requires=[\n        \"setuptools>=42\",\n        \"scikit-build\",\n        \"ninja; platform_system!='Windows'\",\n        \"cmake>=3.21\",\n        \"pybind11\",\n    ],\n    install_requires=[],\n    extras_require={},\n    platforms=\"Windows, macOS, Linux\",\n    python_requires=\">=3.7\",\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3 :: Only\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build\",\n    \"ninja; platform_system!='Windows'\",\n    \"cmake>=3.21\",\n    \"pybind11\",\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "DGtal-team/DGtal": {
    "wrap/deploy/setup.py": "# Generated using: python setup_py_configure.py 'dgtal'\n\nfrom __future__ import print_function\nfrom os import sys, path\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsys.path.append(path.dirname(path.dirname(path.abspath(__file__))))\nfrom dgtalVersion import get_versions\n\n# this_directory = path.abspath(path.dirname(__file__))\n# dgtal_readme_path = path.join(this_directory, 'DGtal-source', 'DGtal', 'README.md')\n# if path.exists(dgtal_readme_path):\n#     with open(dgtal_readme_path, encoding='utf-8') as f:\n#         long_description = f.read()\n# else:\n#     with open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n#         long_description = f.read()\n\nlong_description= r'DGtal is an open-source, cross-platform library providing ' \\\n                   'Digital Geometry Tools and Algorithms.'\nsetup(\n    name='dgtal',\n    version=get_versions()['package-version'],\n    author='Pablo Hernandez-Cerdan',\n    author_email='pablo.hernandez.cerdan@outlook.com',\n    packages=['dgtal'],\n    package_dir={'dgtal': 'dgtal'},\n    package_data={\n        'dgtal': ['tables/*.zlib']\n    },\n    cmake_source_dir='../..', # Top CMakeLists.txt directory\n    cmake_args=[\n        '-DCMAKE_BUILD_TYPE=Release',\n        '-DBUILD_SHARED_LIBS:BOOL=OFF',\n        '-DBUILD_EXAMPLES:BOOL=OFF',\n        '-DBUILD_TESTING:BOOL=OFF',\n        '-DDGTAL_WRAP_PYTHON:BOOL=ON'\n    ],\n    cmake_install_target=\"dgtal-install-runtime\",\n    py_modules=[\n        'dgtalVersion',\n    ],\n    download_url=r'https://github.com/DGtal-team/DGtal',\n    description=r'Digital Geometry Tools and Algorithm Library',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='LGPLv3',\n    keywords=r'DGtal image digital topology processing',\n    url=r'https://github.com/DGtal-team/DGtal',\n    install_requires=[\n    ]\n    )\n"
  },
  "rapidsai/rmm": {
    "python/setup.py": "# Copyright (c) 2019-2023, NVIDIA CORPORATION.\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\npackages = find_packages(include=[\"rmm*\"])\nsetup(\n    packages=packages,\n    package_data={key: [\"*.pxd\"] for key in packages},\n    zip_safe=False,\n)\n",
    "python/pyproject.toml": "# Copyright (c) 2021-2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nbuild-backend = \"setuptools.build_meta\"\nrequires = [\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"cuda-python>=11.7.1,<12.0\",\n    \"cython>=0.29,<0.30\",\n    \"ninja\",\n    \"scikit-build>=0.13.1,<0.17.2\",\n    \"setuptools>=61.0.0\",\n    \"tomli\",\n    \"wheel\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project]\nname = \"rmm\"\nversion = \"23.06.00\"\ndescription = \"rmm - RAPIDS Memory Manager\"\nreadme = { file = \"README.md\", content-type = \"text/markdown\" }\nauthors = [\n    { name = \"NVIDIA Corporation\" },\n]\nlicense = { text = \"Apache 2.0\" }\nrequires-python = \">=3.9\"\ndependencies = [\n    \"cuda-python>=11.7.1,<12.0\",\n    \"numba>=0.49\",\n    \"numpy>=1.19\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../dependencies.yaml and run `rapids-dependency-file-generator`.\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Topic :: Database\",\n    \"Topic :: Scientific/Engineering\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"pytest\",\n    \"pytest-cov\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project.urls]\nHomepage = \"https://github.com/rapidsai/rmm\"\n\n[tool.black]\nline-length = 79\ntarget-version = [\"py39\"]\ninclude = '\\.py?$'\nexclude = '''\n/(\n    thirdparty |\n    \\.eggs |\n    \\.git |\n    \\.hg |\n    \\.mypy_cache |\n    \\.tox |\n    \\.venv |\n    _build |\n    buck-out |\n    build |\n    dist\n)/\n'''\n\n[tool.isort]\nline_length = 79\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\ncombine_as_imports = true\norder_by_type = true\nknown_first_party = [\n    \"rmm\",\n]\ndefault_section = \"THIRDPARTY\"\nsections = [\n    \"FUTURE\",\n    \"STDLIB\",\n    \"THIRDPARTY\",\n    \"FIRSTPARTY\",\n    \"LOCALFOLDER\",\n]\nskip = [\n    \"thirdparty\",\n    \".eggs\",\n    \".git\",\n    \".hg\",\n    \".mypy_cache\",\n    \".tox\",\n    \".venv\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"__init__.py\",\n]\n\n[tool.setuptools]\nlicense-files = [\"LICENSE\"]\n"
  },
  "aewallin/opencamlib": {
    "setup.py": "from skbuild import setup\n\nsetup(\n  name='opencamlib',\n  packages=['opencamlib'],\n  package_dir={'opencamlib': 'src/pythonlib/opencamlib'},\n  include_package_data=True,\n  zip_safe=False,\n  python_requires='>=3.6',\n)\n",
    "pyproject.toml": "[project]\nname = \"opencamlib\"\nversion = \"2022.12.18\"\ndescription = \"open source computer aided manufacturing algorithms library\"\nreadme = \"README.rst\"\nauthors = [\n  { name = \"Anders Wallin\", email=\"anders.e.e.wallin@gmail.com\" }\n]\nmaintainers = [\n  { name = \"Koen Schmeets\", email=\"koen@schmeets.de\" }\n]\nlicense = { file = \"COPYING\" }\nrequires-python = \">=3.6\"\nkeywords = [\"cam\", \"cnc\", \"waterline\", \"axial tool projection\"]\n\nclassifiers = [\n  \"Development Status :: 4 - Beta\",\n  \"Environment :: Console\",\n  \"Programming Language :: Python :: 3 :: Only\",\n  \"Programming Language :: Python :: 3.7\",\n  \"Programming Language :: Python :: 3.8\",\n  \"Programming Language :: Python :: 3.9\",\n  \"Programming Language :: Python :: 3.10\",\n  \"Programming Language :: Python :: 3.11\",\n  \"Topic :: Scientific/Engineering :: Physics\",\n  \"Intended Audience :: Manufacturing\"\n]\n\n[project.urls]\nhomepage = \"https://github.com/aewallin/opencamlib\"\ndocumentation = \"https://github.com/aewallin/opencamlib\"\nrepository = \"https://github.com/aewallin/opencamlib\"\n\n[build-system]\nrequires = [\"scikit-build-core\"]\nbuild-backend = \"scikit_build_core.build\"\n\n[tool.scikit-build]\ncmake.verbose = true\nlogging.level = \"DEBUG\"\nwheel.packages = [\"src/pythonlib/opencamlib\"]\n\n[tool.scikit-build.cmake.define]\nBUILD_PY_LIB = \"ON\"\nBoost_ADDITIONAL_VERSIONS = \"1.80.0;1.79.0;1.78.0;1.77.0;1.76.0;1.75.0;1.74.0;1.73.0;1.72.0;1.71.0;1.70.0\"\nBUILD_DOC = \"OFF\"\n\n[tool.cibuildwheel]\nbuild = [\"cp37*\", \"cp38*\", \"cp39*\", \"cp310*\", \"cp311*\"]\nskip = [\"pp*\", \"*-musllinux*\", \"*-manylinux_i686\"]\n\n[tool.cibuildwheel.windows]\narchs = [\"AMD64\", \"x86\", \"ARM64\"]\nbefore-all = \"cd {package} && bash ./install.sh --install-ci-deps\"\nbefore-build = \"cd {package} && bash ./install.sh --install-boost --boost-with-python --python-executable python\"\n\n[tool.cibuildwheel.linux]\narchs = [\"x86_64\", \"aarch64\"]\nbefore-all = \"cd {package} && bash ./install.sh --install-ci-deps\"\nbefore-build = \"cd {package} && bash ./install.sh --install-boost --boost-with-python --python-executable python && cp --recursive --no-clobber boost_1_80_0 /host/home/runner/work/opencamlib/opencamlib\"\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"arm64\"]\nbefore-all = \"cd {package} && bash ./install.sh --install-ci-deps\"\nbefore-build = \"cd {package} && bash ./install.sh --install-boost --boost-with-python --python-executable python\"\nrepair-wheel-command = \"python src/pythonlib/delocate-wheel.py --require-archs {delocate_archs} -w {dest_dir} -v {wheel}\"\n",
    "setup.cfg": "[metadata]\nname = opencamlib\ndescription = open source computer aided manufacturing algorithms library\nauthor = Anders Wallin\nauthor_email = anders.e.e.wallin@gmail.com\nmaintainer = Koen Schmeets\nmaintainer_email = koen@schmeets.de\nlong_description_file = file: README.rst\nurl = https://github.com/aewallin/opencamlib\nclassifiers =\n    Development Status :: 4 - Beta\n    Environment :: Console\n    Programming Language :: Python :: 3 :: Only\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3.11\n    Topic :: Scientific/Engineering :: Physics\n    Intended Audience :: Manufacturing\nproject_urls =\n    homepage = https://github.com/aewallin/opencamlib\n    documentation = https://github.com/aewallin/opencamlib\n    repository = https://github.com/aewallin/opencamlib\n\n[options]\npackage_dir=\n    opencamlib=src/pythonlib/opencamlib\npackages = opencamlib\npython_requires = >=3.7\ninclude_package_data = True\nzip_safe = False\n"
  },
  "NERSC/timemory": {
    "setup.py": "#!/usr/bin/env python\n\nimport os\nimport sys\nimport argparse\nimport warnings\nimport platform\n\n\n# some Cray systems default to static libraries and the build\n# will fail because BUILD_SHARED_LIBS will get set to off\nif os.environ.get(\"CRAYPE_VERSION\") is not None:\n    os.environ[\"CRAYPE_LINK_TYPE\"] = \"dynamic\"\n\ncmake_args = [\n    \"-DPYTHON_EXECUTABLE:FILEPATH={}\".format(sys.executable),\n    \"-DPython3_EXECUTABLE:FILEPATH={}\".format(sys.executable),\n]\ncmake_options = []  # array of functors\nparser = argparse.ArgumentParser(add_help=False)\nparser.add_argument(\"-h\", \"--help\", help=\"Print help\", action=\"store_true\")\n\n# support CMAKE_ARGS environment variables because\n#  --install-option for pip is a pain to use\nenv_cmake_args = os.environ.get(\"CMAKE_ARGS\", None)\nif env_cmake_args is not None:\n    for _arg in env_cmake_args.split(\" \"):\n        if \"CMAKE_INSTALL_PREFIX\" not in _arg:\n            cmake_args += [_arg]\n\ngotcha_opt = False\nif platform.system() == \"Linux\":\n    gotcha_opt = True\n\n\ndef parse_requirements(fname=\"requirements.txt\"):\n    _req = []\n    requirements = []\n    # read in the initial set of requirements\n    with open(fname, \"r\") as fp:\n        _req = list(filter(bool, (line.strip() for line in fp)))\n    # look for entries which read other files\n    for itr in _req:\n        if itr.startswith(\"-r \"):\n            # read another file\n            for fitr in itr.split(\" \"):\n                if os.path.exists(fitr):\n                    requirements.extend(parse_requirements(fitr))\n        else:\n            # append package\n            requirements.append(itr)\n    # return the requirements\n    return requirements\n\n\ndef get_project_version():\n    # open \"VERSION\"\n    with open(os.path.join(os.getcwd(), \"VERSION\"), \"r\") as f:\n        data = f.read().replace(\"\\n\", \"\")\n    # make sure is string\n    if isinstance(data, list) or isinstance(data, tuple):\n        return data[0]\n    else:\n        return data\n\n\ndef get_long_description():\n    long_descript = \"\"\n    try:\n        long_descript = open(\"README.md\").read()\n    except Exception:\n        long_descript = \"\"\n    return long_descript\n\n\ndef __str2bool(v):\n    return v.lower() in (\"yes\", \"y\", \"true\", \"t\", \"1\", \"on\")\n\n\ndef get_bool_option(_args, _name, default=False):\n    _name = _name.replace(\"-\", \"_\")\n    _enable = getattr(_args, f\"enable_{_name}\")\n    _disable = getattr(_args, f\"disable_{_name}\")\n    _ret = default\n    if _enable:\n        _ret = True\n    if _disable:\n        _ret = False\n    return _ret\n\n\ndef set_cmake_bool_option(opt, enable_opt, disable_opt):\n    global cmake_args\n    try:\n        if enable_opt:\n            cmake_args.append(\"-D{}:BOOL={}\".format(opt, \"ON\"))\n        if disable_opt:\n            cmake_args.append(\"-D{}:BOOL={}\".format(opt, \"OFF\"))\n    except Exception as e:\n        print(\"Exception: {}\".format(e))\n\n\ndef add_arg_bool_option(\n    lc_name, disp_name, default=None, doc=\"\", disp_aliases=[]\n):\n    global parser\n    global cmake_options\n\n    # enable option\n    parser.add_argument(\n        \"--enable-{}\".format(lc_name),\n        action=\"store_true\",\n        default=(None if default is False else default),\n        help=\"Explicitly enable {} build. {}\".format(disp_name, doc),\n    )\n    # disable option\n    parser.add_argument(\n        \"--disable-{}\".format(lc_name),\n        action=\"store_true\",\n        default=None,\n        help=\"Explicitly disable {} build. {}\".format(disp_name, doc),\n    )\n\n    def _add_cmake_bool_option(_args):\n        _name = lc_name.replace(\"-\", \"_\")\n        _enable = getattr(_args, f\"enable_{_name}\")\n        _disable = getattr(_args, f\"disable_{_name}\")\n        # if default=False is passed in, set _disable to false\n        # only when neither --enable_{} and --disable_{} were not specified\n        if default is False and _enable is None and _disable is None:\n            _disable = True\n        for itr in [disp_name] + disp_aliases:\n            set_cmake_bool_option(itr, _enable, _disable)\n\n    cmake_options.append(_add_cmake_bool_option)\n\n\n# build variants\nadd_arg_bool_option(\n    \"require-packages\",\n    \"TIMEMORY_REQUIRE_PACKAGES\",\n    doc=(\n        \"Enables auto-detection of third-party packages\"\n        + \" and suppresses configuration failure\"\n        + \" when packages are not found\"\n    ),\n)\nadd_arg_bool_option(\"shared-libs\", \"BUILD_SHARED_LIBS\")\nadd_arg_bool_option(\"static-libs\", \"BUILD_STATIC_LIBS\")\nadd_arg_bool_option(\n    \"install-rpath-use-link-path\",\n    \"CMAKE_INSTALL_RPATH_USE_LINK_PATH\",\n    default=True,\n)\nadd_arg_bool_option(\"c\", \"TIMEMORY_BUILD_C\")\nadd_arg_bool_option(\n    \"python\",\n    \"TIMEMORY_USE_PYTHON\",\n    default=True,\n    doc=\"Build python bindings\",\n)\nadd_arg_bool_option(\"fortran\", \"TIMEMORY_BUILD_FORTRAN\")\nadd_arg_bool_option(\n    \"arch\", \"TIMEMORY_USE_ARCH\", doc=\"Compile everything for CPU arch\"\n)\nadd_arg_bool_option(\n    \"portable\",\n    \"TIMEMORY_BUILD_PORTABLE\",\n    doc=\"Disable CPU arch flags likely to cause portability issue\",\n)\nadd_arg_bool_option(\"ert\", \"TIMEMORY_BUILD_ERT\")\nadd_arg_bool_option(\n    \"skip-build\",\n    \"TIMEMORY_SKIP_BUILD\",\n    doc=\"Disable building any libraries\",\n)\nadd_arg_bool_option(\n    \"unity-build\",\n    \"TIMEMORY_UNITY_BUILD\",\n    doc=\"timemory-localized CMAKE_UNITY_BUILD\",\n)\nadd_arg_bool_option(\n    \"install-headers\",\n    \"TIMEMORY_INSTALL_HEADERS\",\n    doc=\"Install timemory headers\",\n)\nadd_arg_bool_option(\n    \"install-config\",\n    \"TIMEMORY_INSTALL_CONFIG\",\n    doc=\"Install cmake configuration\",\n)\nadd_arg_bool_option(\n    \"install-all\",\n    \"TIMEMORY_INSTALL_ALL\",\n    doc=\"install target depends on all target\",\n)\n# distributed memory parallelism\nadd_arg_bool_option(\"mpi\", \"TIMEMORY_USE_MPI\")\nadd_arg_bool_option(\"nccl\", \"TIMEMORY_USE_NCCL\")\nadd_arg_bool_option(\"upcxx\", \"TIMEMORY_USE_UPCXX\")\n# components\nadd_arg_bool_option(\"cuda\", \"TIMEMORY_USE_CUDA\")\nadd_arg_bool_option(\"cupti\", \"TIMEMORY_USE_CUPTI\")\nadd_arg_bool_option(\"hip\", \"TIMEMORY_USE_HIP\")\nadd_arg_bool_option(\"papi\", \"TIMEMORY_USE_PAPI\")\nadd_arg_bool_option(\"ompt\", \"TIMEMORY_USE_OMPT\")\nadd_arg_bool_option(\"gotcha\", \"TIMEMORY_USE_GOTCHA\", default=gotcha_opt)\nadd_arg_bool_option(\"caliper\", \"TIMEMORY_USE_CALIPER\")\nadd_arg_bool_option(\"likwid\", \"TIMEMORY_USE_LIKWID\")\nadd_arg_bool_option(\"perfetto\", \"TIMEMORY_USE_PERFETTO\")\nadd_arg_bool_option(\"gperftools\", \"TIMEMORY_USE_GPERFTOOLS\")\nadd_arg_bool_option(\"tau\", \"TIMEMORY_USE_TAU\")\nadd_arg_bool_option(\"vtune\", \"TIMEMORY_USE_VTUNE\")\n# submodules\nadd_arg_bool_option(\"build-caliper\", \"TIMEMORY_BUILD_CALIPER\")\nadd_arg_bool_option(\"build-gotcha\", \"TIMEMORY_BUILD_GOTCHA\")\nadd_arg_bool_option(\"build-dyninst\", \"TIMEMORY_BUILD_DYNINST\")\nadd_arg_bool_option(\n    \"build-dyninst-tpls\",\n    \"TIMEMORY_BUILD_DYNINST_TPLS\",\n    doc=\"Build third-party library dependencies for Dyninst\",\n)\nadd_arg_bool_option(\n    \"build-ert\",\n    \"TIMEMORY_BUILD_ERT\",\n    doc=\"Build/install empirical roofline toolkit tool\",\n)\nadd_arg_bool_option(\n    \"build-ompt\",\n    \"TIMEMORY_BUILD_OMPT\",\n    doc=\"Build/install OpenMP with OMPT support\",\n)\nadd_arg_bool_option(\n    \"build-python\",\n    \"TIMEMORY_BUILD_PYTHON\",\n    doc=\"Build bindings with internal pybind11\",\n)\n# tools\nadd_arg_bool_option(\"tools\", \"TIMEMORY_BUILD_TOOLS\", default=True)\nadd_arg_bool_option(\"timem\", \"TIMEMORY_BUILD_TIMEM\", doc=\"Build timem tool\")\nadd_arg_bool_option(\"jump\", \"TIMEMORY_BUILD_JUMP\", default=False)\nadd_arg_bool_option(\"stubs\", \"TIMEMORY_BUILD_STUBS\", default=False)\nadd_arg_bool_option(\n    \"avail\", \"TIMEMORY_BUILD_AVAIL\", doc=\"Build timemory-avail tool\"\n)\nadd_arg_bool_option(\n    \"dyninst\",\n    \"TIMEMORY_USE_DYNINST\",\n    disp_aliases=[\"TIMEMORY_BUILD_DYNINST_TOOLS\", \"TIMEMORY_BUILD_RUN\"],\n)\nadd_arg_bool_option(\n    \"compiler-instrumentation\",\n    \"TIMEMORY_BUILD_COMPILER_INSTRUMENTATION\",\n    default=False,\n)\nadd_arg_bool_option(\n    \"kokkos\",\n    \"TIMEMORY_BUILD_KOKKOS_TOOLS\",\n    doc=\"Build separate KokkosP libraries\",\n)\nadd_arg_bool_option(\n    \"kokkos-config\",\n    \"TIMEMORY_BUILD_KOKKOS_CONFIG\",\n    doc=\"Build array of dedicated KokkosP libraries\",\n)\nadd_arg_bool_option(\"mpip-library\", \"TIMEMORY_BUILD_MPIP_LIBRARY\")\nadd_arg_bool_option(\"ompt-library\", \"TIMEMORY_BUILD_OMPT_LIBRARY\")\nadd_arg_bool_option(\"ncclp-library\", \"TIMEMORY_BUILD_NCCLP_LIBRARY\")\nadd_arg_bool_option(\"mallocp-library\", \"TIMEMORY_BUILD_MALLOCP_LIBRARY\")\nadd_arg_bool_option(\"python-hatchet\", \"TIMEMORY_BUILD_PYTHON_HATCHET\")\nadd_arg_bool_option(\n    \"python-line-profiler\",\n    \"TIMEMORY_BUILD_PYTHON_LINE_PROFILER\",\n    doc=\"Build line_profiler with timemory backend\",\n)\n# miscellaneous\nadd_arg_bool_option(\"pybind-install\", \"PYBIND11_INSTALL\", default=False)\nadd_arg_bool_option(\"build-testing\", \"TIMEMORY_BUILD_TESTING\")\nparser.add_argument(\n    \"--cxx-standard\",\n    default=17,\n    type=int,\n    choices=[14, 17, 20],\n    help=\"Set C++ language standard\",\n)\nparser.add_argument(\n    \"--cmake-args\",\n    default=[],\n    type=str,\n    nargs=\"*\",\n    help=\"{}{}\".format(\n        \"Pass arguments to cmake. Use w/ pip installations and --install-option, e.g. \",\n        '--install-option=--cmake-args=\"-DTIMEMORY_BUILD_LTO=ON -DCMAKE_UNITY_BUILD=OFF\"',\n    ),\n)\nparser.add_argument(\n    \"--c-flags\",\n    default=None,\n    type=str,\n    nargs=\"*\",\n    help=\"Explicitly set CMAKE_C_FLAGS\",\n)\nparser.add_argument(\n    \"--cxx-flags\",\n    default=None,\n    type=str,\n    nargs=\"*\",\n    help=\"Explicitly set CMAKE_CXX_FLAGS\",\n)\nparser.add_argument(\n    \"--enable-develop\",\n    action=\"store_true\",\n    default=None,\n    help=\"Enable a development install (timemory headers, cmake config, etc.)\",\n)\nparser.add_argument(\n    \"--disable-develop\",\n    action=\"store_true\",\n    default=None,\n    help=\"Disable a development install (timemory headers, cmake config, etc.)\",\n)\nparser.add_argument(\n    \"--dist-info\",\n    action=\"store_true\",\n    default=None,\n    help=\"Generate dist-info (internal usage)\",\n)\n\nargs, left = parser.parse_known_args()\n# if help was requested, print these options and then add '--help' back\n# into arguments so that the skbuild/setuptools argparse catches it\nif args.help:\n    parser.print_help()\n    left.append(\"--help\")\nsys.argv = sys.argv[:1] + left\n\nif args.c_flags is not None:\n    cmake_args.append(\"-DCMAKE_C_FLAGS={}\".format(\" \".join(args.c_flags)))\n\nif args.cxx_flags is not None:\n    cmake_args.append(\"-DCMAKE_CXX_FLAGS='{}'\".format(\" \".join(args.cxx_flags)))\n\nif args.enable_develop:\n    for itr in [\"install_headers\", \"install_config\"]:\n        setattr(args, f\"enable_{itr}\", True)\n\nif args.disable_develop:\n    for itr in [\"install_headers\", \"install_config\"]:\n        setattr(args, f\"disable_{itr}\", True)\n\n# loop over the functors\nfor itr in cmake_options:\n    itr(args)\n\nruntime_req_file = (\n    \".requirements/mpi_runtime.txt\"\n    if args.enable_mpi and not args.disable_mpi\n    else \".requirements/runtime.txt\"\n)\n\ncmake_args.append(\"-DCMAKE_CXX_STANDARD={}\".format(args.cxx_standard))\n\nfor itr in args.cmake_args:\n    cmake_args += itr.split()\n\nif platform.system() == \"Darwin\":\n    # scikit-build will set this to 10.6 and C++ compiler check will fail\n    version = platform.mac_ver()[0].split(\".\")\n    version = \".\".join([version[0], version[1]])\n    cmake_args += [\"-DCMAKE_OSX_DEPLOYMENT_TARGET={}\".format(version)]\n\n# DO THIS LAST!\n# support TIMEMORY_SETUP_ARGS environment variables because\n#  --install-option for pip is a pain to use\n# Env variables should be space-delimited set of cmake arguments, e.g.:\n#   export TIMEMORY_SETUP_ARGS=\"-DTIMEMORY_USE_MPI=ON -DTIMEMORY_USE_OMPT=OFF\"\nenv_cmake_args = os.environ.get(\"TIMEMORY_SETUP_ARGS\", None)\nif env_cmake_args is not None:\n    cmake_args += env_cmake_args.split(\" \")\n\n\ndef _generate_dist_info():\n    from setuptools import setup\n\n    # suppress:\n    #  \"setuptools_scm/git.py:68: UserWarning: \"/.../<PACKAGE>\"\n    #       is shallow and may cause errors\"\n    # since 'error' in output causes CDash to interpret warning as error\n    with warnings.catch_warnings():\n        setup(\n            name=\"timemory\",\n            packages=[\"timemory\"],\n            version=get_project_version(),\n            long_description=get_long_description(),\n            long_description_content_type=\"text/markdown\",\n            install_requires=parse_requirements(runtime_req_file),\n            extras_require={\n                \"all\": parse_requirements(\"requirements.txt\")\n                + parse_requirements(\".requirements/mpi_runtime.txt\"),\n                \"mpi\": parse_requirements(\".requirements/mpi_runtime.txt\"),\n                \"build\": parse_requirements(\".requirements/build.txt\"),\n            },\n            python_requires=\">=3.6\",\n            entry_points={\n                \"console_scripts\": [\n                    \"timemory-plotter=timemory.plotting.__main__:try_plot\",\n                    \"timemory-roofline=timemory.roofline.__main__:try_plot\",\n                    \"timemory-analyze=timemory.analyze.__main__:try_analyze\",\n                    \"timemory-python-line-profiler=timemory.line_profiler.__main__:main\",\n                    \"timemory-python-profiler=timemory.profiler.__main__:main\",\n                    \"timemory-python-trace=timemory.trace.__main__:main\",\n                ],\n            },\n        )\n\n\n_use_skbuild = True\n_dist_info_only = os.environ.get(\"TIMEMORY_DIST_INFO\", None)\nif args.dist_info or (\n    _dist_info_only is not None and __str2bool(_dist_info_only)\n):\n    _use_skbuild = False\n\nif _use_skbuild:\n    try:\n        from skbuild import setup\n        from skbuild.command.install import install as skinstall\n    except (ImportError, ModuleNotFoundError) as e:\n        sys.stderr.write(\n            \"{} {}\".format(\n                \"Warning! timemory requires scikit-build for full installation.\",\n                \"Generating dist-info only...\\n\",\n            )\n        )\n        sys.stderr.write(f\"{e}\\n\")\n        sys.stderr.flush()\n        _use_skbuild = False\n\nif _use_skbuild:\n\n    class custom_install(skinstall):\n        \"\"\"Custom installation\"\"\"\n\n        def __init__(self, *args, **kwargs):\n            skinstall.__init__(self, *args, **kwargs)\n\n        def run(self):\n            print(\"\\n\\n\\t[timemory] Running install...\")\n            print(\"\\t\\t {:10} : {}\".format(\"base\", self.install_base))\n            print(\"\\t\\t {:10} : {}\".format(\"purelib\", self.install_purelib))\n            print(\"\\t\\t {:10} : {}\".format(\"platlib\", self.install_platlib))\n            print(\"\\t\\t {:10} : {}\".format(\"headers\", self.install_headers))\n            print(\"\\t\\t {:10} : {}\".format(\"lib\", self.install_lib))\n            print(\"\\t\\t {:10} : {}\".format(\"scripts\", self.install_scripts))\n            print(\"\\t\\t {:10} : {}\".format(\"data\", self.install_data))\n            print(\"\\t\\t {:10} : {}\".format(\"userbase\", self.install_userbase))\n            print(\"\\t\\t {:10} : {}\".format(\"usersite\", self.install_usersite))\n            print(\"\\n\\n\")\n            skinstall.run(self)\n            for itr in self.get_outputs():\n                print('[timemory] installed file : \"{}\"'.format(itr))\n\n    def exclude_install_hook(cmake_manifest):\n        def _filter_manifest(_manifest, *args):\n            for itr in args:\n                _manifest = list(\n                    filter(\n                        lambda name: itr not in name,\n                        cmake_manifest,\n                    )\n                )\n            return _manifest\n\n        cmake_manifest = _filter_manifest(\n            cmake_manifest,\n            \"pytest.ini\",\n            os.path.join(\"hatchet\", \"tests\", \"timemory_test.py\"),\n        )\n        if not get_bool_option(args, \"develop\"):\n            cmake_manifest = list(\n                filter(lambda name: not (name.endswith(\".a\")), cmake_manifest)\n            )\n            if not get_bool_option(args, \"install-config\"):\n                cmake_manifest = _filter_manifest(\n                    cmake_manifest,\n                    os.path.join(\"share\", \"cmake\"),\n                    os.path.join(\"lib\", \"cmake\"),\n                )\n            if not get_bool_option(args, \"install-headers\"):\n                cmake_manifest = _filter_manifest(cmake_manifest, \"include\")\n\n        return cmake_manifest\n\n    # suppress:\n    #  \"setuptools_scm/git.py:68: UserWarning: \"/.../<PACKAGE>\"\n    #       is shallow and may cause errors\"\n    # since 'error' in output causes CDash to interpret warning as error\n    with warnings.catch_warnings():\n        print(\"CMake arguments: {}\".format(\" \".join(cmake_args)))\n        setup(\n            name=\"timemory\",\n            packages=[\"timemory\"],\n            version=get_project_version(),\n            cmake_args=cmake_args,\n            cmake_languages=(\"C\", \"CXX\"),\n            long_description=get_long_description(),\n            long_description_content_type=\"text/markdown\",\n            install_requires=parse_requirements(runtime_req_file),\n            extras_require={\n                \"all\": parse_requirements(\"requirements.txt\")\n                + parse_requirements(\".requirements/mpi_runtime.txt\"),\n                \"mpi\": parse_requirements(\".requirements/mpi_runtime.txt\"),\n                \"build\": parse_requirements(\".requirements/build.txt\"),\n            },\n            python_requires=\">=3.6\",\n            cmdclass=dict(install=custom_install),\n            cmake_process_manifest_hook=exclude_install_hook,\n            entry_points={\n                \"console_scripts\": [\n                    \"timemory-plotter=timemory.plotting.__main__:try_plot\",\n                    \"timemory-roofline=timemory.roofline.__main__:try_plot\",\n                    \"timemory-analyze=timemory.analyze.__main__:try_analyze\",\n                    \"timemory-python-line-profiler=timemory.line_profiler.__main__:main\",\n                    \"timemory-python-profiler=timemory.profiler.__main__:main\",\n                    \"timemory-python-trace=timemory.trace.__main__:main\",\n                ],\n            },\n        )\n\nelse:\n    _generate_dist_info()\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools >= 40.0.4\",\n    \"setuptools_scm >= 2.0.0\",\n    \"wheel >= 0.29.0\",\n    \"scikit-build >= 0.8.0\",\n    \"cython\",\n]\nbuild-backend = 'setuptools.build_meta'\n\n[tool.black]\nline-length = 80\ntarget-version = ['py37']\ninclude = '\\.pyi?'\nexclude = '''\n\n(\n  /(\n      \\.eggs         # exclude a few common directories in the\n    | \\.git          # root of the project\n    | \\.hg\n    | \\.mypy_cache\n    | \\.tox\n    | \\.venv\n    | \\.misc\n    | _build\n    | __pycache__\n    | _skbuild\n    | build\n    | build-timemory\n    | dist\n    | external\n    | scripts\n    | spack\n    | docker\n    | docs\n    | hatchet\n    | .pytest_cache\n  )/\n  | cmake/Templates/console-script.py.in\n)\n'''\n",
    "setup.cfg": "[metadata]\nname = timemory\nurl = http://timemory.readthedocs.io\ndownload_url = http://github.com/NERSC/timemory.git\nauthor = Jonathan R. Madsen\nauthor_email = jrmadsen@lbl.gov\nmaintainer = Jonathan R. Madsen\nmaintainer_email = jrmadsen@lbl.gov\nlicense = MIT\ndescription = Suite of performance analysis tools and toolkit for building performance analysis tools\nkeywords =\n    performance\n    profiling\n    sampling\n    hardware counters\n    pybind11\n    timing\n    memory\n    gpu\n    cupti\n    cuda\n    papi\n    gperftools\n    craypat\n    ompt\n    likwid\n    roofline\n    TAU\n    vtune\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Environment :: GPU\n    Environment :: GPU :: NVIDIA CUDA\n    Intended Audience :: Developers\n    Intended Audience :: Science/Research\n    Natural Language :: English\n    License :: OSI Approved :: MIT License\n    Operating System :: MacOS\n    Operating System :: Microsoft :: Windows :: Windows 10\n    Operating System :: POSIX :: Linux\n    Operating System :: POSIX :: BSD\n    Operating System :: Unix\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Topic :: Software Development :: Bug Tracking\n    Topic :: Software Development :: Testing\n    Topic :: Software Development :: Quality Assurance\n    Topic :: Software Development :: Libraries :: Python Modules\n    Topic :: System :: Logging\n    Topic :: System :: Monitoring\n    Topic :: Utilities\n\n[options]\npackages = timemory\nzip_safe = false\ninclude_package_data = false\n\n[flake8]\nignore =\n    F403,\n    F405,\n    W503,\n    E203,\n    N801,\n    N802,\n    N804,\n    N806,\n    N812,\nexclude =\n    .git,\n    __pycache__,\n    docs,\n    old,\n    build,\n    dist,\n    pybind11,\n    _skbuild,\n    external,\n    build-*,\n    scripts,\n    .misc,\n    pyctest-runner.py,\n    spack,\nmax-complexity = 40\nmax-line-length = 90\n"
  },
  "NGSolve/ngsolve": {
    "setup.py": "import glob\nimport os\nimport sys\nimport netgen.version\nimport site\n\nfrom skbuild import setup\nimport skbuild.cmaker\nfrom subprocess import check_output\nfrom distutils.sysconfig import get_python_lib\nimport pkg_resources\n\nsetup_requires = []\n\ndef install_filter(cmake_manifest):\n    return cmake_manifest\n\ndef _patched_parse_manifests(self):\n    paths = \\\n        glob.glob(os.path.join(skbuild.cmaker.CMAKE_BUILD_DIR(), \"ngsolve\", \"install_manifest*.txt\"))\n    try:\n        return [self._parse_manifest(path) for path in paths][0]\n    except IndexError:\n        return []\n   \n# we are using the ngsolve superbuild (to download and build some dependencies)\n# patch the parse_manifests function to point to the actual ngsolve cmake project within the superbuild\nskbuild.cmaker.CMaker._parse_manifests = _patched_parse_manifests\n\nversion = check_output([sys.executable,'tests/get_python_version_string_from_git.py'], cwd='.').decode('utf-8').strip()\n\npy_install_dir = get_python_lib(1,0,'').replace('\\\\','/')\n\nnetgen_name = netgen.config.NETGEN_PYTHON_PACKAGE_NAME\nname = netgen_name.replace(\"netgen-mesher\", \"ngsolve\") # keep -avx2 suffix\n\nnetgen_version = netgen.config.NETGEN_VERSION_PYTHON\nroot_dir = os.path.abspath(os.path.join(netgen.__file__, '../'*(len(py_install_dir.split('/'))+2)))\n\nif netgen.config.NG_INSTALL_DIR_CMAKE.startswith('netgen'):\n    netgen_dir = os.path.abspath(os.path.join(os.path.dirname(netgen.__file__), 'cmake'))\nelse:\n    netgen_dir = root_dir\n\ninstall_requires = [\n        f'{netgen_name} == {netgen_version}',\n    ]\n\nuse_umfpack = 'ON' if 'darwin' in sys.platform else 'OFF'\n\n_cmake_args = [\n    f'-DNETGEN_DIR={netgen_dir}',\n    '-DUSE_SUPERBUILD:BOOL=ON',\n    '-DCMAKE_BUILD_TYPE=Release',\n    '-DBUILD_FOR_CONDA=ON',\n    '-DBUILD_STUB_FILES=OFF',\n    f'-DUSE_UMFPACK={use_umfpack}',\n    f'-DNGSOLVE_VERSION_PYTHON={version}',\n]\n\nif 'NETGEN_CCACHE' in os.environ:\n  _cmake_args += ['-DUSE_CCACHE=ON']\n\npackages=['netgen', 'ngsolve']\n\nif 'darwin' in sys.platform:\n    pass\nelif 'linux' in sys.platform:\n    _cmake_args += [\n        '-DUSE_MKL:BOOL=ON',\n        f'-DMKL_ROOT:PATH={root_dir}',\n        f'-DMKL_LIBRARY:PATH={root_dir}/lib/libmkl_rt.so.2',\n        f'-DMKL_INCLUDE_DIR:PATH={root_dir}/include',\n        '-DUSE_CUDA=ON',\n        '-DCMAKE_CUDA_ARCHITECTURES=all',\n    ]\n    install_requires.append('mkl')\n    packages = []\nelif 'win' in sys.platform:\n    _cmake_args += [\n        '-DUSE_MKL:BOOL=ON',\n        f'-DMKL_ROOT:PATH={root_dir}',\n        f'-DMKL_LIBRARY:PATH={root_dir}/Library/lib/mkl_rt.lib',\n        f'-DMKL_INCLUDE_DIR:PATH={root_dir}/Library/include',\n        f'-DNGSOLVE_INSTALL_DIR_TCL:PATH=Scripts',\n    ]\n    install_requires.append('mkl')\n\nif 'PYDIR' in os.environ:\n    _cmake_args += [f'-DCMAKE_PREFIX_PATH={os.environ[\"PYDIR\"]}']\n\nsetup(\n    name=name,\n    version=version,\n    description=\"NGSolve\",\n    author='The NGSolve team',\n    license=\"LGPL2.1\",\n    packages=packages,\n    # package_dir={'ngsolve': 'python'},\n    install_requires=install_requires,\n    tests_require=['pytest','scipy','numpy'],\n    # include_package_data=True,\n    cmake_process_manifest_hook=install_filter,\n    cmake_args=_cmake_args,\n    setup_requires=setup_requires\n)\n"
  },
  "OpenChemistry/avogadrolibs": {
    "setup.py": "import os\n\nfrom skbuild import setup\n\n\ndef extra_cmake_args():\n    # FIXME: this doesn't seem to work if we supply more than one argument.\n    # I really am not sure why.\n    env = os.getenv('EXTRA_CMAKE_ARGS')\n    return env.split(';') if env else []\n\n\ndef wheel_args():\n    # Check if we are building wheels...\n    env = os.getenv('GITHUB_WORKFLOW')\n    args = [\n      '-DPYTHON_WHEEL_BUILD:BOOL=TRUE',\n    ]\n    return args if env == 'Build Wheels' else []\n\n\ncmake_args = [\n    '-DUSE_SPGLIB:BOOL=FALSE',\n    '-DUSE_OPENGL:BOOL=FALSE',\n    '-DUSE_QT:BOOL=FALSE',\n    '-DUSE_MMTF:BOOL=FALSE',\n    '-DUSE_PYTHON:BOOL=TRUE',\n    '-DUSE_HDF5:BOOL=FALSE',\n    '-DUSE_LIBARCHIVE:BOOL=FALSE',\n    '-DUSE_LIBMSYM:BOOL=FALSE',\n    '-DINSTALL_RUNTIME_DIR:PATH=avogadro',\n    '-DINSTALL_LIBRARY_DIR:PATH=avogadro',\n    '-DINSTALL_ARCHIVE_DIR:PATH=avogadro',\n] + extra_cmake_args() + wheel_args()\n\n# Add pybind11 if it is installed\ntry:\n    from pybind11 import get_cmake_dir\nexcept ImportError:\n    pass\nelse:\n    cmake_args.append('-Dpybind11_DIR:PATH=' + get_cmake_dir())\n\nwith open('README.md') as f:\n    long_description = f.read()\n\nsetup(\n    name='avogadro',\n    use_scm_version=True,\n    setup_requires=['setuptools_scm'],\n    description='Avogadro provides analysis and data processing useful in computational chemistry, molecular modeling, bioinformatics, materials science, and related areas.',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author='Avogadro / OpenChemistry Developers',\n    license='BSD',\n    url='https://github.com/OpenChemistry/avogadrolibs',\n    project_urls={\n        'Documentation': 'https://two.avogadro.cc',\n        'Funding': 'https://github.com/sponsors/OpenChemistry',\n        'Source': 'https://github.com/OpenChemistry/avogadrolibs',\n        'Tracker': 'https://github.com/OpenChemistry/avogadrolibs/issues',\n        'Forum': 'https://discuss.avogadro.cc'\n    },\n    classifiers=[\n        'License :: OSI Approved :: BSD License',\n        'Programming Language :: Python',\n        'Programming Language :: C++',\n        'Development Status :: 4 - Beta',\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Education',\n        'Intended Audience :: Science/Research',\n        'Topic :: Scientific/Engineering',\n        'Topic :: Scientific/Engineering :: Chemistry',\n        'Topic :: Scientific/Engineering :: Physics',\n        'Topic :: Scientific/Engineering :: Visualization',\n        'Topic :: Scientific/Engineering :: Information Analysis',\n        'Topic :: Software Development :: Libraries',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: Unix',\n        'Operating System :: MacOS'\n        ],\n    packages=['avogadro'],\n    cmake_args=cmake_args,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=40.8.0\", \"wheel\", \"scikit-build\", \"pybind11\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta:__legacy__\"\n[tool.cibuildwheel]\nbuild-verbosity = \"1\"\n"
  },
  "daanzu/kaldi-active-grammar": {
    "setup.py": "\"\"\"A setuptools based setup module.\n\nSee:\nhttps://packaging.python.org/guides/distributing-packages-using-setuptools/\nhttps://github.com/pypa/sampleproject\n\"\"\"\n\n# Always prefer setuptools over distutils\nfrom setuptools import find_packages\nimport os, re, datetime\n# io.open is needed for projects that support Python 2.7\n# It ensures open() defaults to text mode with universal newlines,\n# and accepts an argument to specify the text encoding\n# Python 3 only projects can skip this import\nfrom io import open\n\nif os.environ.get('KALDIAG_SETUP_RAW'):\n    from setuptools import setup\n    import site, sys\n    site.ENABLE_USER_SITE = (\"--user\" in sys.argv[1:])  # Fix pip https://github.com/pypa/pip/issues/7953\nelse:\n    from skbuild import setup\n\n\n# Force wheel to be platform specific\n# https://stackoverflow.com/questions/45150304/how-to-force-a-python-wheel-to-be-platform-specific-when-building-it\n# https://github.com/Yelp/dumb-init/blob/48db0c0d0ecb4598d1a6400710445b85d67616bf/setup.py#L11-L27\n# https://github.com/google/or-tools/issues/616#issuecomment-371480314\ntry:\n    from wheel.bdist_wheel import bdist_wheel as bdist_wheel\n    class bdist_wheel_impure(bdist_wheel):\n\n        def finalize_options(self):\n            bdist_wheel.finalize_options(self)\n            # Mark us as not a pure python package\n            self.root_is_pure = False\n\n        def get_tag(self):\n            python, abi, plat = bdist_wheel.get_tag(self)\n            # We don't contain any python source\n            python, abi = 'py2.py3', 'none'\n            return python, abi, plat\n\n    from setuptools.command.install import install\n    class install_platlib(install):\n        def finalize_options(self):\n            install.finalize_options(self)\n            self.install_lib = self.install_platlib\n\nexcept ImportError:\n    bdist_wheel_impure = None\n    install_platlib = None\n\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n# https://packaging.python.org/guides/single-sourcing-package-version/\ndef read(*parts):\n    with open(os.path.join(here, *parts), 'r') as fp:\n        return fp.read()\n\ndef find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\nversion = find_version('kaldi_active_grammar', '__init__.py')\nif version.endswith('dev0'):\n    version = version[:-1] + datetime.datetime.now().strftime('%Y%m%d%H%M%S')\n\n# Set branch for Kaldi source repository (maybe we should use commits instead?)\nif not os.environ.get('KALDI_BRANCH'):\n    os.environ['KALDI_BRANCH'] = ('kag-v' + version) if ('dev' not in version) else 'origin/master'\n\n# Get the long description from the README file\nwith open(os.path.join(here, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\n\n# Arguments marked as \"Required\" below must be included for upload to PyPI.\n# Fields marked as \"Optional\" may be commented out.\n\nsetup(\n    cmdclass={\n        'bdist_wheel': bdist_wheel_impure,\n        'install': install_platlib,\n    },\n\n    # This is the name of your project. The first time you publish this\n    # package, this name will be registered for you. It will determine how\n    # users can install this project, e.g.:\n    #\n    # $ pip install sampleproject\n    #\n    # And where it will live on PyPI: https://pypi.org/project/sampleproject/\n    #\n    # There are some restrictions on what makes a valid project name\n    # specification here:\n    # https://packaging.python.org/specifications/core-metadata/#name\n    name='kaldi-active-grammar',  # Required\n\n    # Versions should comply with PEP 440:\n    # https://www.python.org/dev/peps/pep-0440/\n    #\n    # For a discussion on single-sourcing the version across setup.py and the\n    # project code, see\n    # https://packaging.python.org/en/latest/single_source_version.html\n    # version='0.2.0',  # Required\n    # version=open('VERSION').read().strip(),\n    version=version,\n\n    # This is a one-line description or tagline of what your project does. This\n    # corresponds to the \"Summary\" metadata field:\n    # https://packaging.python.org/specifications/core-metadata/#summary\n    description='Kaldi speech recognition with grammars that can be set active/inactive dynamically at decode-time',  # Optional\n\n    # This is an optional longer description of your project that represents\n    # the body of text which users will see when they visit PyPI.\n    #\n    # Often, this is the same as your README, so you can just read it in from\n    # that file directly (as we have already done above)\n    #\n    # This field corresponds to the \"Description\" metadata field:\n    # https://packaging.python.org/specifications/core-metadata/#description-optional\n    long_description=long_description,  # Optional\n\n    # Denotes that our long_description is in Markdown; valid values are\n    # text/plain, text/x-rst, and text/markdown\n    #\n    # Optional if long_description is written in reStructuredText (rst) but\n    # required for plain-text or Markdown; if unspecified, \"applications should\n    # attempt to render [the long_description] as text/x-rst; charset=UTF-8 and\n    # fall back to text/plain if it is not valid rst\" (see link below)\n    #\n    # This field corresponds to the \"Description-Content-Type\" metadata field:\n    # https://packaging.python.org/specifications/core-metadata/#description-content-type-optional\n    long_description_content_type='text/markdown',  # Optional (see note above)\n\n    # This should be a valid link to your project's main homepage.\n    #\n    # This field corresponds to the \"Home-Page\" metadata field:\n    # https://packaging.python.org/specifications/core-metadata/#home-page-optional\n    url='https://github.com/daanzu/kaldi-active-grammar',  # Optional\n\n    # This should be your name or the name of the organization which owns the\n    # project.\n    author='David Zurow',  # Optional\n\n    # This should be a valid email address corresponding to the author listed\n    # above.\n    author_email='daanzu@gmail.com',  # Optional\n\n    license='AGPL-3.0',\n\n    # Classifiers help users find your project by categorizing it.\n    #\n    # For a list of valid classifiers, see https://pypi.org/classifiers/\n    classifiers=[  # Optional\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        'Development Status :: 5 - Production/Stable',\n\n        # Indicate who your project is intended for\n        'Intended Audience :: Developers',\n        # 'Topic :: Software Development :: Build Tools',\n\n        # Pick your license as you wish\n        'License :: OSI Approved :: GNU Affero General Public License v3',\n\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n        # These classifiers are *not* checked by 'pip install'. See instead\n        # 'python_requires' below.\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n    ],\n\n    # This field adds keywords for your project which will appear on the\n    # project page. What does your project relate to?\n    #\n    # Note that this is a string of words separated by whitespace, not a list.\n    keywords='kaldi speech recognition grammar dragonfly',  # Optional\n\n    # You can just specify package directories manually here if your project is\n    # simple. Or you can use find_packages().\n    #\n    # Alternatively, if you just want to distribute a single Python file, use\n    # the `py_modules` argument instead as follows, which will expect a file\n    # called `my_module.py` to exist:\n    #\n    #   py_modules=[\"my_module\"],\n    #\n    packages=find_packages(exclude=['contrib', 'docs', 'tests']),  # Required\n\n    # Specify which Python versions you support. In contrast to the\n    # 'Programming Language' classifiers above, 'pip install' will check this\n    # and refuse to install the project if the version does not match. If you\n    # do not support Python 2, you can simplify this to '>=3.5' or similar, see\n    # https://packaging.python.org/guides/distributing-packages-using-setuptools/#python-requires\n    python_requires='>=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, <4',\n\n    # This field lists other packages that your project depends on to run.\n    # Any package you put here will be installed by pip when your project is\n    # installed, so they must be valid existing projects.\n    #\n    # For an analysis of \"install_requires\" vs pip's requirements files see:\n    # https://packaging.python.org/en/latest/requirements.html\n    install_requires=[\n        'cffi ~= 1.12',\n        'numpy ~= 1.16, != 1.19.4',\n        'ush ~= 3.1',\n        'six',\n        'futures; python_version == \"2.7\"',\n    ],  # Optional\n\n    # List additional groups of dependencies here (e.g. development\n    # dependencies). Users will be able to install these using the \"extras\"\n    # syntax, for example:\n    #\n    #   $ pip install sampleproject[dev]\n    #\n    # Similar to `install_requires` above, these must be valid existing\n    # projects.\n    extras_require={  # Optional\n        'g2p_en': ['g2p_en ~= 2.1.0'],\n        'online': ['requests ~= 2.18'],\n        # 'dev': ['check-manifest'],\n        # 'test': ['coverage'],\n    },\n\n    # package_dir={\n    #     'kaldi_active_grammar': 'package'\n    # },\n\n    # If there are data files included in your packages that need to be\n    # installed, specify them here.\n    #\n    # If using Python 2.6 or earlier, then these have to be included in\n    # MANIFEST.in as well.\n    package_data={  # Optional\n        # 'kaldi_active_grammar': ['exec/windows/*'],\n        'kaldi_active_grammar': ['exec/*/*'],\n        '': ['LICENSE.txt'],\n    },\n\n    # Although 'package_data' is the preferred approach, in some case you may\n    # need to place data files outside of your packages. See:\n    # http://docs.python.org/3.4/distutils/setupscript.html#installing-additional-files\n    #\n    # In this case, 'data_file' will be installed into '<sys.prefix>/my_data'\n    # data_files=[('my_data', ['data/data_file'])],  # Optional\n    # data_files=[('my_data', ['exec/windows/dragonfly.dll'])],  # Optional\n    # data_files=[('', ['LICENSE.txt'])],\n\n    # To provide executable scripts, use entry points in preference to the\n    # \"scripts\" keyword. Entry points provide cross-platform support and allow\n    # `pip` to create the appropriate form of executable for the target\n    # platform.\n    #\n    # For example, the following would provide a command called `sample` which\n    # executes the function `main` from this package when invoked:\n    # entry_points={  # Optional\n    #     'console_scripts': [\n    #         'sample=sample:main',\n    #     ],\n    # },\n\n    # List additional URLs that are relevant to your project as a dict.\n    #\n    # This field corresponds to the \"Project-URL\" metadata fields:\n    # https://packaging.python.org/specifications/core-metadata/#project-url-multiple-use\n    #\n    # Examples listed include a pattern for specifying where the package tracks\n    # issues, where the source is hosted, where to say thanks to the package\n    # maintainers, and where to support the project financially. The key is\n    # what's used to render the link text on PyPI.\n    project_urls={  # Optional\n        'Bug Reports': 'https://github.com/daanzu/kaldi-active-grammar/issues',\n        'Funding': 'https://github.com/sponsors/daanzu',\n        # 'Say Thanks!': 'http://saythanks.io/to/example',\n        'Source': 'https://github.com/daanzu/kaldi-active-grammar/',\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n",
    "setup.cfg": "[metadata]\n# This includes the license file(s) in the wheel.\n# https://wheel.readthedocs.io/en/stable/user_guide.html#including-license-files-in-the-generated-wheel-file\nlicense_files = LICENSE.txt\n\n[bdist_wheel]\n# This flag says to generate wheels that support both Python 2 and Python\n# 3. If your code will not run unchanged on both Python 2 and 3, you will\n# need to generate separate wheels for each Python version that you\n# support. Removing this line (or setting universal to 0) will prevent\n# bdist_wheel from trying to make a universal wheel. For more see:\n# https://packaging.python.org/guides/distributing-packages-using-setuptools/#wheels\n# universal=1\n"
  },
  "DigitalSlideArchive/HistomicsTK": {
    "setup.py": "#! /usr/bin/env python\n\nimport importlib\nimport os\nimport sys\n\nfrom setuptools import find_packages\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    sys.stderr.write(\"\"\"scikit-build is required to build from source or run tox.\nPlease run:\n  python -m pip install scikit-build\n\"\"\")\n    # from setuptools import setup\n    sys.exit(1)\n\n\nwith open('README.rst') as readme_file:\n    readme = readme_file.read()\n\n\ndef prerelease_local_scheme(version):\n    \"\"\"\n    Return local scheme version unless building on master in CircleCI.\n\n    This function returns the local scheme version number\n    (e.g. 0.0.0.dev<N>+g<HASH>) unless building on CircleCI for a\n    pre-release in which case it ignores the hash and produces a\n    PEP440 compliant pre-release version number (e.g. 0.0.0.dev<N>).\n    \"\"\"\n    from setuptools_scm.version import get_local_node_and_date\n\n    if os.getenv('CIRCLE_BRANCH') in {'master'}:\n        return ''\n    else:\n        return get_local_node_and_date(version)\n\n\nsetup(\n    name='histomicstk',\n    use_scm_version={'local_scheme': prerelease_local_scheme,\n                     'fallback_version': '0.0.0'},\n    description='A Python toolkit for Histopathology Image Analysis',\n    long_description=readme,\n    long_description_content_type='text/x-rst',\n    author='Kitware, Inc.',\n    author_email='developers@digitalslidearchive.net',\n    url='https://github.com/DigitalSlideArchive/HistomicsTK',\n    packages=find_packages(exclude=['tests', '*_test']),\n    package_dir={\n        'histomicstk': 'histomicstk',\n    },\n    include_package_data=True,\n    install_requires=[\n        'girder-client',\n        # scientific packages\n        'nimfa',\n        'numpy',\n        'scipy',\n        'Pillow',\n        'pandas',\n        'scikit-image',\n        'scikit-learn',\n        'imageio',\n        'shapely[vectorized]',\n        'sqlalchemy ; python_version >= \"3.8\"',\n        'sqlalchemy<2 ; python_version < \"3.8\"',\n        'matplotlib',\n        'pyvips',\n        # dask packages\n        'dask[dataframe]',\n        'distributed',\n        # large image; for non-linux systems only install the PIL tile source\n        # by default.\n        'large-image[sources];sys.platform==\"linux\"',\n        'large-image[sources];sys.platform==\"linux2\"',\n        'large-image[pil];sys.platform!=\"linux\" and sys.platform!=\"linux2\"',\n        'girder-slicer-cli-web',\n        # cli\n        'ctk-cli',\n    ] + (\n        # Only require opencv if it isn't installed.  This can allow alternate\n        # forms to be in the environment (such as a headed form) without\n        # causing conflicts\n        [\n            'opencv-python-headless ; python_version >= \"3.7\"',\n            'opencv-python-headless<4.7 ; python_version < \"3.7\"',\n        ] if not importlib.util.find_spec('cv2') else []\n    ),\n    license='Apache Software License 2.0',\n    keywords='histomicstk',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'License :: OSI Approved :: Apache Software License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n    zip_safe=False,\n    python_requires='>=3.6',\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"numpy\", \"cython\", \"setuptools-scm\"]\n\n"
  },
  "syoyo/tinyusdz": {
    "setup.py": "import os\nimport pathlib\n\n# skbuild = python setuptools with Cmake support\nfrom skbuild import setup\n\nsetup(\n    name='tinyusdz',\n    version='0.8.0rc4',\n    author='Light Transport Entertainment Inc.',\n    author_email='syoyo@lighttransport.com, lighttransport.eth@mail3.me',\n    # `python/tinyusdz` as root for `tinyusdz` module\n    packages=['tinyusdz'],\n    package_dir={'': 'python'},\n    cmake_args=['-DTINYUSDZ_WITH_PYTHON=1',\n        '-DTINYUSDZ_BUILD_EXAMPLES=Off',\n        '-DTINYUSDZ_BUILD_TESTS=Off',\n        '-DTINYUSDZ_WITH_TOOL_USDA_PARSER=Off',\n        '-DTINYUSDZ_WITH_TOOL_USDC_PARSER=Off'],\n    long_description=open(\"./python/README.md\", 'r').read(),\n    long_description_content_type='text/markdown',\n    license='MIT',\n)\n",
    "pyproject.toml": "#\n# It seeems pyproject(python-build) is still not mature to build native modules.\n# So we don't use pyton-buold at the moment.\n# This file is just provided for future possible use of `python-build`.\n#\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.16\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 140\n"
  },
  "pthom/imgui_bundle": {
    "setup.py": "# Part of ImGui Bundle - MIT License - Copyright (c) 2022-2023 Pascal Thomet - https://github.com/pthom/imgui_bundle\nfrom typing import List\nimport sys\nimport os\n\nVERSION = \"0.8.5\"  # Remember to mirror changes on line 2 of main CMakeLists!\nTHIS_DIR = os.path.dirname(__file__)\nROOT_PACKAGE_FOLDER = \"bindings/imgui_bundle\"\nROOT_PACKAGE_NAME = \"imgui_bundle\"\n\n\ndef get_readme():\n    with open(ROOT_PACKAGE_FOLDER + \"/Readme_pypi.md\", encoding=\"utf8\") as f:\n        r = f.read()\n    return r\n\n\ndef _get_assets_and_demos_cpp_dirs() -> List[str]:\n    r = []\n\n    dir_name: str\n    for dir_name, subdir_list, file_list in os.walk(ROOT_PACKAGE_FOLDER):\n\n        def is_assets_dir_or_subdir():\n            dir_parts = dir_name.replace(\"\\\\\", \"/\").split(\"/\")\n            return \"assets\" in dir_parts or \"demos_cpp\" in dir_parts or \"demos_assets\" or \"doc\" in dir_parts\n\n        if is_assets_dir_or_subdir():\n            relative_dir = os.path.relpath(dir_name, ROOT_PACKAGE_FOLDER)\n            r.append(relative_dir)\n\n    return r\n\n\ndef get_imgui_bundle_package_data() -> List[str]:\n    data = [\n        \"Readme.md\",\n        \"LICENSE\",\n        \"py.typed\",\n        \"*.pyi\",\n        \"*/*.pyi\",\n        \"*/py.typed\",\n        \"demos_python/notebooks/*.ipynb\",\n        \"demos_python/demos_node_editor/demo_node_editor_basic.json\",\n    ]\n    for asset_dir in _get_assets_and_demos_cpp_dirs():\n        data.append(asset_dir + \"/*.*\")\n    return data\n\n\ndef get_imgui_bundle_packages() -> List[str]:\n    r = []\n    dir_name: str\n    for dir_name, subdir_list, file_list in os.walk(ROOT_PACKAGE_FOLDER):\n        if os.path.isfile(dir_name + \"/__init__.py\"):\n            package_dir = os.path.relpath(dir_name, ROOT_PACKAGE_FOLDER)\n            if package_dir == \".\":\n                package_name = ROOT_PACKAGE_NAME\n            else:\n                package_name = ROOT_PACKAGE_NAME + \".\" + package_dir.replace(\"/\", \".\")\n            r.append(package_name)\n    return r\n\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nsetup(\n    name=\"imgui-bundle\",\n    version=VERSION,\n    author=\"Pascal Thomet\",\n    author_email=\"pthomet@gmail.com\",\n    description=\"Dear ImGui Bundle: easily create ImGui applications in Python and C++. Batteries included!\",\n    long_description=get_readme(),\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/pthom/imgui_bundle\",\n    packages=(get_imgui_bundle_packages()),\n    package_dir={\"\": \"bindings\"},\n    cmake_install_dir=\"bindings/imgui_bundle\",\n    extras_require={\"test\": [\"pytest\"]},\n    python_requires=\">=3.6\",\n    package_data={\"imgui_bundle\": get_imgui_bundle_package_data()},\n    install_requires=[\n        \"numpy >= 1.15\",\n        \"munch >= 2.0.0\",\n        \"glfw > 2.5\",\n        \"PyOpenGL >= 3.0\",\n        \"PyGLM>=2.5.0\",\n        \"pillow >= 9.0.0\",\n    ],\n    entry_points={\n        \"console_scripts\": [\n            \"demo_imgui_bundle=imgui_bundle.demos_python.demo_imgui_bundle:main\",\n            \"imgui_bundle_demo=imgui_bundle.demos_python.demo_imgui_bundle:main\",\n        ],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"pybind11>=2.9.2\",\n    \"cmake>=3.22, !=3.25.0\",  # cmake 3.25.0 is buggy and fails with OpenCV (see https://github.com/opencv/opencv/issues/22784)\n    \"scikit-build>=0.14.1\",\n    \"ninja; platform_system!='Windows'\",\n    \"patch>=1.16\",\n    \"conan>=1.5\",\n    \"distro<=1.7.0,>=1.0.2\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\"\n\n\n\n[tool.cibuildwheel]\nbuild-verbosity = 1\n\n# Target python versions:\nbuild = [\"cp39-*\", \"cp310-*\", \"cp311-*\"]\n\n# Tests\ntest-requires = \"pytest\"\ntest-command = \"pytest {project}/tests\"  # cibuildwheel doc says pytest {package}/tests !\n\n\n#####################################\n# macos wheels options\n#####################################\n[tool.cibuildwheel.macos]\n# identify whether this is a M1 or intel\nbefore-build = \"uname -a\"\n# Skip trying to test arm64 builds on Intel Macs\n# test-skip = [\"*-macosx_arm64 *-macosx_universal2:arm64\"]\n#\n# Skip trying to test x86_64 builds on Mac M1\n# test-skip = [\"*-macosx_x86_64 *-macosx_universal2:x86_64\"]\n# test-skip = [\"*-macosx_arm64 *-macosx_universal2:arm64\"]\ntest-skip = [\"*\"]\n# Environment variables\n# IMGUIBUNDLE_OPENCV_FETCH_SOURCE => Will fetch, build and install a very-minimalist OpenCV\nenvironment = { MACOSX_DEPLOYMENT_TARGET=\"11.0\" }\n\n# Architectures\n# -------------\n# archs = [\"universal2\"] # building universal2 fails miserably at this time: see comment in external/immvision/find_opencv.cmake\n# So, we build separately for x86_64 and arm64\n# archs = [\"x86_64\", \"arm64\"]\n# Actually, we (temporarily) do not build for arm64 on github's CI, since it succeeds to build a wheel,\n# however the resulting wheel wants to link to intel IPP, which is not available on arm.\n# => mac arm61 will need to be built and uploaded from an M1 mac\narchs = [\"x86_64\"]\n\n#####################################\n# linux wheels options\n#####################################\n[tool.cibuildwheel.linux]\nskip = [\"*i686\"]\ntest-skip = [\"cp311-musllinux_x86_64\"] #  opencv-python not yet available there\n# Environment variables\n# IMGUIBUNDLE_OPENCV_FETCH_SOURCE => Will fetch, build and install a very-minimalist OpenCV\n# environment = { IMGUIBUNDLE_OPENCV_FETCH_SOURCE=\"ON\" }\n\n# Install glfw dev packages on manylinux:\n# --------------------------------------\n# https://www.glfw.org/docs/3.3/compile.html#compile_deps\n# https://iscinumpy.dev/post/cibuildwheel-2-2-0/\n# cibuildwheel has added a new platform: musllinux\n# Remember, the manylinux1 image has been in maintenance mode, has no support for Python 3.10,\n# and will be fully retired at the end of 2021.\n#\n# This also means that installing things inside the images can vary even further;\n# * manylinux1 (CentOS 5), manylinux2010 (CentOS 6), and manylinux2014 (CentOS 7) all use yum;\n#     => yum install -y libXcursor-devel libXi-devel libXinerama-devel libXrandr-devel\n# * manylinux_2_24 (Debian 8) uses apt (and is stuck on GCC 6),\n#     => apt install xorg-dev\n# * musllinux_1_1 MUSL based distributions of Linux (like Alpine). uses apk\nbefore-all = \"yum install -y libXcursor-devel libXi-devel libXinerama-devel libXrandr-devel\"\n[[tool.cibuildwheel.overrides]]\nselect = \"*-musllinux*\"\nbefore-all = \"apk add xorg-server-dev libxcursor-dev libxi-dev libxinerama-dev libxrandr-dev\"\n\n#####################################\n# windows wheels options\n#####################################\n[tool.cibuildwheel.windows]\nskip = [\"*win32\"]\n\n# Environment variables\n# IMGUIBUNDLE_OPENCV_FETCH_SOURCE => Download a precompiled version of opencv4.6.0\n# environment = { IMGUIBUNDLE_OPENCV_WIN_USE_OFFICIAL_PREBUILT_460=\"ON\" }\n"
  },
  "ds4dm/ecole": {
    "setup.py": "import pathlib\nimport re\nimport sys\nimport os\nimport shlex\nimport platform\n\nfrom typing import List\n\nimport skbuild\n\n__dir__ = pathlib.Path(__file__).resolve().parent\n\n\ndef get_file(file: pathlib.Path) -> str:\n    \"\"\"Extract all lines from a file.\"\"\"\n    with open(file, \"r\") as f:\n        return f.read()\n\n\ndef get_version(version_file: pathlib.Path) -> str:\n    \"\"\"Extract version from the Ecole VERSION file according to PEP440.\"\"\"\n    lines = get_file(version_file)\n    major = re.search(r\"VERSION_MAJOR\\s+(\\d+)\", lines).group(1)\n    minor = re.search(r\"VERSION_MINOR\\s+(\\d+)\", lines).group(1)\n    patch = re.search(r\"VERSION_PATCH\\s+(\\d+)\", lines).group(1)\n    pre = re.search(r\"VERSION_PRE\\s+([\\.\\w]*)\", lines).group(1)\n    post = re.search(r\"VERSION_POST\\s+([\\.\\w]*)\", lines).group(1)\n    dev = re.search(r\"VERSION_DEV\\s+([\\.\\w]*)\", lines).group(1)\n    return f\"{major}.{minor}.{patch}{pre}{post}{dev}\"\n\n\ndef get_env_cmake_args() -> List[str]:\n    \"\"\"Return the list of extra CMake arguments from the environment.\n\n    When called through conda-build (environment variable `CONDA_BUILD` is set), the `CMAKE_INSTALL_<>`\n    are filtered out as they\n    \"\"\"\n    cmake_args = shlex.split(os.environ.get(\"CMAKE_ARGS\", \"\"))\n    if \"CONDA_BUILD\" in os.environ:\n        install_re = re.compile(r\"-D\\s*CMAKE_INSTALL.*\")\n        cmake_args = [a for a in cmake_args if not install_re.search(a)]\n    return cmake_args\n\n\ndef get_cmake_install_args() -> List[str]:\n    \"\"\"Return default installation settings.\"\"\"\n    if \"CONDA_BUILD\" in os.environ:\n        return get_cmake_out_package_install_args()\n    else:\n        return get_cmake_in_package_install_args()\n\n\ndef get_cmake_in_package_install_args() -> List[str]:\n    \"\"\"Return default installation settings for installing libecole in the package.\"\"\"\n    system = platform.system()\n    if system == \"Linux\":\n        origin = r\"${ORIGIN}\"\n    elif system == \"Darwin\":\n        origin = \"@loader_path\"\n    else:\n        raise NotImplementedError(f\"OS {system} is not supported\")\n    return [\n        \"-DBUILD_SHARED_LIBS=ON\",\n        \"-DCMAKE_INSTALL_LIBDIR=lib\",\n        \"-DCMAKE_INSTALL_BINDIR=bin\",\n        \"-DCMAKE_INSTALL_INCLUDEDIR=include\",\n        \"-DECOLE_PY_EXT_INSTALL_LIBDIR='.'\",\n        \"-DECOLE_PY_EXT_INSTALL_RPATH={origin}/lib\".format(origin=origin),\n    ]\n\n\ndef get_cmake_out_package_install_args() -> List[str]:\n    \"\"\"Return default installation settings for an extrenal libecole installation.\"\"\"\n    return [\"-DECOLE_BUILD_LIB=OFF\", \"-DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON\"]\n\n\nskbuild.setup(\n    name=\"ecole\",\n    author=\"Antoine Prouvost et al.\",\n    version=get_version(__dir__ / \"VERSION\"),\n    url=\"https://www.ecole.ai\",\n    description=\"Extensible Combinatorial Optimization Learning Environments\",\n    long_description=get_file(__dir__ / \"README.rst\"),\n    long_description_content_type=\"text/x-rst\",\n    license=\"BSD-3-Clause\",\n    packages=[\"ecole\"],\n    package_dir={\"\": \"python/ecole/src\"},\n    package_data={\"ecole\": [\"py.typed\"]},\n    cmake_languages=[\"CXX\"],\n    cmake_install_dir=\"python/ecole/src/ecole\",  # Must match package_dir layout\n    cmake_minimum_required_version=\"3.14\",\n    # FIXME No way to pass cmake argument to scikit-build through pip (for now)\n    # https://github.com/scikit-build/scikit-build/issues/479\n    # So we read them from an environment variable\n    cmake_args=get_cmake_install_args() + get_env_cmake_args(),\n    zip_safe=False,\n    python_requires=\">=3.6\",\n    install_requires=[\"numpy>=1.4\"],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n\t\"setuptools>=42\",\n\t\"wheel\",\n\t\"pybind11>=2.7\",\n\t\"cmake>=3.15\",\n\t\"numpy>=1.4\",\n\t\"ninja\",\n\t\"scikit-build\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 100\n"
  },
  "IntelligentSoftwareSystems/Galois": {
    "setup.py": "import sys\nimport os\nimport setuptools\n\nfrom skbuild import setup\n\n# Require pytest-runner only when running tests\npytest_runner = (\n    [\"pytest-runner>=2.0,<3dev\"] if any(arg in sys.argv for arg in (\"pytest\", \"test\")) else []\n)\n\nsetup_requires = pytest_runner\n\n\ndef find_files(root, suffix):\n    \"\"\"\n    Find files ending with a given suffix in root and its subdirectories and\n    return their names relative to root.\n    \"\"\"\n    files = []\n    for dirpath, _, filenames in os.walk(root):\n        for f in filenames:\n            if not f.endswith(suffix):\n                continue\n            relpath = os.path.relpath(dirpath, root)\n            files.append(os.path.join(relpath, f))\n    return files\n\n\ndef package_setup():\n    with open(\"config/version.txt\") as f:\n        version = f.read().strip()\n\n    pxd_files = find_files(\"python/galois\", \".pxd\")\n\n    # \"pip wheel --build-option=...\" disables use of wheels for dependencies.\n    # In order to support passing build arguments directly, accept arguments\n    # via the environment.\n    cmake_args = os.environ.get(\"GALOIS_CMAKE_ARGS\", \"\").split()\n\n    # Following PEP-518, use pyproject.toml instead of setup(setup_requires=...) to\n    # specify setup dependencies.\n\n    setup(\n        version=version,\n        name=\"galois\",\n        packages=setuptools.find_packages(\"python\"),\n        package_data={\"galois\": pxd_files},\n        package_dir={\"\": \"python\"},\n        tests_require=[\"pytest\"],\n        setup_requires=setup_requires,\n        cmake_args=cmake_args,\n        cmake_source_dir=\"python\",\n    )\n\n\nif __name__ == \"__main__\":\n    package_setup()\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake>=3.13\", \"cython\"]\n"
  },
  "rapidsai/raft": {
    "python/raft-dask/setup.py": "#\n# Copyright (c) 2020-2023, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\ndef exclude_libcxx_symlink(cmake_manifest):\n    return list(\n        filter(\n            lambda name: not (\"include/rapids/libcxx/include\" in name),\n            cmake_manifest,\n        )\n    )\n\n\npackages = find_packages(include=[\"raft_dask*\"])\nsetup(\n    cmake_process_manifest_hook=exclude_libcxx_symlink,\n    packages=packages,\n    package_data={key: [\"*.pxd\"] for key in packages},\n    zip_safe=False,\n)\n",
    "python/raft-dask/pyproject.toml": "# Copyright (c) 2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\n\nrequires = [\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"cython>=0.29,<0.30\",\n    \"ninja\",\n    \"scikit-build>=0.13.1,<0.17.2\",\n    \"setuptools\",\n    \"wheel\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project]\nname = \"raft-dask\"\nversion = \"23.06.00\"\ndescription = \"Reusable Accelerated Functions & Tools Dask Infrastructure\"\nreadme = { file = \"README.md\", content-type = \"text/markdown\" }\nauthors = [\n    { name = \"NVIDIA Corporation\" },\n]\nlicense = { text = \"Apache 2.0\" }\nrequires-python = \">=3.9\"\ndependencies = [\n    \"dask-cuda==23.6.*\",\n    \"dask==2023.3.2\",\n    \"distributed==2023.3.2.1\",\n    \"joblib>=0.11\",\n    \"numba>=0.49\",\n    \"numpy>=1.21\",\n    \"pylibraft==23.6.*\",\n    \"ucx-py==0.32.*\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"pytest\",\n    \"pytest-cov\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project.urls]\nHomepage = \"https://github.com/rapidsai/raft\"\nDocumentation = \"https://docs.rapids.ai/api/raft/stable/\"\n\n[tool.setuptools]\nlicense-files = [\"LICENSE\"]\n\n[tool.isort]\nline_length = 79\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\ncombine_as_imports = true\norder_by_type = true\nknown_dask = [\n    \"dask\",\n    \"distributed\",\n    \"dask_cuda\",\n]\nknown_rapids = [\n    \"pylibraft\",\n    \"rmm\",\n]\nknown_first_party = [\n    \"raft_dask\",\n]\ndefault_section = \"THIRDPARTY\"\nsections = [\n    \"FUTURE\",\n    \"STDLIB\",\n    \"THIRDPARTY\",\n    \"DASK\",\n    \"RAPIDS\",\n    \"FIRSTPARTY\",\n    \"LOCALFOLDER\",\n]\nskip = [\n    \"thirdparty\",\n    \".eggs\",\n    \".git\",\n    \".hg\",\n    \".mypy_cache\",\n    \".tox\",\n    \".venv\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"__init__.py\",\n]\n",
    "python/pylibraft/setup.py": "#\n# Copyright (c) 2022-2023, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\ndef exclude_libcxx_symlink(cmake_manifest):\n    return list(\n        filter(\n            lambda name: not (\"include/rapids/libcxx/include\" in name),\n            cmake_manifest,\n        )\n    )\n\n\npackages = find_packages(include=[\"pylibraft*\"])\nsetup(\n    # Don't want libcxx getting pulled into wheel builds.\n    cmake_process_manifest_hook=exclude_libcxx_symlink,\n    packages=packages,\n    package_data={key: [\"*.pxd\"] for key in packages},\n    zip_safe=False,\n)\n",
    "python/pylibraft/pyproject.toml": "# Copyright (c) 2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\n\nrequires = [\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"cuda-python>=11.7.1,<12.0\",\n    \"cython>=0.29,<0.30\",\n    \"ninja\",\n    \"rmm==23.6.*\",\n    \"scikit-build>=0.13.1,<0.17.2\",\n    \"setuptools\",\n    \"wheel\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"pylibraft\"\nversion = \"23.06.00\"\ndescription = \"RAFT: Reusable Algorithms Functions and other Tools\"\nreadme = { file = \"README.md\", content-type = \"text/markdown\" }\nauthors = [\n    { name = \"NVIDIA Corporation\" },\n]\nlicense = { text = \"Apache 2.0\" }\nrequires-python = \">=3.9\"\ndependencies = [\n    \"cuda-python>=11.7.1,<12.0\",\n    \"numpy>=1.21\",\n    \"rmm==23.6.*\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\nclassifiers = [\n    \"Intended Audience :: Developers\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n]\n\n[project.optional-dependencies]\ntest = [\n    \"cupy-cuda11x>=12.0.0\",\n    \"pytest\",\n    \"pytest-cov\",\n    \"scikit-learn\",\n    \"scipy\",\n] # This list was generated by `rapids-dependency-file-generator`. To make changes, edit ../../dependencies.yaml and run `rapids-dependency-file-generator`.\n\n[project.urls]\nHomepage = \"https://github.com/rapidsai/raft\"\nDocumentation = \"https://docs.rapids.ai/api/raft/stable/\"\n\n[tool.setuptools]\nlicense-files = [\"LICENSE\"]\n\n[tool.isort]\nline_length = 79\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\ncombine_as_imports = true\norder_by_type = true\nknown_dask = [\n    \"dask\",\n    \"distributed\",\n    \"dask_cuda\",\n]\nknown_rapids = [\n    \"rmm\",\n]\nknown_first_party = [\n    \"pylibraft\",\n]\ndefault_section = \"THIRDPARTY\"\nsections = [\n    \"FUTURE\",\n    \"STDLIB\",\n    \"THIRDPARTY\",\n    \"DASK\",\n    \"RAPIDS\",\n    \"FIRSTPARTY\",\n    \"LOCALFOLDER\",\n]\nskip = [\n    \"thirdparty\",\n    \".eggs\",\n    \".git\",\n    \".hg\",\n    \".mypy_cache\",\n    \".tox\",\n    \".venv\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"__init__.py\",\n]\n",
    "python/pylibraft/setup.cfg": "# Copyright (c) 2022-2023, NVIDIA CORPORATION.\n\n[isort]\nline_length=79\nmulti_line_output=3\ninclude_trailing_comma=True\nforce_grid_wrap=0\ncombine_as_imports=True\norder_by_type=True\nknown_dask=\n    dask\n    distributed\n    dask_cuda\nknown_rapids=\n    nvtext\n    cudf\n    cuml\n    cugraph\n    dask_cudf\n    rmm\nknown_first_party=\n    raft\n    pylibraft\ndefault_section=THIRDPARTY\nsections=FUTURE,STDLIB,THIRDPARTY,DASK,RAPIDS,FIRSTPARTY,LOCALFOLDER\nskip=\n    thirdparty\n    .eggs\n    .git\n    .hg\n    .mypy_cache\n    .tox\n    .venv\n    _build\n    buck-out\n    build\n    dist\n    __init__.py\n"
  },
  "Nic30/hdlConvertor": {
    "setup.py": "#!/usr/bin/env python3\n# -*- coding: UTF-8 -*-\n\nimport os\nfrom setuptools import find_packages\ntry:\n    from skbuild import setup\nexcept ImportError:\n    raise ImportError(\"Missing scikit-build, (should be automatically installed by pip)\")\nimport sys\n\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(this_directory, \"README.md\")) as f:\n    long_description = f.read()\n\ndeps = [\"typing\", \"future\"] if sys.version_info[0] == 2 else []\n\n\nsetup(\n    cmake_args=[\n        # '-DCMAKE_BUILD_TYPE=Debug'\n    ],\n    name='hdlConvertor',\n    version='2.3',\n    description='VHDL and System Verilog parser written in c++',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url='https://github.com/Nic30/hdlConvertor',\n    author='Michal Orsak',\n    author_email='Nic30original@gmail.com',\n    keywords=['hdl', 'vhdl', 'verilog', 'system verilog',\n              'parser', 'preprocessor', 'antlr4'],\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'Operating System :: OS Independent',\n        'Topic :: Software Development :: Build Tools',\n        'Programming Language :: C++',\n        'Programming Language :: Cython',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)',\n    ],\n    install_requires=[\n        'hdlConvertorAst>=1.0',\n    ] + deps,\n    license=\"MIT\",\n    packages=find_packages(exclude=[\"tests\", ]),\n    test_suite=\"tests.main_test_suite\",\n    test_runner=\"tests:TimeLoggingTestRunner\",\n    tests_require=deps,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"Cython\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n",
    "setup.cfg": "[metadata]\ndescription_file = README.md\n"
  },
  "adobe/lagrange": {
    "setup.py": "#\n# Copyright 2022 Adobe. All rights reserved.\n# This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License. You may obtain a copy\n# of the License at http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software distributed under\n# the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n# OF ANY KIND, either express or implied. See the License for the specific language\n# governing permissions and limitations under the License.\n#\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n        \"install .'. If you wish to run the setup script directly, you must \"\n        \"first install the build dependencies listed in pyproject.toml!\",\n        file=sys.stderr,\n    )\n    raise\n\nsetup(\n    packages=[\"lagrange\"],\n    package_dir={\"lagrange\": \"modules/python/lagrange\"},\n    cmake_install_dir=\"modules/python/lagrange\",\n    include_package_data=True,\n    package_data={\"lagrange\": [\"lagrange/*.pyi\", \"py.typed\"]},\n    cmake_args=[\n        \"-DLAGRANGE_ASSERT_DEBUG_BREAK=Off\",\n        \"-DLAGRANGE_EXAMPLES=Off\",\n        \"-DLAGRANGE_INSTALL=Off\",\n        \"-DLAGRANGE_MODULE_DECIMATION=On\",\n        \"-DLAGRANGE_MODULE_IO=On\",\n        \"-DLAGRANGE_MODULE_PYTHON=On\",\n        \"-DLAGRANGE_MODULE_SCENE=On\",\n        \"-DLAGRANGE_UNIT_TESTS=Off\",\n        \"-DLAGRANGE_WITH_ASSIMP=On\",\n        \"-DTBB_PREFER_STATIC=Off\",\n        \"-DPython_EXECUTABLE=\" + sys.executable,\n        # Debugging options.\n        #'-DCMAKE_BUILD_TYPE=Debug',\n        #'-DUSE_SANITIZER=Address',\n    ],\n    cmake_install_target=\"lagrange-python-install-runtime\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel>=0.36.0\",\n    \"scikit-build==0.14.0\",\n    \"cmake>=3.24.2\",\n    \"nanobind-stubgen==0.1.1\",\n    \"ninja; platform_system!='Windows'\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"lagrange-open\"\nmaintainers = [{name = \"Lagrange Core Team\", email = \"lagrange-core@adobe.com\"}]\ndescription = \"A robust geometry processing engine\"\nlicense = {file = \"LISENCE\"}\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\ndependencies = [\n    \"numpy>=1.23\",\n    \"colorama>=0.4.5\",\n]\ndynamic = [\"version\"]\n\n[tool.setuptools.dynamic]\nversion = {file = \"VERSION\"}\n\n[project.urls]\nrepo = \"https://github.com/adobe/lagrange\"\ndoc = \"https://opensource.adobe.com/lagrange-docs\"\n"
  },
  "glotzerlab/freud": {
    "setup.py": "# Copyright (c) 2010-2023 The Regents of the University of Michigan\n# This file is from the freud project, released under the BSD 3-Clause License.\n\nimport os\n\nfrom skbuild import setup\n\nversion = \"2.13.0\"\n\n# Read README for PyPI, fallback to short description if it fails.\ndescription = \"Powerful, efficient trajectory analysis in scientific Python.\"\ntry:\n    readme_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"README.rst\")\n    with open(readme_file) as f:\n        readme = f.read()\nexcept ImportError:\n    readme = description\n\n\nsetup(\n    name=\"freud-analysis\",\n    version=version,\n    packages=[\"freud\"],\n    description=description,\n    long_description=readme,\n    long_description_content_type=\"text/x-rst\",\n    keywords=(\n        \"simulation analysis molecular dynamics soft matter \"\n        \"particle system computational physics\"\n    ),\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Topic :: Scientific/Engineering :: Chemistry\",\n        \"Topic :: Scientific/Engineering :: Physics\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Cython\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    zip_safe=False,\n    maintainer=\"freud Developers\",\n    maintainer_email=\"freud-developers@umich.edu\",\n    # See documentation credits for current and former lead developers\n    author=\"Vyas Ramasubramani et al.\",\n    author_email=\"vramasub@umich.edu\",\n    url=\"https://github.com/glotzerlab/freud\",\n    download_url=\"https://pypi.org/project/freud-analysis/\",\n    project_urls={\n        \"Homepage\": \"https://github.com/glotzerlab/freud\",\n        \"Documentation\": \"https://freud.readthedocs.io/\",\n        \"Source Code\": \"https://github.com/glotzerlab/freud\",\n        \"Issue Tracker\": \"https://github.com/glotzerlab/freud/issues\",\n    },\n    python_requires=\">=3.7\",\n    install_requires=[\n        \"numpy>=1.14\",\n        \"rowan>=1.2.1\",\n        \"scipy>=1.1\",\n    ],\n    tests_require=[\n        \"ase>=3.16\",\n        \"gsd>=2.0\",\n        \"garnett>=0.7.1\",\n        \"matplotlib>=3.0\",\n        \"sympy>=1.0\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"oldest-supported-numpy\", \"cython>=0.29.14\", \"scikit-build>=0.17.3\", \"cmake\"]\n\n[tool.black]\ntarget-version = ['py36']\n\n[tool.isort]\nprofile = 'black'\n",
    "setup.cfg": "[bumpversion]\ncurrent_version = 2.13.0\ncommit = True\ntag = False\nmessage = Bump up to version {new_version}.\n\n[flake8]\nmax-line-length = 88\nfilename = *.py,*.pyx,*.pxi,*.pxd\nforce-check = True\nexclude = .eggs,*.egg,build,extern,doc/source/gettingstarted/examples\nselect = E,F,W\nignore = E203,E225,E226,E227,E741,E999,W503,W504\nper-file-ignores = \n\tfreud/__init__.py: F401\n\tfreud/*.pxd: E402\n\n[tool:pytest]\nnorecursedirs = extern\n\n[bumpversion:file:freud/__init__.py]\n\n[bumpversion:file:doc/source/conf.py]\n\n[bumpversion:file:setup.py]\n\n[bumpversion:file:.github/ISSUE_TEMPLATE/bug_report.yml]\n\n[coverage:run]\nbranch = True\nsource = freud\nplugins = Cython.Coverage\n\n[coverage:report]\nignore_errors = True\n\n[coverage:html]\ndirectory = coverage_html_report\n"
  },
  "NGSolve/netgen": {
    "setup.py": "import glob\nimport os\nimport sys\nimport pathlib\n\nfrom skbuild import setup\nimport skbuild.cmaker\nfrom subprocess import check_output\nfrom distutils.sysconfig import get_python_lib;\n\nsetup_requires = []\n\ndef install_filter(cmake_manifest):\n    print(cmake_manifest)\n    return cmake_manifest\n\ndef _patched_parse_manifests(self):\n    paths = \\\n        glob.glob(os.path.join(skbuild.cmaker.CMAKE_BUILD_DIR(), \"netgen\", \"install_manifest*.txt\"))\n    try:\n        return [self._parse_manifest(path) for path in paths][0]\n    except IndexError:\n        return []\n   \n# we are using the netgen superbuild (to download and build some dependencies)\n# patch the parse_manifests function to point to the actual netgen cmake project within the superbuild\nskbuild.cmaker.CMaker._parse_manifests = _patched_parse_manifests\n\ngit_version = check_output(['git', 'describe', '--tags']).decode('utf-8').strip()\nversion = git_version[1:].split('-')\nif len(version)>2:\n    version = version[:2]\nif len(version)>1:\n    version = '.post'.join(version) + '.dev'\nelse:\n    version = version[0]\n\npy_install_dir = get_python_lib(1,0,'').replace('\\\\','/')\n\nname = \"netgen-mesher\"\narch = None\ncmake_args = [\n        f'-DNETGEN_VERSION_GIT={git_version}',\n        f'-DNETGEN_VERSION_PYTHON={version}',\n    ]\n\nif 'NETGEN_ARCH' in os.environ and os.environ['NETGEN_ARCH'] == 'avx2':\n    # build for avx2 architecture\n    if 'darwin' in sys.platform:\n        flag = \"'-Xarch_x86_64;-march=core-avx2'\"\n    elif 'win' in sys.platform:\n        flag = '/AVX2'\n    else:\n        flag = '-march=core-avx2'\n    cmake_args += [f'-DNG_COMPILE_FLAGS={flag}']\n\nif 'NETGEN_CCACHE' in os.environ:\n  cmake_args += [f'-DUSE_CCACHE=ON']\n\npackages = ['netgen', 'pyngcore']\n\nif 'darwin' in sys.platform:\n    cmake_args += [\n        '-DNG_INSTALL_DIR_LIB=netgen',\n        '-DNG_INSTALL_DIR_PYTHON=.',\n        '-DNG_INSTALL_DIR_BIN=bin',\n        '-DNG_INSTALL_DIR_CMAKE=netgen/cmake',\n        '-DNG_INSTALL_DIR_INCLUDE=netgen/include',\n        '-DNG_INSTALL_DIR_RES=share',\n    ]\nelif 'win' in sys.platform:\n    cmake_args += [\n        '-A Win64',\n        '-DNG_INSTALL_DIR_BIN=netgen',\n        '-DNG_INSTALL_DIR_PYTHON=.',\n        '-DNG_INSTALL_DIR_LIB=netgen/lib',\n        '-DNG_INSTALL_DIR_CMAKE=netgen/cmake',\n        '-DNG_INSTALL_DIR_INCLUDE=netgen/include',\n    ]\nelif 'linux' in sys.platform:\n    name_dir = name.replace('-','_')\n    cmake_args += [\n        f'-DNG_INSTALL_DIR_LIB={py_install_dir}/{name_dir}.libs',\n        '-DNG_INSTALL_DIR_BIN=bin',\n        '-DNG_INSTALL_DIR_INCLUDE=include/netgen',\n        '-DTCL_INCLUDE_PATH=/usr/include',\n        '-DTK_INCLUDE_PATH=/usr/include',\n    ]\n    packages = []\n\ncmake_args += [\n        '-DUSE_SUPERBUILD:BOOL=ON',\n        '-DUSE_CCACHE:BOOL=ON',\n        '-DUSE_GUI=ON',\n        '-DUSE_NATIVE_ARCH=OFF',\n        '-DBUILD_ZLIB=ON',\n        '-DBUILD_OCC=ON',\n        '-DUSE_OCC=ON',\n        '-DBUILD_FOR_CONDA=ON',\n        f'-DNETGEN_PYTHON_PACKAGE_NAME={name}',\n        '-DBUILD_STUB_FILES=OFF',\n]\n\npyprefix = pathlib.Path(sys.prefix).as_posix()\ncmake_args += [f'-DCMAKE_PREFIX_PATH={pyprefix}']\n\nsetup(\n    name=name,\n    version=version,\n    description=\"Netgen\",\n    author='The Netgen team',\n    license=\"LGPL2.1\",\n    packages=packages,\n    #package_dir={'netgen': 'python'},\n    tests_require=['pytest'],\n    #include_package_data=True,\n    cmake_process_manifest_hook=install_filter,\n    cmake_args = cmake_args,\n    setup_requires=setup_requires,\n    entry_points={\n    'console_scripts': [\n        'netgen = netgen.__main__:main',\n    ],\n},\n)\n"
  },
  "IBM/aihwkit": {
    "setup.py": "# -*- coding: utf-8 -*-\n\n# (C) Copyright 2020, 2021, 2022 IBM. All Rights Reserved.\n#\n# This code is licensed under the Apache License, Version 2.0. You may\n# obtain a copy of this license in the LICENSE.txt file in the root directory\n# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.\n#\n# Any modifications or derivative works of this code must retain this\n# copyright notice, and modified files need to carry a notice indicating\n# that they have been altered from the originals.\n\n\"\"\"Setup.py for `aihwkit`.\"\"\"\n\nimport os\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nINSTALL_REQUIRES = [\n    'torch{}'.format(os.getenv('TORCH_VERSION_SPECIFIER', '>=1.9')),\n    'torchvision',\n    'scipy',\n    'requests>=2.25,<3',\n    'numpy>=1.19',\n    'protobuf>=4.21.6',\n]\n\ndef get_version() -> str:\n    \"\"\"Get the package version.\"\"\"\n    version_path = os.path.join(\n        os.path.dirname(__file__), 'src', 'aihwkit', 'VERSION.txt')\n    with open(version_path, encoding='utf-8') as version_file:\n        return version_file.read().strip()\n\n\ndef get_long_description() -> str:\n    \"\"\"Get the package long description.\"\"\"\n    readme_path = os.path.join(os.path.dirname(__file__), 'README.md')\n    with open(readme_path, encoding='utf-8') as readme_file:\n        return readme_file.read().strip()\n\n\nsetup(\n    name='aihwkit',\n    version=get_version(),\n    description='IBM Analog Hardware Acceleration Kit',\n    long_description=get_long_description(),\n    long_description_content_type='text/markdown',\n    url='https://github.com/IBM/aihwkit',\n    author='IBM Research',\n    author_email='aihwkit@us.ibm.com',\n    license='Apache 2.0',\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Environment :: Console',\n        'Environment :: GPU :: NVIDIA CUDA',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: Apache Software License',\n        'Operating System :: MacOS',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX :: Linux',\n        'Programming Language :: Python :: 3 :: Only',\n        'Topic :: Scientific/Engineering',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n        'Typing :: Typed',\n    ],\n    keywords=['ai', 'analog', 'rpu', 'torch'],\n    package_dir={'': 'src'},\n    packages=find_packages('src'),\n    package_data={\n        'aihwkit': ['VERSION.txt']\n    },\n    install_requires=INSTALL_REQUIRES,\n    python_requires='>=3.7',\n    zip_safe=False,\n    extras_require={\n        'visualization': ['matplotlib>=3.0'],\n        'fitting': ['lmfit'],\n        'bert': [\n            'transformers',\n            'evaluate',\n            'datasets',\n            'wandb',\n            'tensorboard',\n        ],\n    }\n)\n",
    "setup.cfg": "[pycodestyle]\nmax-line-length = 100\nexclude = *_pb2.py\n\n[pydocstyle]\nconvention = google\nadd_ignore = D105,D107,D205,D400,D415\nadd_select = D204,D215,D401,D404\nmatch-dir = ^(?!helpers|definitions).*\n\n[mypy]\npython_version = 3.8\nnamespace_packages = True\nignore_missing_imports = True\nwarn_redundant_casts = True\nwarn_unreachable = True\nstrict_equality = True\ndisallow_untyped_calls = True\ndisallow_untyped_defs = True\ndisallow_incomplete_defs = True\nstrict_optional = True\n\n[mypy-torch.*]\nfollow_imports = skip\nfollow_imports_for_stubs = True\n\n[mypy-aihwkit.cloud.converter.definitions.*]\nignore_errors = True\n\n[flake8]\nmax-line-length = 100\n"
  },
  "RTKConsortium/RTK": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\n# Configure wheel name if CUDA is used\nwheel_name='itk-rtk'\nwheel_requirements=[r'itk>=5.3.0']\n\n# Extract cuda version from the RTK_CUDA_VERSION cmake option\nfor arg in sys.argv:\n  if \"RTK_CUDA_VERSION\" in str(arg):\n    cuda_version = arg.rsplit('RTK_CUDA_VERSION=', 1)[-1]\n    wheel_name += '-cuda' + cuda_version.replace('.', '')\n    cudacommon_wheel_name = wheel_name.replace('rtk', 'cudacommon')\n    wheel_requirements.append(fr'{cudacommon_wheel_name}')\n\nsetup(\n    name=wheel_name,\n    version='2.4.1',\n    author='RTK Consortium',\n    author_email='rtk-users@openrtk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/RTKConsortium/RTK',\n    description=r'The Reconstruction Toolkit (RTK) for fast circular cone-beam CT reconstruction.',\n    long_description='Based on the Insight Toolkit ITK, RTK provides: basic operators for reconstruction (e.g. filtering, forward, projection and backprojection), multithreaded CPU and GPU versions, tools for respiratory motion correction, I/O for several scanners, preprocessing of raw data for scatter correction.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    scripts=[\n        \"lib/rtkorageometry.py\",\n        \"lib/rtksimulatedgeometry.py\",\n        \"lib/rtkvarianobigeometry.py\",\n        \"lib/rtkelektasynergygeometry.py\"\n        ],\n    license='Apache',\n    keywords='RTK Reconstruction Toolkit',\n    url=r'https://www.openrtk.org/',\n    install_requires=wheel_requirements\n    )\n"
  },
  "Erotemic/xdoctest": {
    "tests/pybind11_test/setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\npip install --target=\"$(pwd)\" .\n\"\"\"\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\nif __name__ == '__main__':\n    setup(\n        name=\"my_ext\",\n        install_requires=['scikit-build', 'cmake', 'pybind11'],\n        packages=find_packages('.'),\n    )\n"
  },
  "Kitware/kwiver": {
    "CMake/kwiver-setup-python.cmake": "###\n# Finds the python binaries, libs, include, and site-packages paths\n#\n# The purpose of this file is to export variables that will be used in\n# kwiver/CMake/utils/kwiver-utils-python.cmake and\n# kwiver/sprokit/conf/sprokit-macro-python.cmake (the latter will eventually be\n# consolidated into the former)\n#\n# User options defined in this file:\n#\n#    KWIVER_PYTHON_MAJOR_VERSION\n#      The major python version to target (either 2 or 3)\n#\n#\n# Calls find_packages to on python interpreter/libraries which defines:\n#\n#    PYTHON_EXECUTABLE\n#    PYTHON_INCLUDE_DIR\n#    PYTHON_LIBRARY\n#    PYTHON_LIBRARY_DEBUG\n#\n# Exported variables used by python utility functions are:\n#\n#    PYTHON_VERSION\n#      the major/minor python version\n#\n#    PYTHON_ABI_FLAGS\n#      Python abstract binary interface flags (used internally for defining\n#      subsequent variables, but settable by the user as an advanced setting)\n#\n#    python_site_packages\n#      Location where python packages are installed relative to your python\n#      install directory. For example:\n#        Windows system install: Lib\\site-packages\n#        Debian system install: lib/python2.7/dist-packages\n#        Debian virtualenv install: lib/python3.5/site-packages\n#\n#    python_sitename\n#      The basename of the python_site_packages directory. This is either\n#      site-packages (in most cases) or dist-packages (if your python was\n#      configured by a debian package manager). If you are using a python\n#      virtualenv (you should be) then this will be site-packages\n#\n#    kwiver_python_subdir\n#      basename of the python lib folder (that contains site-packages).\n#      Depends on the python major/minor version and the ABI flags\n#      (e.g. python2.7, python3.5m)\n#\n#    kwiver_python_output_path\n#      The location in the build tree to copy/symlink python modules Depends on\n#      the value of `kwiver_python_subdir`.\n#      (e.g. build/lib/python2.7, build/lib/python3.5m)\n#\n#    kwiver_python_install_path\n#      The base location in the install tree where python files/modules are\n#      to be installed.\n#      (e.g. ${CMAKE_INSTALL_PREFIX}/lib/python3)\n#\n#    sprokit_python_output_path\n#      Similar to `kwiver_python_output_path`. Used by sprokit to define extra\n#      python output paths. This may be removed in the future.\n#      (e.g. build/lib)\n#\n\n###\n# Private helper function to execute `python -c \"<cmd>\"`\n#\n# Runs a python command and populates an outvar with the result of stdout.\n# Be careful of indentation if `cmd` is multiline.\n#\nfunction(_pycmd outvar cmd)\n  execute_process(\n    COMMAND \"${PYTHON_EXECUTABLE}\" -c \"${cmd}\"\n    RESULT_VARIABLE _exitcode\n    OUTPUT_VARIABLE _output)\n  if(NOT ${_exitcode} EQUAL 0)\n    message(ERROR \"Failed when running python code: \\\"\\\"\\\"\n${cmd}\\\"\\\"\\\"\")\n    message(FATAL_ERROR \"Python command failed with error code: ${_exitcode}\")\n  endif()\n  # Remove supurflous newlines (artifacts of print)\n  string(STRIP \"${_output}\" _output)\n  set(${outvar} \"${_output}\" PARENT_SCOPE)\nendfunction()\n\n\n###\n# Python major version user option\n#\n\n# Respect the PYTHON_VERSION_MAJOR version if it is set\nif (PYTHON_VERSION_MAJOR)\n  set(DEFAULT_PYTHON_MAJOR ${PYTHON_VERSION_MAJOR})\nelse()\n  set(DEFAULT_PYTHON_MAJOR \"3\")\nendif()\n\n\nset(KWIVER_PYTHON_MAJOR_VERSION \"${DEFAULT_PYTHON_MAJOR}\" CACHE STRING \"Python version to use: 3 or 2\")\nset_property(CACHE KWIVER_PYTHON_MAJOR_VERSION PROPERTY STRINGS \"3\" \"2\")\n\n\n###\n# Detect major version change (part1)\n#\n# Clear cached variables when the user changes major python versions.\n# When this happens, we need to re-find the bin, include, and libs\n#\nif (NOT __prev_kwiver_pyversion STREQUAL KWIVER_PYTHON_MAJOR_VERSION)\n  # but dont clobber initial settings in the instance they are specified via\n  # commandline (e.g  cmake -DPYTHON_EXECUTABLE=/my/special/python)\n  if (__prev_kwiver_pyversion)\n    message(STATUS \"The Python version changed; refinding the interpreter\")\n    message(STATUS \"The previous Python version was: \\\"${__prev_kwiver_pyversion}\\\"\")\n    unset(__prev_kwiver_pyversion CACHE)\n    unset(PYTHON_EXECUTABLE CACHE)\n    unset(PYTHON_INCLUDE_DIR CACHE)\n    unset(PYTHON_LIBRARY CACHE)\n    unset(PYTHON_LIBRARY_DEBUG CACHE)\n    unset(PYTHON_ABIFLAGS CACHE)\n  endif()\nendif()\n\n\n###\n#\n# Mark the previous version so we can determine when python versions change\n#\nset(__prev_kwiver_pyversion \"${KWIVER_PYTHON_MAJOR_VERSION}\" CACHE INTERNAL\n  \"allows us to determine if the user changes python version\")\n\n###\n# Python interpreter and libraries\n#\nif (KWIVER_PYTHON_MAJOR_VERSION STREQUAL \"3\")\n  # note, 3.4 is a minimum version\n  find_package(PythonInterp 3.4 REQUIRED)\n  find_package(PythonLibs 3.4 REQUIRED)\nelse()\n  find_package(PythonInterp 2.7 REQUIRED)\n  find_package(PythonLibs 2.7 REQUIRED)\nendif()\ninclude_directories(SYSTEM ${PYTHON_INCLUDE_DIR})\n\n\n###\n# Python site-packages\n#\n# Get canonical directory for python site packages (relative to install\n# location).  It varys from system to system.\n#\n_pycmd(python_site_packages \"from distutils import sysconfig; print(sysconfig.get_python_lib(prefix=''))\")\nmessage(STATUS \"python_site_packages = ${python_site_packages}\")\n\n# Current usage determines most of the path in alternate ways.\n# All we need to supply is the '*-packages' directory name.\n# Customers could be converted to accept a larger part of the path from this function.\nget_filename_component(python_sitename ${python_site_packages} NAME)\n\n###\n# Python install path\nset(kwiver_python_install_path \"${CMAKE_INSTALL_PREFIX}/${python_site_packages}\")\nmessage(STATUS \"kwiver_python_install_path = ${kwiver_python_install_path}\")\n\n###\n# Python major/minor version\n#\n# Use the executable to find the major/minor version.\n# If you want to change this, then change the executable.\n#\n_pycmd(PYTHON_VERSION \"import sys; print(sys.version[0:3])\")\n# assert that the right python version was found\nif(NOT PYTHON_VERSION MATCHES \"^${KWIVER_PYTHON_MAJOR_VERSION}.*\")\n  message(STATUS \"KWIVER_PYTHON_MAJOR_VERSION = ${KWIVER_PYTHON_MAJOR_VERSION}\")\n  message(STATUS \"PYTHON_VERSION = ${PYTHON_VERSION}\")\n  message(FATAL_ERROR \"Requested python \\\"${KWIVER_PYTHON_MAJOR_VERSION}\\\" but got \\\"${PYTHON_VERSION}\\\"\")\nendif()\n\n\n###\n# Python ABI Flags\n#\n# See PEP 3149 - ABI (application binary interface) version tagged .so files\n# https://www.python.org/dev/peps/pep-3149/\n#\nif (KWIVER_PYTHON_MAJOR_VERSION STREQUAL \"3\")\n  # In python 3, we can determine what the ABI flags are\n  _pycmd(_python_abi_flags \"from distutils import sysconfig; print(sysconfig.get_config_var('ABIFLAGS'))\")\nelse()\n  # Not sure if ABI flags are easilly found (or are even used in python2)\n  set(_python_abi_flags, \"\")\nendif()\nset(PYTHON_ABIFLAGS \"${_python_abi_flags}\"\n  CACHE STRING \"The ABI flags for the version of Python being used\")\nmark_as_advanced(PYTHON_ABIFLAGS)\n\n\n###\n# Python dependencies\n#\n# Add python packages needed to execute the bindings\n# to requirements.txt file\n#\nlist(APPEND PYTHON_REQS \"numpy>=1.13.0,<=1.19.0\" \"six>=1.10.0,<=1.13.0\")\n\nif(SKBUILD)\n  list(APPEND PYTHON_REQS \"scikit-build<=0.11.1\")\nendif()\n\nif(KWIVER_ENABLE_PYTORCH)\n  list(APPEND PYTHON_REQS \"opencv-python>=3.4.2.17,<=4.0.0\"\n                          \"pillow>=7.0.0,<=7.1.2\"\n                          \"scipy>=1.2,<=1.5\"\n                          \"torch==1.4.0\"\n                          \"torchvision==0.5.0\"\n                        )\nendif()\n\n\n###\n# PyBind11\n#\n#\n#\n  set(pybind11_library     python)\n  find_package(pybind11)\n\n\n###\n# Python Dependencies\n#\n# sets the python dependencies defined in python/requirements.txt\n# to be a custom command of the python libraries target\n# a venv will be created to encapsulate the pip installed dependencies\n# from the larger system, while still providing the tests access to their dependencies\n#\n\nif (KWIVER_ENABLE_TESTS)\n\n  message(STATUS \"KWIVER_PYTHON and KWIVER_TESTING enabled.\")\n  message(STATUS \"Python tests will be added to CTest.\")\n  message(STATUS \"Tests are executed by PYTEST, for sucessful test execution, please install the appropriate pytest for your python distribution.\")\n  message(STATUS \"Testing dependencies will be added to Python requirements.\")\n  set(PYTHON_TEST 1)\n  set(PYTHON_REQS \"${PYTHON_REQS};nose>1.2;coverage>=4.4.1,<5.0.0;pytest>=4.6,<=6.0;multimethod>=1.2,<=1.4\")\n\nendif()\n\nstring(REPLACE \";\" \"\\n\" PYTHON_REQS \"${PYTHON_REQS}\")\nfile(WRITE ${KWIVER_BINARY_DIR}/python/requirements.txt \"${PYTHON_REQS}\")\n###\n# Python package build locations\n#\n# defines paths used to determine where the kwiver/sprokit/vital python\n# packages will be generated in the build tree. (TODO: python modules should\n# use a setup.py file to install themselves to the right location)\n#\n#set(kwiver_python_subdir \"python${PYTHON_VERSION}${PYTHON_ABIFLAGS}\")\n\n# Instead of contructing the directory with ABIFLAGS just use what python gives us\nget_filename_component(python_lib_subdir ${python_site_packages} DIRECTORY)\nget_filename_component(python_subdir ${python_lib_subdir} NAME)\nset(kwiver_python_subdir ${python_subdir})\nset(kwiver_python_output_path \"${KWIVER_BINARY_DIR}/${python_lib_subdir}\")\n\n# Currently needs to be separate because sprokit may have CONFIGURATIONS that\n# are placed between lib and `kwiver_python_subdir`\nset(sprokit_python_output_path \"${KWIVER_BINARY_DIR}/lib\")\n\nset(KWIVER_PYTHON_VERSION \"${PYTHON_VERSION}\" CACHE STRING \"\" )\nmark_as_advanced(KWIVER_PYTHON_VERSION)\n\n###\n# Status string for debugging\n#\nset(PYTHON_CONFIG_STATUS \"\nPYTHON_CONFIG_STATUS\n\n  * KWIVER_PYTHON_MAJOR_VERSION = \\\"${KWIVER_PYTHON_MAJOR_VERSION}\\\"\n\n  * PYTHON_EXECUTABLE = \\\"${PYTHON_EXECUTABLE}\\\"\n  * PYTHON_INCLUDE_DIR = \\\"${PYTHON_INCLUDE_DIR}\\\"\n  * PYTHON_LIBRARY = \\\"${PYTHON_LIBRARY}\\\"\n  * PYTHON_LIBRARY_DEBUG = \\\"${PYTHON_LIBRARY_DEBUG}\\\"\n\n  * PYTHON_ABIFLAGS = \\\"${PYTHON_ABIFLAGS}\\\"\n  * PYTHON_VERSION = \\\"${PYTHON_VERSION}\\\"\n\n  * python_site_packages = \\\"${python_site_packages}\\\"\n  * python_sitename = \\\"${python_sitename}\\\"\n\n  * kwiver_python_subdir = \\\"${kwiver_python_subdir}\\\"\n  * kwiver_python_install_path = \\\"${kwiver_python_install_path}\\\"\n  * kwiver_python_output_path = \\\"${kwiver_python_output_path}\\\"\n  * sprokit_python_output_path = \\\"${sprokit_python_output_path}\\\"\n\")\n\nmessage(STATUS \"${PYTHON_CONFIG_STATUS}\")\n",
    "python/setup.py": "# ckwg +29\n# Copyright 2019-2020 by Kitware, Inc.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n#  * Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n#\n#  * Redistributions in binary form must reproduce the above copyright notice,\n#    this list of conditions and the following disclaimer in the documentation\n#    and/or other materials provided with the distribution.\n#\n#  * Neither name of Kitware, Inc. nor the names of any contributors may be used\n#    to endorse or promote products derived from this software without specific\n#    prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR\n# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n\n\n\nfrom skbuild import setup\nimport os.path as osp\nimport os\nfrom setuptools import find_packages\n\nkwiver_install_dir = 'kwiver'\nkwiver_source_dir = '../'\n\nwith open('VERSION', 'r') as f:\n    version = f.read().strip()\n\nwith open(os.path.join(kwiver_source_dir, 'README.rst'), 'r') as f:\n    long_description = f.read()\n\nsetup(\n        name='kwiver',\n        version=version,\n        description='Python and C++ toolkit that pulls together computer vision algorithms '\n                     ' into highly modular run time configurable systems',\n        long_description=long_description,\n        author='Kitware, Inc.',\n        author_email='kwiver-developers@kitware.com',\n        url='https://github.com/Kitware/kwiver',\n        cmake_install_dir=kwiver_install_dir,\n        cmake_source_dir=kwiver_source_dir,\n        license='BSD 3-Clause',\n        classifiers=[\n            'Intended Audience :: Developers',\n            'Intended Audience :: Science/Research',\n            'License :: OSI Approved :: BSD License',\n            'Programming Language :: Python :: 3.5',\n            'Programming Language :: Python :: 3.6',\n            'Programming Language :: Python :: 3.7',\n            'Programming Language :: Python :: 3.8',\n            'Operating System :: Unix',\n            'Topic :: Scientific/Engineering :: Artificial Intelligence',\n            ],\n        platforms=[\n                   'linux',\n                   'Unix',\n                   ],\n        cmake_minimum_required_version='3.3',\n        packages = find_packages(\n            exclude=['test-*', 'kwiver.sprokit.util'],\n            include=['kwiver*', 'vital*', 'sprokit*'],\n        ),\n        python_requires='>=3.5',\n        setup_requires=[\n                        'setuptools',\n                        'cmake',\n                        'scikit-build',\n                       ],\n        install_requires=[\n                          'numpy',\n                          'opencv-python',\n                          'pillow',\n                          'scipy',\n                          'six',\n                          'torch',\n                          'torchvision',\n                         ],\n        tests_require=[\n                        'nose',\n                        'mock',\n                        'coverage',\n                        'external_arrow',\n                        'pytest',\n                      ],\n        cmake_args=[\n                    '-DCMAKE_BUILD_TYPE=Release',\n                    '-DKWIVER_BUILD_SHARED=OFF',\n                    '-DKWIVER_ENABLE_C_BINDINGS=ON',\n                    '-DKWIVER_ENABLE_PYTHON=ON',\n                    '-DKWIVER_ENABLE_PYTORCH=ON',\n                    '-DKWIVER_PYTHON_MAJOR_VERSION=3',\n                    '-DPYBIND11_PYTHON_VERSION=3',\n                    '-DCMAKE_BUILD_WITH_INSTALL_RPATH=ON',\n                    '-DKWIVER_ENABLE_SPROKIT=ON',\n                    '-DKWIVER_ENABLE_ARROWS=ON',\n                    '-DKWIVER_ENABLE_PROCESSES=ON',\n                    '-DKWIVER_ENABLE_TOOLS=ON',\n                    '-DKWIVER_ENABLE_LOG4CPLUS=ON',\n                    '-DKWIVER_INSTALL_SET_UP_SCRIPT=OFF',\n                    '-DKWIVER_ENABLE_OPENCV=ON',\n                    '-DKWIVER_ENABLE_FFMPEG=ON',\n                    '-DKWIVER_ENABLE_ZeroMQ=ON',\n                    '-DKWIVER_ENABLE_SERIALIZE_JSON=ON',\n                    '-DKWIVER_ENABLE_SERIALIZE_PROTOBUF=ON',\n                   ],\n        entry_points={\n            'kwiver.python_plugin_registration': [\n                'pythread_process=kwiver.sprokit.schedulers.pythread_per_process',\n                'apply_descriptor=kwiver.sprokit.processes.apply_descriptor',\n                'process_image=kwiver.sprokit.processes.process_image',\n                'print_number_process=kwiver.sprokit.processes.kw_print_number_process',\n                'homography_writer=kwiver.sprokit.processes.homography_writer',\n                'simple_homog_tracker=kwiver.sprokit.processes.simple_homog_tracker',\n                'alexnet_descriptors=kwiver.sprokit.processes.pytorch.alexnet_descriptors',\n                'resnet_augmentation=kwiver.sprokit.processes.pytorch.resnet_augmentation',\n                'resnet_descriptors=kwiver.sprokit.processes.pytorch.resnet_descriptors',\n                'srnn_tracker=kwiver.sprokit.processes.pytorch.srnn_tracker',\n                'simple_object_detector=kwiver.vital.tests.alg.simple_image_object_detector'\n                ],\n            'kwiver.cpp_search_paths': [\n                'sprokit_process=kwiver.vital.util.entrypoint:sprokit_process_path',\n                'applets=kwiver.vital.util.entrypoint:applets_path',\n                'plugin_explorer=kwiver.vital.util.entrypoint:plugin_explorer_path'\n                ],\n            'kwiver.env.ld_library_path': [\n                'kwiver_ld_library_path=kwiver.vital.util.entrypoint:get_library_path',\n                ],\n            'kwiver.env.logger_factory': [\n                'vital_log4cplus_logger_factory=kwiver.vital.util.entrypoint:get_vital_logger_factory',\n                ],\n            'console_scripts': [\n                'plugin_explorer=kwiver.kwiver_tools:plugin_explorer',\n                'kwiver=kwiver.kwiver_tools:kwiver',\n                ],\n        },\n    )\n"
  },
  "OpenVoiceOS/ovos-buildroot": {
    "buildroot-external/board/ovos/raspberrypi/rootfs-overlay/base/home/mycroft/.local/setup.py": "import os\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\nabout = {}\nwith open(os.path.join(here, 'src', 'h3', '_version.py')) as f:\n    exec(f.read(), about)\n\n\ndef long_desc():\n    here = os.path.abspath(os.path.dirname(__file__))\n    fname = os.path.join(here, 'readme.md')\n    with open(fname) as f:\n        long_description = f.read()\n\n    return long_description\n\n\nsetup(\n    name = 'h3',\n    version = about['__version__'],\n    description = about['__description__'],\n    long_description = long_desc(),\n    long_description_content_type = 'text/markdown',\n    license = about['__license__'],\n    author = about['__author__'],\n    author_email = about['__author_email__'],\n    url = about['__url__'],\n    classifiers = about['__classifiers__'],\n    include_package_data=True,\n    packages = find_packages(\n        'src',\n        exclude = [\"*.tests\", \"*.tests.*\", \"tests.*\", \"tests\"],\n    ),\n    package_dir = {'': 'src'},\n    cmake_languages = ('C'),\n    extras_require={\n        'numpy': ['numpy'],\n        'test': ['pytest', 'pytest-cov', 'flake8', 'pylint'],\n        'all': ['numpy', 'pytest', 'pytest-cov', 'flake8', 'pylint'],\n    },\n)\n",
    "buildroot-external/board/ovos/raspberrypi/rootfs-overlay/base/home/mycroft/.local/pyproject.toml": "[build-system]\nrequires = [\n    'scikit-build',\n    'cython',\n    'cmake',\n]\n"
  },
  "ALIGN-analoglayout/ALIGN-public": {
    "setup.py": "import sys\nimport os\n\ntry:\n    from skbuild import setup\n    from setuptools import find_packages\nexcept ImportError:\n    raise AssertionError(\"Use pip 10+, or install pyproject.toml requirements yourself\")\n\n\ndef get_version(pkg_path):\n    with open(os.path.join(pkg_path, '__init__.py'), 'r') as fp:\n        for line in fp:\n            if line.startswith('__version__'):\n                return line.split('\"' if '\"' in line else \"'\")[1]\n\n\ndef get_readme_text():\n    with open(\"README.md\", \"r\", encoding=\"utf8\") as fp:\n        long_description = fp.read()\n    return long_description\n\n\ndef align_manifest_filter(cmake_manifest):\n    '''\n    Pick out all generated *.so* & test_* files\n    '''\n    return list(filter(lambda name: 'test_' in name or '.so' in name or '.py' in name, cmake_manifest))\n\n\nversion = get_version(\n    os.path.join(\n        os.path.abspath(os.path.dirname(__file__)),\n        'align'))\ncmake_args = [f\"-DALIGN_VERSION:string={version}\"]\n\n# Enable unit-tests for all in-place builds (pip install -e . --no-build-isolation)\ndevmode = 'develop' in sys.argv\n# if devmode and not any(x.startswith('-DBUILD_TESTING') for x in sys.argv):\n#     cmake_args.append('-DBUILD_TESTING=ON')\nif devmode and not any(x.startswith('--build-type') for x in sys.argv):\n    sys.argv.extend(['--build-type', 'Debug'])\n\nsetup(name='align',\n      version=version,\n      description='Analog Layout Synthesis Package',\n      long_description=get_readme_text(),\n      long_description_content_type=\"text/markdown\",\n      url='ALIGN-analoglayout/ALIGN-public.git',\n      author='Parijat Mukherjee',\n      author_email='parijat.mukherjee@intel.com',\n      license='BSD-3-Clause',\n      packages=find_packages(include=['align', 'align.*'])\n      + (['tests'] if devmode else []),\n      package_data={\n          'align': [\n              'config/*',\n              'pdk/finfet/*.json',\n              'pdk/finfet/*.sp'\n          ]\n      },\n      cmake_args=cmake_args,\n      cmake_process_manifest_hook=align_manifest_filter,\n      scripts=[\n          'bin/schematic2layout.py',\n          'bin/gds2png.sh',\n          'bin/analyze_regression.py',\n          'bin/convert_lef_to_layout_json.py',\n          'bin/gen_gds_from_json.py',\n          'bin/gen_lef_with_obs.py',\n          'bin/gen_primitive_from_gds.py'\n      ],\n      install_requires=[\n          'networkx>=2.4',\n          'python-gdsii',\n          'gdspy',\n          'pyyaml',\n          'pybind11',\n          'pydantic>=1.9.2',\n          'z3-solver',\n          'mip',\n          'more-itertools',\n          'colorlog',\n          'plotly',\n          'numpy',\n          'pandas',\n          'werkzeug',\n          'dash',\n          'typing_extensions; python_version<\"3.8\"',\n          'memory_profiler',\n          'flatdict',\n          'mip'\n      ],\n      extras_require={\n          'test': [\n              'pytest',\n              'pytest-cov',\n              'pytest-xdist',\n              'pytest-timeout',\n              'pytest-cpp'\n          ]\n      },\n      python_requires='>=3.7',\n      classifiers=[\n          'Development Status :: 2 - Pre-Alpha',\n          'Environment :: Console',\n          'Intended Audience :: Science/Research',\n          'License :: OSI Approved :: BSD License',\n          'Operating System :: OS Independent',\n          'Programming Language :: Python :: 3.8',\n          'Programming Language :: C++',\n          'Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)'\n      ],\n      zip_safe=False)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"pybind11\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "huggingface/simulate": {
    "setup.py": "# Lint as: python3\n\"\"\" HuggingFace/simulate is an open library of simulation and synthetic environments.\n\nNote:\n\n    VERSION needs to be formatted following the MAJOR.MINOR.PATCH convention\n    (we need to follow this convention to be able to retrieve versioned scripts)\n\nSimple check list for release from AllenNLP repo: https://github.com/allenai/allennlp/blob/main/setup.py\n\nTo create the package for pypi.\n\n0. Prerequisites:\n    - Dependencies:\n      - twine: \"pip install twine\"\n    - Create an account in (and join the 'simulate' project):\n      - PyPI: https://pypi.org/\n      - Test PyPI: https://test.pypi.org/\n\n1. Change the version in:\n    - __init__.py\n    - setup.py\n\n2. Commit these changes: \"git commit -m 'Release: VERSION'\"\n\n3. Add a tag in git to mark the release: \"git tag VERSION -m 'Add tag VERSION for pypi'\"\n    Push the tag to remote: git push --tags origin main\n\n4. Build both the sources and the wheel. Do not change anything in setup.py between\n    creating the wheel and the source distribution (obviously).\n\n    First, delete any \"build\" directory that may exist from previous builds.\n\n    For the wheel, run: \"python setup.py bdist_wheel\" in the top level directory.\n    (this will build a wheel for the python version you use to build it).\n\n    For the sources, run: \"python setup.py sdist\"\n    You should now have a /dist directory with both .whl and .tar.gz source versions.\n\n5. Check that everything looks correct by uploading the package to the pypi test server:\n\n    twine upload dist/* -r pypitest --repository-url=https://test.pypi.org/legacy/\n\n    Check that you can install it in a virtualenv/notebook by running:\n    pip install -i https://testpypi.python.org/pypi simulate\n\n6. Upload the final version to actual pypi:\n    twine upload dist/* -r pypi\n\n7. Fill release notes in the tag in GitHub once everything is looking hunky-dory.\n\n8. Change the version in __init__.py and setup.py to X.X.X+1.dev0 (e.g. VERSION=1.18.3 -> 1.18.4.dev0).\n    Then push the change with a message 'set dev version'\n\"\"\"\nfrom skbuild import setup\n\nimport numpy as np\nfrom glob import glob\n\n# Available at setup time due to pyproject.toml\n# from pybind11.setup_helpers import Pybind11Extension, build_ext\n\nfrom setuptools import find_packages\nimport sys\n\n__version__ = \"0.1.3.dev0\"  # expected format is one of x.y.z.dev0, or x.y.z.rc1 or x.y.z (no to dashes, yes to dots)\n\nREQUIRED_PKGS = [\n    \"dataclasses_json\",  # For GLTF export/imports\n    \"numpy>=1.18\",  # We use numpy>=1.17 to have np.random.Generator\n    \"vtk>=9.0\",  # Pyvista doesn't always install vtk, so we do it here\n    \"pyvista>=0.35\",  # For mesh creation and edition and simple vizualization\n    \"huggingface_hub>=0.10\",  # For sharing objects, environments & trained RL policies\n    'pybind11>=2.10.0',  # For compiling extensions pybind11\n    'scikit-build>=0.5',  # For compiling extensions\n]\n\nRL_REQUIRE = [\n    \"gym==0.21.0\",  # For RL action spaces and API\n]\nSB3_REQUIRE = [\n    \"gym==0.21.0\",  # For RL action spaces and API\n    \"stable-baselines3\"\n]\n\nDEV_REQUIRE = [\n    \"gym==0.21.0\",  # For RL action spaces and API\n    \"stable-baselines3\",  # For training with SB3\n\n    # For background vizualization capabilities (could be optional - note than some Qt backend can have GPL license)\n    \"pyvistaqt\",\n    \"pyqt5\",  # You can also use PySide2, PyQt6 or PySide6 (see https://github.com/spyder-ide/qtpy#requirements)\n]\n\nTESTS_REQUIRE = [\n    \"pytest\",\n    \"pytest-xdist\",\n\n    \"gym\",  # For RL action spaces and API\n    \"stable-baselines3\",  # For training with SB3\n]\n\nDOCS_REQUIRE = [\n    \"s3fs\"\n]\n\nQUALITY_REQUIRE = [\"black[jupyter]~=22.0\", \"flake8>=3.8.3\", \"isort>=5.0.0\", \"pyyaml>=5.3.1\"]\n\nEXTRAS_REQUIRE = {\n    \"rl\": RL_REQUIRE,\n    \"sb3\": SB3_REQUIRE,\n    \"dev\": DEV_REQUIRE + TESTS_REQUIRE + QUALITY_REQUIRE,\n    \"test\": TESTS_REQUIRE,\n    \"quality\": QUALITY_REQUIRE,\n    \"docs\": DOCS_REQUIRE,\n}\n\nif sys.platform == 'darwin':\n    extra_compile_args = [\"-std=c++11\"]\n    extra_link_args = [\"-std=c++11\"]\n\nelse:\n    extra_compile_args = []\n    extra_link_args = []\n\n\nsetup(\n    name=\"simulate\",\n    version=__version__,\n    description=\"HuggingFace community-driven open-source library of simulation environments\",\n    long_description=open(\"README.md\", encoding=\"utf-8\").read(),\n    long_description_content_type=\"text/markdown\",\n    author=\"HuggingFace Inc.\",\n    author_email=\"thomas@huggingface.co\",\n    url=\"https://github.com/huggingface/simulate\",\n    download_url=\"https://github.com/huggingface/simulate/tags\",\n    license=\"Apache 2.0\",\n    package_dir={\"\": \"src\"},\n    packages=find_packages(\"src\"),\n    include_package_data=True,\n    package_data={'simulate': ['src/simulate/engine/*.zip']},\n    install_requires=REQUIRED_PKGS,\n    extras_require=EXTRAS_REQUIRE,\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    ],\n    keywords=\"simulation environments synthetic data datasets machine learning\",\n    zip_safe=False,  # Required for mypy to find the py.typed file\n    python_requires=\">=3.8\",\n    include_dirs=[np.get_include()],\n    cmake_install_dir='src/simulate',\n)\n\n# When building extension modules `cmake_install_dir` should always be set to the\n# location of the package you are building extension modules for.\n# Specifying the installation directory in the CMakeLists subtley breaks the relative\n# paths in the helloTargets.cmake file to all of the library components.\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build\",\n    \"cmake>=3.22\",\n    \"pybind11>=2.10.0\",\n    \"numpy>=1.17\",\n    \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\ntest-command = \"python {project}/tests/test_scene.py\"\ntest-skip = \"*universal2:arm64\"",
    "setup.cfg": "[metadata]\nlicense_files = LICENSE\n\n[isort]\nensure_newline_before_comments = True\nforce_grid_wrap = 0\ninclude_trailing_comma = True\nline_length = 119\nlines_after_imports = 2\nmulti_line_output = 3\nuse_parentheses = True\n\n[flake8]\nignore = E203, E501, W503\nmax-line-length = 119\nper-file-ignores = __init__.py:F401, F403\n"
  },
  "nv-legate/legate.core": {
    "examples/reduction/setup.py": "#!/usr/bin/env python3\n\n# Copyright 2023 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\nimport os\nfrom pathlib import Path\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport legate.install_info as lg_install_info\n\nlegate_dir = Path(lg_install_info.libpath).parent.as_posix()\n\ncmake_flags = [\n    f\"-Dlegate_core_ROOT:STRING={legate_dir}\",\n]\n\nenv_cmake_args = os.environ.get(\"CMAKE_ARGS\")\nif env_cmake_args is not None:\n    cmake_flags.append(env_cmake_args)\nos.environ[\"CMAKE_ARGS\"] = \" \".join(cmake_flags)\n\n\nsetup(\n    name=\"Legate Reduction Tutorial\",\n    version=\"0.1\",\n    description=\"Reduction examples for Legate\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"reduction\", \"reduction.*\"],\n    ),\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=[\"cunumeric\", \"pyarrow>=5\"],\n)\n",
    "examples/hello/setup.py": "#!/usr/bin/env python3\n\n# Copyright 2023 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\nimport os\nfrom pathlib import Path\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport legate.install_info as lg_install_info\n\nlegate_dir = Path(lg_install_info.libpath).parent.as_posix()\n\ncmake_flags = [\n    f\"-Dlegate_core_ROOT:STRING={legate_dir}\",\n]\n\nenv_cmake_args = os.environ.get(\"CMAKE_ARGS\")\nif env_cmake_args is not None:\n    cmake_flags.append(env_cmake_args)\nos.environ[\"CMAKE_ARGS\"] = \" \".join(cmake_flags)\n\n\nsetup(\n    name=\"Legate Hello\",\n    version=\"0.1\",\n    description=\"A Hello World for Legate\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"hello\", \"hello.*\"],\n    ),\n    include_package_data=True,\n    zip_safe=False,\n)\n",
    "examples/io/setup.py": "#!/usr/bin/env python3\n\n# Copyright 2023 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\nimport os\nfrom pathlib import Path\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport legate.install_info as lg_install_info\n\nlegate_dir = Path(lg_install_info.libpath).parent.as_posix()\n\ncmake_flags = [\n    f\"-Dlegate_core_ROOT:STRING={legate_dir}\",\n]\n\nenv_cmake_args = os.environ.get(\"CMAKE_ARGS\")\nif env_cmake_args is not None:\n    cmake_flags.append(env_cmake_args)\nos.environ[\"CMAKE_ARGS\"] = \" \".join(cmake_flags)\n\n\nsetup(\n    name=\"Legate IO Tutorial\",\n    version=\"0.1\",\n    description=\"An IO example for Legate\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"legateio\", \"legateio.*\"],\n    ),\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=[\"cunumeric\"],\n)\n",
    "tests/integration/registry/setup.py": "#!/usr/bin/env python3\n\n# Copyright 2021-2022 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\nimport os\nfrom pathlib import Path\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport legate.install_info as lg_install_info\n\nlegate_dir = Path(lg_install_info.libpath).parent.as_posix()\n\ncmake_flags = [\n    f\"-Dlegate_core_ROOT:STRING={legate_dir}\",\n]\n\nenv_cmake_args = os.environ.get(\"CMAKE_ARGS\")\nif env_cmake_args is not None:\n    cmake_flags.append(env_cmake_args)\nos.environ[\"CMAKE_ARGS\"] = \" \".join(cmake_flags)\n\n\nsetup(\n    name=\"Task registration test\",\n    version=\"0.1\",\n    description=\"Task registration test\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"registry\", \"registry.*\"],\n    ),\n    include_package_data=True,\n    zip_safe=False,\n)\n",
    "tests/integration/scoping/setup.py": "#!/usr/bin/env python3\n\n# Copyright 2021-2022 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\nimport os\nfrom pathlib import Path\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport legate.install_info as lg_install_info\n\nlegate_dir = Path(lg_install_info.libpath).parent.as_posix()\n\ncmake_flags = [\n    f\"-Dlegate_core_ROOT:STRING={legate_dir}\",\n]\n\nenv_cmake_args = os.environ.get(\"CMAKE_ARGS\")\nif env_cmake_args is not None:\n    cmake_flags.append(env_cmake_args)\nos.environ[\"CMAKE_ARGS\"] = \" \".join(cmake_flags)\n\n\nsetup(\n    name=\"Resource scoping test\",\n    version=\"0.1\",\n    description=\"Resource scoping test\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"scoping\", \"scoping.*\"],\n    ),\n    include_package_data=True,\n    zip_safe=False,\n)\n",
    "setup.py": "#!/usr/bin/env python3\n\n# Copyright 2021-2022 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport versioneer\n\nsetup(\n    name=\"legate.core\",\n    version=versioneer.get_version(),\n    description=\"legate.core - The Foundation for All Legate Libraries\",\n    url=\"https://github.com/nv-legate/legate.core\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    extras_require={\n        \"test\": [\n            \"colorama\",\n            \"coverage\",\n            \"mock\",\n            \"mypy>=0.961\",\n            \"pynvml\",\n            \"pytest-cov\",\n            \"pytest\",\n        ]\n    },\n    packages=find_packages(\n        where=\".\",\n        include=[\n            \"legate\",\n            \"legate.*\",\n            \"legate.core\",\n            \"legate.core.*\",\n            \"legate.timing\",\n            \"legate.timing.*\",\n        ],\n    ),\n    include_package_data=True,\n    entry_points={\n        \"console_scripts\": [\n            \"legate = legate.driver:main\",\n            \"legate-jupyter = legate.jupyter:main\",\n            \"lgpatch = legate.lgpatch:main\",\n        ],\n    },\n    scripts=[\"bind.sh\"],\n    cmdclass=versioneer.get_cmdclass(),\n    install_requires=[\"numpy>=1.22\"],\n    zip_safe=False,\n)\n",
    "pyproject.toml": "# Copyright (c) 2021-2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nrequires = [\n    \"wheel\",\n    \"ninja\",\n    \"setuptools\",\n    \"scikit-build>=0.13.1\",\n    \"cmake>=3.22.1,!=3.23.0,!=3.25.0\",\n    \"cython\",\n]\n\n[tool.black]\nline-length = 79\ntarget-version = [\"py36\"]\ninclude = '\\.py?$'\nexclude = '''\n/(\n    \\.eggs |\n    \\.git |\n    \\.mypy_cache |\n    \\.tox |\n    \\.venv |\n    _build |\n    buck-out |\n    build |\n    dist\n)/\n'''\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"if TYPE_CHECKING:\",\n    \"@abstract\"\n]\n\n[tool.mypy]\npython_version = \"3.10\"\nmypy_path = \"typings/\"\n\npretty = true\nshow_error_codes = true\nshow_error_context = true\nshow_column_numbers = true\n\nnamespace_packages = true\nignore_missing_imports = false\n\ndisallow_any_unimported = true\ndisallow_any_expr = false\ndisallow_any_decorated = false\ndisallow_any_explicit = false\ndisallow_any_generics = true\ndisallow_subclassing_any = true\n\ndisallow_untyped_calls = true\ndisallow_untyped_defs = true\ndisallow_incomplete_defs = true\ncheck_untyped_defs = true\ndisallow_untyped_decorators = true\nno_implicit_optional = true\nstrict_optional = true\n\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_no_return = true\nwarn_return_any = false\nwarn_unreachable = true\n\nignore_errors = false\n\nallow_untyped_globals = false\nallow_redefinition = false\nimplicit_reexport = true\nstrict_equality = true\n\nwarn_unused_configs = true\n\nexclude = ['tests/examples', 'tests/integration']\n\n[[tool.mypy.overrides]]\n# ignore certain auto-generated and utility files\nmodule = [\n    \"legate._version\",\n    \"legate.__main__\",\n    \"legate.install_info\",\n    \"legate._sphinxext.*\",\n]\nignore_errors = true\n",
    "setup.cfg": "# Copyright (c) 2021-2022, NVIDIA CORPORATION.\n\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = legate/_version.py\nversionfile_build = legate/_version.py\ntag_prefix = v\nparentdir_prefix = legate-\n\n[options.packages.find]\nwhere = .\ninclude = legate*\nexclude = install_info\n\n[flake8]\nexclude = __init__.py\nignore =\n    # line break before binary operator\n    W503\n    # whitespace before :\n    E203\n\n[isort]\nline_length=79\nmulti_line_output=3\ninclude_trailing_comma=True\nforce_grid_wrap=0\ncombine_as_imports=True\norder_by_type=True\nknown_third_party=\n    numpy\nknown_legion=\n    legion_cffi\n    legion_top\nknown_first_party=\n    legate.core\ndefault_section=THIRDPARTY\nsections=FUTURE,STDLIB,THIRDPARTY,LEGION,FIRSTPARTY,LOCALFOLDER\nskip=\n    .eggs\n    .git\n    .mypy_cache\n    .tox\n    .venv\n    _build\n    build\n    dist\n    __init__.py\nskip_glob=\n    legion/*\n    install/*\n\n\n[options]\npackages = find:\ninstall_requires =\n    numpy>=1.22\n    # TODO: Add rest of install dependencies\npython_requires = >=3.9,!=3.9.7\n",
    "tests/integration/tree_reduce/setup.py": "#!/usr/bin/env python3\n\n# Copyright 2021-2022 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\nimport os\nfrom pathlib import Path\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport legate.install_info as lg_install_info\n\nlegate_dir = Path(lg_install_info.libpath).parent.as_posix()\n\ncmake_flags = [\n    f\"-Dlegate_core_ROOT:STRING={legate_dir}\",\n]\n\nenv_cmake_args = os.environ.get(\"CMAKE_ARGS\")\nif env_cmake_args is not None:\n    cmake_flags.append(env_cmake_args)\nos.environ[\"CMAKE_ARGS\"] = \" \".join(cmake_flags)\n\n\nsetup(\n    name=\"Tree reduction test\",\n    version=\"0.1\",\n    description=\"Tree reduction test\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"tree_reduce\", \"tree_reduce.*\"],\n    ),\n    include_package_data=True,\n    zip_safe=False,\n)\n"
  },
  "YoungXIAO13/PoseFromShape": {
    "data/virtual_scanner/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"ocnn.virtualscanner\",\n    version=\"18.09.05\",\n    description=\"Virtual scanner utilities\",\n    author='Microsoft',\n    author_email=\"dapisani@microsoft.com\",\n    packages=['ocnn', 'ocnn.virtualscanner'],\n    zip_safe=False,\n    install_requires=['Cython', 'pyyaml'],\n    package_dir={'': 'python'},\n    package_data={'ocnn.virtualscanner': ['*.pxd']}\n)\n"
  },
  "InsightSoftwareConsortium/itk-wasm": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-webassemblyinterface',\n    version='1.0b74',\n    author='Insight Software Consortium',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/itk-wasm',\n    description=r'IO with the itk-wasm file formats',\n    long_description='This package provides native binary interfaces to the itk-wasm file formats that can be used with itk.imread, itk.meshread, itk.transformread, itk.imwrite, etc. For execution of itk-wasm WASI binaries see itkwasm and itkwasm-* packages.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk-io>=5.3.0'\n    ]\n    )\n"
  },
  "rgl-epfl/cholespy": {
    "setup.py": "import sys\n\ntry:\n    from skbuild import setup\n    import nanobind\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nfrom setuptools import find_packages\n\n# read the contents of your README file (https://packaging.python.org/en/latest/guides/making-a-pypi-friendly-readme/)\nfrom pathlib import Path\nthis_directory = Path(__file__).parent\nreadme = (this_directory / \"README.md\").read_text()\n\nsetup(\n    name=\"cholespy\",\n    version=\"0.1.6\",\n    description=\"A self-contained sparse Cholesky solver, compatible with CPU and GPU tensor frameworks.\",\n    author=\"Baptiste Nicolet\",\n    license=\"BSD\",\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/cholespy\",\n    include_package_data=True,\n    python_requires=\">=3.8\",\n    long_description=readme,\n    long_description_content_type=\"text/markdown\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build==0.14.0\",\n    \"cmake>=3.18\",\n    \"nanobind>=0.0.7\",\n    \"ninja; platform_system!='Windows'\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "maxbachmann/Levenshtein": {
    "setup.py": "from skbuild import setup\n\nwith open('README.md', 'rt', encoding=\"utf8\") as f:\n    readme = f.read()\n\nsetup(\n    name=\"Levenshtein\",\n    version=\"0.21.0\",\n    url=\"https://github.com/maxbachmann/Levenshtein\",\n    author=\"Max Bachmann\",\n    install_requires=[\"rapidfuzz >= 2.3.0, < 4.0.0\"],\n    author_email=\"contact@maxbachmann.de\",\n    description=\"Python extension for computing string edit distances and similarities.\",\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n\n    license=\"GPL\",\n    license_file = \"COPYING\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)\"\n    ],\n\n    packages=[\"Levenshtein\"],\n    package_dir={'':'src'},\n    package_data={\n        \"Levenshtein\": [\"*.pyi\", \"py.typed\"]\n    },\n    python_requires=\">=3.6\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"scikit-build>=0.13.0\",\n    \"Cython>=3.0.0a11\"\n]\nbuild-backend = \"backend\"\nbackend-path = [\"_custom_build\"]\n"
  },
  "KaveIO/PhiK": {
    "setup.py": "\"\"\"Project: Phi_K - correlation coefficient package\n\nCreated: 2018/11/13\n\nDescription:\n    setup script to install Phi_K correlation package.\n\nAuthors:\n    KPMG Big Data team, Amstelveen, The Netherlands\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted according to the terms listed in the file\nLICENSE.\n\"\"\"\n\nimport sys\nfrom warnings import warn\nfrom setuptools import find_packages\nfrom setuptools import setup\nfrom skbuild import setup as sk_setup\nimport pybind11\n\nNAME = 'phik'\n\nMAJOR = 0\nREVISION = 12\nPATCH = 3\nDEV = False\n\n# note: also update README.rst, CHANGES.rst\n\nVERSION = '{major}.{revision}.{patch}'.format(major=MAJOR, revision=REVISION, patch=PATCH)\nFULL_VERSION = VERSION\nif DEV:\n    FULL_VERSION += '.dev'\n\nTEST_REQUIREMENTS = [\n    'pytest>=4.0.2',\n    'pytest-pylint>=0.13.0',\n    'nbconvert>=5.3.1',\n    'jupyter_client>=5.2.3',\n]\n\nREQUIREMENTS = [\n    'numpy>=1.18.0',\n    'scipy>=1.5.2',\n    'pandas>=0.25.1',\n    'matplotlib>=2.2.3',\n    'joblib>=0.14.1',\n]\n\nEXTRA_REQUIREMENTS = {\n    'test': TEST_REQUIREMENTS,\n}\n\nif DEV:\n    REQUIREMENTS += TEST_REQUIREMENTS\n\nEXCLUDE_PACKAGES = []\n\n# read the contents of readme file\nwith open(\"README.rst\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\n\ndef write_version_py(filename: str = 'phik/version.py') -> None:\n    \"\"\"Write package version to version.py.\n\n    This will ensure that the version in version.py is in sync with us.\n\n    :param filename: The version.py to write too.\n    :type filename: str\n    :return:\n    :rtype: None\n    \"\"\"\n    # Do not modify the indentation of version_str!\n    version_str = \"\"\"\\\"\\\"\\\"THIS FILE IS AUTO-GENERATED BY PHIK SETUP.PY.\\\"\\\"\\\"\n\nname = '{name!s}'\nversion = '{version!s}'\nfull_version = '{full_version!s}'\nrelease = {is_release!s}\n\"\"\"\n\n    with open(filename, 'w') as version_file:\n        version_file.write(\n            version_str.format(name=NAME.lower(), version=VERSION, full_version=FULL_VERSION, is_release=not DEV)\n        )\n\n\nsetup_args = {\n    'name': NAME,\n    'version': FULL_VERSION,\n    'url': 'http://phik.rtfd.io',\n    'license': 'Apache-2',\n    'author': 'KPMG N.V. The Netherlands',\n    'author_email': 'kave@kpmg.com',\n    'description': \"Phi_K correlation analyzer library\",\n    'long_description': long_description,\n    'long_description_content_type': \"text/x-rst\",\n    'python_requires': '>=3.7',\n    'packages': find_packages(exclude=EXCLUDE_PACKAGES),\n    # Setuptools requires that package data are located inside the package.\n    # This is a feature and not a bug, see\n    # http://setuptools.readthedocs.io/en/latest/setuptools.html#non-package-data-files\n    'package_data': {\n        NAME.lower(): ['data/*', 'notebooks/phik_tutorial*.ipynb', ]\n    },\n    'include_package_data': True,\n    'install_requires': REQUIREMENTS,\n    'extras_require': EXTRA_REQUIREMENTS,\n    'tests_require': TEST_REQUIREMENTS,\n    'zip_safe': False,\n    'classifiers': [\n        \"Programming Language :: Python :: 3\",\n        \"Operating System :: OS Independent\",\n        \"License :: OSI Approved :: Apache Software License\",\n    ],\n    # The following 'creates' executable scripts for *nix and Windows.\n    # As an added bonus the Windows scripts will auto-magically\n    # get a .exe extension.\n    #\n    # phik_trial: test application to let loose on tests. This is just a wrapper around pytest.\n    'entry_points': {\n        'console_scripts': [\n            'phik_trial = phik.entry_points:phik_trial'\n        ]\n    }\n}\n\nsk_build_kwargs = {\n    'cmake_args': [\n        f\"-Dpybind11_DIR:STRING={pybind11.get_cmake_dir()}\",\n        \"-DPYTHON_EXECUTABLE={}\".format(sys.executable),\n        f\"-DPHIK_VERSION_INFO={VERSION}\",\n    ]\n}\n\nif __name__ == '__main__':\n    write_version_py()\n    try:\n        # try building with C++ extension:\n        sk_setup(**setup_args, **sk_build_kwargs)\n    except Exception as ex:\n        warn(\n            '\\n---------------------------------------------\\n'\n            'WARNING\\n\\n'\n            'The Phi_K C++ extension could not be compiled\\n\\n'\n            f'{ex.__class__.__name__} {ex.__str__()}\\n\\n'\n            '\\n---------------------------------------------\\n'\n        )\n\n        # # Retry to install the module without extension :\n        # If this new 'setup' call doesn't fail, the module\n        # will be successfully installed, without the C++ extension :\n        setup(**setup_args)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build>=0.14.1\",\n    \"ninja; platform_system!='Windows'\",\n    \"cmake>=3.16\",\n    \"pybind11>=2.8.1\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "InsightSoftwareConsortium/ITKElastix": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\nimport os\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\npackage_name = 'itk-elastix'\nif 'ELASTIX_USE_OPENCL' in os.environ:\n    package_name = 'itk-elastix-opencl'\n\nsetup(\n    name=package_name,\n    version='0.17.1',\n    author='Insight Software Consortium',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKElastix',\n    description=r'Provides an ITK Python interface to elastix, a toolbox for rigid and nonrigid registration of images',\n    long_description='elastix is open source software, based on the well-known Insight Segmentation and Registration Toolkit (ITK). The software consists of a collection of algorithms that are commonly used to solve (medical) image registration problems. The modular design of elastix allows the user to quickly configure, test, and compare different registration methods for a specific application.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "MerginMaps/geodiff": {
    "setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom skbuild import setup\nimport platform\n\n# use scripts/update_version.py to update the version here and in other places at once\nVERSION = \"2.0.2\"\n\ncmake_args = [\n    '-DENABLE_TESTS:BOOL=OFF',\n    '-DENABLE_COVERAGE:BOOL=OFF',\n    '-DBUILD_TOOLS:BOOL=OFF',\n    '-DPEDANTIC:BOOL=OFF',\n    '-DPYGEODIFFVERSION='+str(VERSION)\n]\n\narch = platform.architecture()[0]  # 64bit or 32bit\nif ('Windows' in platform.system()) and (\"32\" in arch):\n    cmake_args.append('-AWin32')\n\nsetup(\n    name=\"pygeodiff\",\n    version=VERSION,\n    author=\"Lutra Consulting Ltd.\",\n    author_email=\"info@merginmaps.com\",\n    description=\"Python wrapper around GeoDiff library\",\n    long_description=\"Python wrapper around GeoDiff library\",\n    url=\"https://github.com/MerginMaps/geodiff\",\n    packages=[\"pygeodiff\"],\n    include_package_data=False,\n    keywords=[\"diff\", \"gis\", \"geo\", \"geopackage\", \"merge\"],\n    scripts=[],\n    entry_points={\"console_scripts\": [\"pygeodiff=pygeodiff.main:main\"]},\n    zip_safe=False,\n    cmake_args=cmake_args,\n    cmake_source_dir=\"geodiff\",\n    cmake_with_sdist=False,\n    test_suite=\"tests.test_project\",\n    python_requires=\">=3.7\",\n    license=\"License :: OSI Approved :: MIT License\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\"]\n"
  },
  "silnrsi/graphite": {
    "setup.py": "#!/usr/bin/env python\n# SPDX-License-Identifier: MIT OR MPL-2.0 OR LGPL-2.1-or-later OR GPL-2.0-or-later\n# Copyright 2018, SIL International, All rights reserved.\n\nfrom re import findall\nfrom os import path\nfrom io import open\ntry:\n    from skbuild import setup\nexcept ImportError:\n    from setuptools import setup\n\nhere = path.abspath(path.dirname(__file__))\nwith open(path.join(here, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\nwith open(path.join(here, 'include/graphite2/Font.h')) as f:\n    c_header = f.read()\nmajor, minor, bug = findall('define GR2_VERSION_[A-X]+\\s+(\\d+)', c_header)\nversion = major + \".\" + minor + \".\" + bug\n\nsetup(\n    name             = 'graphite2',\n    version          = version,\n    description      = 'SIL graphite2 smart font system python bindings',\n    author           = 'SIL International',\n    license          = 'LGPL-2.1+ OR MPL-2.0 OR GPL-2+',\n    url              = 'https://github.com/silnrsi/graphite',\n    zip_safe         = False,\n    package_dir      = {'': 'python'},\n    packages         = ['graphite2'],\n    install_requires = ['future'],\n    long_description = long_description,\n    long_description_content_type = 'text/markdown',\n    classifiers = [\n        'License :: OSI Approved :: GNU Library or Lesser General Public License v2 or later (LGPLv2+)',\n        'License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)',\n        'License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3'\n    ]\n)\n"
  },
  "opnsense/ports": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "NordicSemiconductor/pc-ble-driver-py": {
    "setup.py": "#\n# Copyright (c) 2016-2019 Nordic Semiconductor ASA\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification,\n# are permitted provided that the following conditions are met:\n#\n#   1. Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n#   2. Redistributions in binary form must reproduce the above copyright notice, this\n#   list of conditions and the following disclaimer in the documentation and/or\n#   other materials provided with the distribution.\n#\n#   3. Neither the name of Nordic Semiconductor ASA nor the names of other\n#   contributors to this software may be used to endorse or promote products\n#   derived from this software without specific prior written permission.\n#\n#   4. This software must only be used in or with a processor manufactured by Nordic\n#   Semiconductor ASA, or in or with a processor manufactured by a third party that\n#   is used in combination with a processor manufactured by Nordic Semiconductor.\n#\n#   5. Any software provided in binary or object form under this license must not be\n#   reverse engineered, decompiled, modified and/or disassembled.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\nimport sys\nimport re\nimport codecs\nimport os\n\nfrom skbuild import setup\nfrom setuptools import find_packages\n\nif sys.version_info < (3, 6):\n    print(\"pc-ble-driver-py only supports Python version 3.6 and newer\")\n    sys.exit(-1)\n\nrequirements = [\"wrapt\", \"cryptography\"]\n\nif os.path.exists(\"MANIFEST\"):\n    os.remove(\"MANIFEST\")\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n\ndef read(*parts):\n    # intentionally *not* adding an encoding option to open, See:\n    #   https://github.com/pypa/virtualenv/issues/201#issuecomment-3145690\n    with codecs.open(os.path.join(here, *parts), \"r\") as fp:\n        return fp.read()\n\n\ndef find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(\n        r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M,\n    )\n    if version_match:\n        return version_match.group(1)\n\n    raise RuntimeError(\"Unable to find version string.\")\n\n\npackages = find_packages(exclude=[\"tests*\"])\n\nsetup(\n    name=\"pc_ble_driver_py\",\n    version=find_version(\"pc_ble_driver_py\", \"__init__.py\"),\n    description=\"Python bindings for the Nordic pc-ble-driver SoftDevice serialization library\",\n    long_description=\"A Python interface and library for pc-ble-driver. This allows Python applications to interface \"\n    \"with a Nordic Semiconductor IC (both nRF51 and nRF52 series) over a serial port to obtain \"\n    \"access to the full serialized SoftDevice API.\",\n    url=\"https://github.com/NordicSemiconductor/pc-ble-driver-py\",\n    license=\"Modified BSD License\",\n    author=\"Nordic Semiconductor ASA\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Topic :: System :: Networking\",\n        \"Topic :: System :: Hardware :: Hardware Drivers\",\n        \"Topic :: Software Development :: Embedded Systems\",\n        \"License :: Other/Proprietary License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n    ],\n    keywords=\"nordic nrf51 nrf52 ble bluetooth softdevice serialization bindings pc-ble-driver pc-ble-driver-py \"\n    \"pc_ble_driver pc_ble_driver_py\",\n    python_requires=\">=3.7, <3.11\",\n    install_requires=requirements,\n    packages=packages,\n    package_data={\n        \"pc_ble_driver_py.lib\": [\"*.pyd\", \"*.dll\", \"*.txt\", \"*.so\", \"*.dylib\"],\n        \"pc_ble_driver_py.hex\": [\"*.hex\"],\n        \"pc_ble_driver_py.hex.sd_api_v2\": [\"*.hex\"],\n        \"pc_ble_driver_py.hex.sd_api_v5\": [\"*.hex\", \"*.zip\"],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"tox\"]\n\n[flake8]\nexclude = [\n    \"hex\",\n    \"__pycache__\",\n    \"lib\"\n]\n"
  },
  "GooFit/GooFit": {
    "setup.py": "#!/usr/bin/env python\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"Failed to find scikit-build, please run `pip install scikit-build`\")\n    raise\n\nimport os\n\nITEMS = [\n    \"-DGOOFIT_PYTHON=ON\",\n    \"-DGOOFIT_TESTS=OFF\",\n    \"-DGOOFIT_CERNROOT=OFF\",\n    \"-DGOOFIT_EXAMPLES=OFF\",\n    \"-DCMAKE_UNITY_BUILD=ON\",  # Faster build on CMake 3.16+\n]\n\n# Add GOOFIT_* from env.\nfor item in os.environ:\n    if item.startswith(\"GOOFIT_\"):\n        ITEMS.append(f\"-D{item}={os.environ[item]}\")\n\n\nsetup(\n    name=\"goofit\",\n    version=\"2.3.0\",\n    description=\"GooFit fitting package\",\n    provides=[\"goofit\"],\n    cmake_args=ITEMS,\n    packages=[\"goofit\"],\n    long_description=\"\"\"\\\nGooFit for Python\n-----------------\n\nGooFit is a highly parallel fitting framework originally designed for High Energy Physics.\n\nInstallation basics\n===================\n\nThis package can be installed with pip, but uses SciKit-Build, and is build,\nfully optimized, on your system. Because of this, there are a few caveats when\nrunning a pip install if you use an old version of pip. When you build, you\nshould also use pip's ``-v`` flag, so that you can see it build (and observe\nthe configuration options). Otherwise, you might wait a very long time without\noutput (especially if CUDA was found).\n\n\nInstallation: pip\n=================\n\nUsing pip 10+::\n\n    pip install -v goofit\n\nUsing pip < 10::\n\n    pip install scikit-build # optionally cmake ninja\n    pip install -v goofit\n\n\nGooFit will automatically look for CUDA, and build in GPU mode if it finds CUDA. You can pick a specific version by passing through a CMake option (see below), or by setting an environment variable, `GOOFIT_DEVICE` before building. You may want to build with OpenMP as a backend to avoid using your GPU, or you might want the CPP version if you are using Anaconda on macOS. Here are the three common backends::\n\n    GOOFIT_DEVICE=CUDA pip install -v goofit\n    GOOFIT_DEVICE=OMP pip install -v goofit\n    GOOFIT_DEVICE=CPP pip install -v goofit\n\nThe lines above use environment variables; GooFit will find any environment variables that start with ``GOOFIT_*`` and set them as CMake defines. If you want to send arbitrary commands to CMake through PIP, you will need to pass each option through, starting with a ``--`` option. Pip will try to reuse the built version if you do not pass options, but will rebuild if you pass options, so this works for a rebuild, unlike the lines above. This is how you would do this to set OMP as the backend::\n\n    pip install -v goofit --install-option=\"--\" --install-option=\"-DGOOFIT_DEVICE=OMP\"\n    # OR\n    PIP_INSTALL_OPTION=\"-- -DGOOFIT_DEVICE=OMP\" pip install -v goofit\n\n\nInstallation: local\n===================\n\nIf you want to add PDFs to GooFit, or use GooFit packages, you should be working in a local directory using git. In the following example, I'm assuming you've set up SSH keys with GitHub; you can use https instead if you prefer by changing the URL to ``https://github.com/GooFit/GooFit.git``::\n\n    git clone --recursive git@github.com:GooFit/GooFit.git\n    cd goofit\n\nLocal pip\n~~~~~~~~~\n\nThe normal install here works, though as usual you should include verbose output and you should be in a virtual environment (standard practice)::\n\n    pip install -v .\n\n\"\"\",\n)\n\n\n# Building a source package from git\n# ==================================\n#\n# For developers only:\n#\n# To make a source package, start with a clean (such as new) git GooFit package with all submodules checked out::\n#\n#     git clone --branch=master --recursive --depth=10 git@github.com:GooFit/GooFit.git\n#     cd goofit\n#     pipx run build --sdist\n#     pipx run twine upload dist/*\n#\n# To make a binary package, use instead::\n#\n#     GOOFIT_OPTI=\"\" pipx run build --wheel\n#\n# To set this up on Docker for linux, use::\n#\n#    docker run -it quay.io/pypa/manylinux1_x86_64 -v goofit-py:goofit-py\n#    export PATH=/opt/python/cp36-cp36m/bin:$PATH\n#    cd goofit-py\n#    python -m pip install scikit-build cmake build\n#    python setup.py bdist_wheel -- -DGOOFIT_OPTI=\"-march=core2\"\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"cmake>=3.20\",\n  \"ninja>=1.9\",\n  \"scikit-build>=0.13\",\n  \"setuptools>=42\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\naddopts = [\"-ra\", \"--showlocals\", \"--strict-markers\", \"--strict-config\"]\nxfail_strict = true\nfilterwarnings = [\"error\"]\nlog_cli_level = \"info\"\ntestpaths = [\"python/tests\"]\n\n[tool.ruff]\nselect = [\n  \"E\", \"F\", \"W\", # flake8\n  \"B\", \"B904\",   # flake8-bugbear\n  \"I\",           # isort\n  \"ARG\",         # flake8-unused-arguments\n  \"C4\",          # flake8-comprehensions\n  \"ISC\",         # flake8-implicit-str-concat\n  \"PGH\",         # pygrep-hooks\n  \"PIE\",         # flake8-pie\n  \"PL\",          # pylint\n  \"PT\",          # flake8-pytest-style\n  \"RET\",         # flake8-return\n  \"RUF\",         # Ruff-specific\n  \"SIM\",         # flake8-simplify\n  \"UP\",          # pyupgrade\n  \"YTT\",         # flake8-2020\n]\nignore = [\n  \"E402\",\n  \"E501\",\n  \"E722\",\n  \"F403\",\n  \"F405\",\n  \"PLR\",\n]\ntarget-version = \"py37\"\nexclude = []\nflake8-unused-arguments.ignore-variadic-names = true\nisort.known-first-party = [\"goofit\"]\nmccabe.max-complexity = 12\n",
    "setup.cfg": "[metadata]\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\n    License :: OSI Approved :: BSD License\n    Natural Language :: English\n    Operating System :: Unix\n    Programming Language :: C++\n    Programming Language :: Python\n    Programming Language :: Python :: 3 :: Only\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3.11\n    Topic :: Scientific/Engineering :: Physics\n\nproject_urls =\n    Homepage = https://goofit.github.io\n    Documentation = https://goofit.github.io/GooFit\n    Bug Tracker = https://github.com/scikit-hep/package/issues\n    Changelog = https://github.com/GooFit/GooFit/blob/master/docs/CHANGELOG.md\n\n[options]\npython_requires = >=3.6\ninstall_requires =\n    numpy >=1.13.3\n\n\n[options.extras_require]\ntest =\n    pytest>=6\ndev =\n    pytest>=6\n    matplotlib>=1.5\n    pandas>=0.15.1\n    uncertainties>=3.0.2\n    scipy\n    plumbum\n"
  },
  "fbertola/bgfx-python": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nimport io\nimport os\nimport sys\n\nfrom skbuild import setup\nfrom skbuild.constants import skbuild_plat_name\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\ntry:\n    with io.open(os.path.join(here, 'README.md'), encoding='utf-8') as f:\n        long_description = '\\n' + f.read()\nexcept FileNotFoundError:\n    long_description = \"\"\n\npackage_name = \"bgfx-python\"\nversion = \"2.0.1\"\ncmake_args = []\n\nif sys.platform == 'darwin':\n    plat_name = skbuild_plat_name()\n    sep = [pos for pos, char in enumerate(plat_name) if char == '-']\n    assert len(sep) == 2\n    cmake_args.extend(('-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=' + plat_name[sep[0] + 1:sep[1]],\n                       '-DCMAKE_OSX_ARCHITECTURES:STRING=' + plat_name[sep[1] + 1:]))\n\nsetup(\n    name=package_name,\n    version=version,\n    description='Python wrapper for BGFX Library',\n    author='Federico Bertola',\n    url='https://github.com/fbertola/bgfx-python',\n    packages=['pybgfx'],\n    cmake_source_dir=\"src\",\n    cmake_args=cmake_args,\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    python_requires=\">=3.7.0\",\n    include_package_data=True,\n    zip_safe=False,\n    license='BSD',\n    install_requires=[\n        'cppyy',\n        'clang',\n        'loguru'\n    ],\n    classifiers=[\n        'License :: OSI Approved :: BSD License',\n        'Intended Audience :: Developers',\n        'Operating System :: OS Independent',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Multimedia :: Graphics'\n    ],\n)\n",
    "pyproject.toml": "[tool.poetry]\nname = \"bgfx-python\"\nversion = \"1.0.5\"\ndescription = \"Python wrapper for BGFX Library\"\nauthors = [\n    \"Federico Bertola\"\n]\nlicense = \"MIT\"\n\nreadme = \"README.md\"\n\nrepository = \"https://github.com/fbertola/bgfx-python\"\n\nkeywords = [\"cpp\", \"bgfx\", \"opengl\", \"metal\", \"directx\", \"vulkan\"]\n\nclassifiers = [\n    \"License :: OSI Approved :: BSD License\",\n    \"Intended Audience :: Developers\",\n    \"Operating System :: OS Independent\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.6\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n    \"Topic :: Multimedia :: Graphics\"\n]\n\n[tool.poetry.dependencies]\npython = \"^3.7\"\nloguru = \"^0.5.1\"\ncppyy = \"^2.1.0\"\nclang = \"^11.0\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^5.4.3\"\npytest-mock = \"^1.9\"\nblack = \"^19.10b0\"\nflake8 = \"^3.8.3\"\nflake8-bandit = \"^2.1.2\"\nflake8-black = \"^0.2.0\"\nflake8-bugbear = \"^20.1.4\"\nflake8-import-order = \"^0.18.1\"\nsafety = \"^1.9.0\"\nnox = \"^2020.5.24\"\nglfw = \"^2.0.0\"\nnumpy = \"^1.19.0\"\npytest-sugar = \"^0.9.4\"\npillow = \"^8.2.0\"\ncmakelang = \"^0.6.13\"\n\n[tool.black]\nline-length = 88\ninclude = '\\.pyi?$'\nexclude = '''\n/(\n    \\.eggs\n  | \\.git\n  | \\.hg\n  | \\.mypy_cache\n  | \\.tox\n  | \\.venv\n  | _build\n  | buck-out\n  | build\n  | dist\n  | tests/.*/setup.py\n)/\n'''\n\n[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"loguru\", \"cppyy\", \"clang\"]\n\n\n"
  },
  "pyomeca/ezc3d": {
    "setup.py": "from skbuild import setup\nimport re\nimport os\ndir_path = os.path.dirname(os.path.realpath(__file__))\n\nwith open(f\"{dir_path}/CMakeLists.txt\") as file:\n    for line in file:\n        match = re.search(\"project\\(ezc3d VERSION ([0-9].[0-9].[0-9])\\)\", line)\n        if match is not None:\n            version = match[1]\n            break\n    else:\n        raise RuntimeError(\"Version not found\")\n\nsetup(\n    # NOTE: Could still add stuff like homepage or author mail, but since this isn't used to redistribute, not important\n    name=\"ezc3d\",\n    version=version,\n    description=\" Easy to use C3D reader/writer for C++, Python and Matlab\",\n    author=\"Michaud, Benjamin and Begon, Micka\u00ebl\",\n    license=\"MIT\",\n    packages=['ezc3d'],\n    cmake_args=[\n        '-DBUILD_EXAMPLE:BOOL=OFF',\n        '-DBINDER_PYTHON3:BOOL=ON',\n        '-DCMAKE_INSTALL_BINDIR=ezc3d',\n        '-DCMAKE_INSTALL_LIBDIR=ezc3d'\n    ],\n)",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]"
  },
  "ufz/ogs": {
    "setup.py": "from skbuild import setup\nfrom setuptools import find_packages\n\nimport os\nimport platform\nimport sys\n\nsys.path.append(os.path.join(\"Applications\", \"Python\"))\nfrom ogs._internal.provide_ogs_cli_tools_via_wheel import binaries_list\n\nconsole_scripts = []\nfor b in binaries_list:\n    console_scripts.append(f\"{b}=ogs._internal.provide_ogs_cli_tools_via_wheel:{b}\")\n\nfrom pathlib import Path\n\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\n# setuptools_scm config local_scheme via env var SETUPTOOLS_SCM_LOCAL_SCHEME:\nscm_local_scheme = \"node-and-date\"\nif \"SETUPTOOLS_SCM_LOCAL_SCHEME\" in os.environ:\n    local_scheme_values = [\n        \"node-and-date\",\n        \"node-and-timestamp\",\n        \"dirty-tag\",\n        \"no-local-version\",\n    ]\n    if os.environ[\"SETUPTOOLS_SCM_LOCAL_SCHEME\"] in local_scheme_values:\n        scm_local_scheme = os.environ[\"SETUPTOOLS_SCM_LOCAL_SCHEME\"]\n\nif \"CMAKE_ARGS\" in os.environ:\n    print(\n        \"WARNING: Default CMake preset 'wheel' overridden! \"\n        \"Be sure to pass a proper preset or configuration!\"\n    )\nelse:\n    cmake_preset = \"wheel\"\n    if platform.system() == \"Windows\":\n        cmake_preset += \"-win\"\n    os.environ[\"CMAKE_ARGS\"] = f\"--preset {cmake_preset}\"\n\ncmake_args = [\"-B .\"]\nif \"SKBUILD_GENERATOR\" in os.environ:\n    cmake_args.extend([\"-G\", os.environ[\"SKBUILD_GENERATOR\"]])\n\nsetup(\n    name=\"ogs\",\n    description=\"OpenGeoSys Python Module\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"OpenGeoSys Community\",\n    license=\"BSD-3-Clause\",\n    packages=find_packages(where=\"Applications/Python\"),\n    package_dir={\"\": \"Applications/Python\"},\n    cmake_install_dir=\"Applications/Python/ogs\",\n    extras_require={\"test\": [\"pytest\", \"numpy\"]},\n    cmake_args=cmake_args,\n    python_requires=\">=3.7\",\n    entry_points={\"console_scripts\": console_scripts},\n    use_scm_version={\n        \"write_to\": \"Applications/Python/_version.py\",\n        \"write_to_template\": '__version__ = \"{version}\"',\n        # Switching to guess-next-dev (default) would increment the version number\n        # This would be in line with PEP 440, switch OGS versioning too?\n        \"version_scheme\": \"no-guess-dev\",\n        \"local_scheme\": scm_local_scheme,\n        # Was in pyproject.toml but it somehow reset the version scheme. Maybe\n        # it is better to do all scm config here.\n        \"git_describe_command\": 'git describe --dirty --tags --long --match \"*[0-9]*\" --abbrev=8',\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools>=42\",\n  \"scikit-build @ git+https://github.com/bilke/scikit-build/@disable-cmake-install-check#egg=scikit-build ; platform_system == 'Windows'\",\n  \"scikit-build>=0.15.0 ; platform_system != 'Windows'\",\n  \"cmake>=3.22\",\n  \"ninja ; platform_system != 'Windows'\",\n  \"setuptools_scm[toml]>=7.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"Tests\"]\nnorecursedirs = [\"Tests/Data\"]\n\n[tool.cibuildwheel]\narchs = \"auto64\"\nbuild = \"cp3*\"\ntest-extras = \"test\"\ntest-command = \"pytest {project}/Tests/Python\"\nbuild-verbosity = \"1\"\n\n[tool.cibuildwheel.linux]\nskip = [\"*musllinux*\", \"cp36-*\"]\n# See https://github.com/NixOS/patchelf/issues/446\n# quay.io/pypa/manylinux_2_28 works too\nmanylinux-x86_64-image = \"quay.io/pypa/manylinux2014_x86_64@sha256:005826a6fa94c97bd31fccf637a0f10621304da447ca2ab3963c13991dffa013\"\nmanylinux-aarch64-image = \"quay.io/pypa/manylinux2014_x86_64@sha256:005826a6fa94c97bd31fccf637a0f10621304da447ca2ab3963c13991dffa013\"\nbefore-all = \"yum install -y ccache\"\nenvironment-pass = [\n  \"SETUPTOOLS_SCM_LOCAL_SCHEME\",\n  \"CPM_SOURCE_CACHE\",\n  \"CCACHE_DIR\",\n  \"CCACHE_MAXSIZE\",\n  \"CMAKE_ARGS\",\n]\n\n[tool.cibuildwheel.macos]\nskip = [\"cp36-*\", \"cp37-*\", \"cp38-*x86_64\"]\n\n[tool.cibuildwheel.windows]\nskip = [\"cp36-*\", \"cp37-*\"]\n"
  },
  "python-control/Slycot": {
    "setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"Slycot: a wrapper for the SLICOT control and systems library\n\nSlycot wraps the SLICOT library which is used for control and systems analysis.\n\n\"\"\"\n\nimport builtins\nimport os\nimport subprocess\n\ntry:\n    from skbuild import setup\n    from skbuild.command.sdist import sdist\nexcept ImportError:\n    raise ImportError('scikit-build must be installed before running setup.py')\n\ntry:\n    from setuptools_scm import get_version\nexcept ImportError:\n    raise ImportError('setuptools_scm must be installed before running setup.py')\n\n# This is a bit hackish: we are setting a global variable so that the main\n# slycot __init__ can detect if it is being loaded by the setup routine, to\n# avoid attempting to load components that aren't built yet.  While ugly, it's\n# a lot more robust than what was previously being used.\nbuiltins.__SLYCOT_SETUP__ = True\n\n\ndef check_submodules():\n    \"\"\" verify that the submodules are checked out and clean\n        use `git submodule update --init`; on failure\n    \"\"\"\n    if not os.path.exists('.git'):\n        return\n    with open('.gitmodules') as f:\n        for l in f:\n            if 'path' in l:\n                p = l.split('=')[-1].strip()\n                if not os.path.exists(p):\n                    raise ValueError('Submodule %s missing' % p)\n\n    proc = subprocess.Popen(['git', 'submodule', 'status'],\n                            stdout=subprocess.PIPE)\n    status, _ = proc.communicate()\n    status = status.decode(\"ascii\", \"replace\")\n    for line in status.splitlines():\n        if line.startswith('-') or line.startswith('+'):\n            raise ValueError('Submodule not clean: %s' % line)\n\n\nclass sdist_checked(sdist):\n    \"\"\" check submodules on sdist to prevent incomplete tarballs \"\"\"\n    def run(self):\n        check_submodules()\n        sdist.run(self)\n\n# These need to stay in setup.py\n# https://scikit-build.readthedocs.io/en/latest/usage.html#setuptools-options\nsetup(\n    packages=['slycot', 'slycot.tests'],\n    cmdclass={'sdist': sdist_checked},\n    cmake_languages=('C', 'Fortran'),\n    use_scm_version = True,\n    include_package_data = False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=45\",\n    \"setuptools_scm>=7\",\n    \"wheel\",\n    \"scikit-build>=0.15\",\n    \"cmake>=3.14\",\n    \"numpy!=1.23.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"slycot\"\ndescription = \"A wrapper for the SLICOT control and systems library\"\nreadme = \"README.rst\"\nauthors = [{ name = \"Enrico Avventi et al.\" }]\nmaintainers = [{ name = \"Slycot developers\", email = \"python-control-discuss@lists.sourceforge.net\"}]\nlicense = {text = \"GPL-2.0 AND BSD-3-Clause\"}\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Science/Research\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved\",\n    \"License :: OSI Approved :: GNU General Public License v2 (GPLv2)\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Programming Language :: C\",\n    \"Programming Language :: Fortran\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Topic :: Software Development\",\n    \"Topic :: Scientific/Engineering\",\n    \"Operating System :: Microsoft :: Windows\",\n    \"Operating System :: POSIX\",\n    \"Operating System :: Unix\",\n    \"Operating System :: MacOS\",\n]\nrequires-python = \">=3.8\"\ndependencies = [\n    \"numpy\",\n]\ndynamic = [\"version\"]\n\n[project.urls]\nhomepage = \"https://github.com/python-control/Slycot\"\n\n\n[tool.setuptools_scm]\nwrite_to = \"slycot/version.py\"\n\n[tool.pytest.ini_options]\n# run the tests with compiled and installed package\naddopts = \"--pyargs slycot\"\n"
  },
  "pupil-labs/pyuvc": {
    "setup.py": "import json\nimport os\nimport pathlib\nimport platform\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\ncmake_args = []\ncmake_args.append(f\"-DUVC_DEBUGGING={os.environ.get('UVC_DEBUGGING', 'OFF')}\")\ncmake_args.append(\n    f\"-DFORCE_LOCAL_LIBUVC_BUILD={os.environ.get('FORCE_LOCAL_LIBUVC_BUILD', 'OFF')}\"\n)\n\nif platform.system() == \"Windows\":\n    import os\n\n    import pupil_pthreads_win as ptw\n\n    cmake_args.append(f\"-DPTHREADS_WIN_INCLUDE_DIR='{ptw.include_path}'\")\n    cmake_args.append(f\"-DPTHREADS_WIN_IMPORT_LIB_PATH='{ptw.import_lib_path}'\")\n\n    paths_loc = os.environ.get(\"DEPS_PATHS_LOC\")\n    paths = json.loads(pathlib.Path(paths_loc).read_text())\n    for path_name, path_value in paths.items():\n        path_value = pathlib.Path(path_value).resolve()\n        cmake_args.append(f\"-D{path_name}='{path_value}'\")\n\n    # The Ninja cmake generator will use mingw (gcc) on windows travis instances, but we\n    # need to use msvc for compatibility. The easiest solution I found was to just use\n    # the vs cmake generator as it defaults to msvc.\n    cmake_args.append(\"-GVisual Studio 17 2022\")\n    cmake_args.append(\"-DCMAKE_WINDOWS_EXPORT_ALL_SYMBOLS=True\")\n\npyuvc_source_folder = \"pyuvc-source\"\n\nsetup(\n    packages=find_packages(where=pyuvc_source_folder),\n    package_dir={\"\": pyuvc_source_folder},\n    include_package_data=False,\n    cmake_source_dir=pyuvc_source_folder,\n    cmake_install_dir=pyuvc_source_folder + \"/uvc\",\n    cmake_args=cmake_args,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"setuptools_scm[toml]>=3.4.1\",\n    \"wheel\",\n    \"Cython\",\n    \"numpy\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja;platform_system != \\\"Windows\\\"\",\n    \"pupil_pthreads_win; platform_system == \\\"Windows\\\"\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\n\n[tool.cibuildwheel]\narchs = [\"native\"]\nskip = \"{cp,pp}27-* {cp,pp}35-* pp*\"\n\nbuild-frontend = \"build\"\n\ntest-command = \"pytest {package}/tests -v\"\nbefore-test = \"\"\ntest-requires = [\"pytest\"]\ntest-extras = []\n\nmanylinux-x86_64-image = \"manylinux2014\"\n\n[tool.cibuildwheel.windows]\nenvironment = { DEPS_PATHS_LOC = \"tmp/dep_paths.json\" }\nbefore-all = \"powershell scripts/download-deps-win.ps1 -DEPS_TMP_PATH tmp\"\nbefore-build = \"pip install delvewheel pupil-pthreads-win\"\nrepair-wheel-command = \"python scripts/repair-wheels-win.py tmp/dep_paths.json {wheel} {dest_dir}\"\n\n[tool.cibuildwheel.macos]\nbefore-all = [\"brew install automake\", \"{project}/scripts/build-deps-unix.sh\"]\n\n[tool.cibuildwheel.linux]\nbefore-all = [\n    \"yum install -y libudev-devel\",\n    \"{project}/scripts/build-deps-manylinux.sh\",\n]\n\n[[tool.cibuildwheel.overrides]]\nselect = \"*-musllinux*\"\nbefore-all = [\n    \"apk add eudev-dev nasm\",\n    \"{project}/scripts/build-deps-manylinux.sh\",\n]\n",
    "setup.cfg": "[metadata]\nname = pupil_labs_uvc\ndescription = Usb Video Class Device bindings with format conversion tool\nlong_description = file: README.rst\nlong_description_content_type = text/x-rst\nurl = https://github.com/pupil-labs/pyuvc\nauthor = Pupil Labs GmbH\nauthor_email = info@pupil-labs.com\nlicense = MIT\nlicense_file = LICENSE\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Developers\n    License :: OSI Approved :: MIT License\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3 :: Only\n\n[options]\ninstall_requires =\n    numpy\n    importlib-metadata;python_version<\"3.8\"\npython_requires = >=3.6\n\n[options.extras_require]\ndocs =\n    furo\n    jaraco.packaging>=9\n    rst.linker>=1.9\n    sphinx\nexample =\n    opencv-python\n    rich\ntesting =\n    pytest>=6\n    pytest-checkdocs>=2.4\n    pytest-cov\n    pytest-enabler>=1.3\n    pytest-mypy>=0.9.1;python_implementation != \"PyPy\"\n"
  },
  "insight-platform/Savant": {
    "libs/savantboost/setup.py": "from skbuild import setup\n\nsetup(\n    name='savantboost',\n    version='0.0.1',\n    description='Python bindings for Savant boost library',\n    author='Nikolay Bogoslovskiy',\n    author_email='bogoslovskiy_nn@bw-sw.com',\n    packages=['pysavantboost'],\n    package_dir={'': ''},\n    cmake_install_dir='pysavantboost',\n    python_requires='>=3.6',\n)\n",
    "libs/savantboost/pyproject.toml": "[build-system]\nrequires = [\n    'setuptools>=61.0',\n    'pybind11[global]',\n    'cmake',\n    'scikit-build',\n]\nbuild-backend = 'setuptools.build_meta'\n\n[tool.black]\nskip-string-normalization = true\n\n[tool.pylint.messages_control]\nmax-line-length = 88\n",
    "libs/gstsavantframemeta/setup.py": "from skbuild import setup\n\nsetup(\n    name='pygstsavantframemeta',\n    version='0.0.1',\n    description='Python bindings for GstSavantFrameMeta library',\n    author='Pavel Tomskikh',\n    author_email='tomskih_pa@bw-sw.com',\n    packages=['pygstsavantframemeta'],\n    package_dir={'': ''},\n    cmake_install_dir='pygstsavantframemeta',\n    python_requires='>=3.6',\n)\n",
    "libs/gstsavantframemeta/pyproject.toml": "[build-system]\nrequires = [\n    'setuptools>=61.0',\n    'pybind11[global]~=2.10.0',\n    'cmake>=3.12',\n    'scikit-build~=0.15.0',\n]\nbuild-backend = 'setuptools.build_meta'\n\n[tool.black]\nskip-string-normalization = true\n\n[tool.pylint.messages_control]\nmax-line-length = 88\n"
  },
  "equinor/dlisio": {
    "python/setup.py": "#!/usr/bin/env python3\n\nimport os\nimport skbuild\nimport setuptools\n\nclass get_pybind_include(object):\n    def __init__(self, user=False):\n        self.user = user\n\n    def __str__(self):\n        # postpone importing pybind11 until building actually happens\n        import pybind11\n        return pybind11.get_include(self.user)\n\ndef src(x):\n    root = os.path.dirname( __file__ )\n    return os.path.abspath(os.path.join(root, x))\n\npybind_includes = [\n    str(get_pybind_include()),\n    str(get_pybind_include(user = True))\n]\n\ndef get_long_description():\n    path = os.path.abspath(os.path.join(os.path.dirname( __file__ ), '..', 'README.md'))\n    with open(path) as f:\n        return f.read()\n\nskbuild.setup(\n    name = 'dlisio',\n    description = 'Python library for working with the well log formats DLIS (RP66v1) and LIS79',\n    long_description = get_long_description(),\n    long_description_content_type = \"text/markdown\",\n    url = 'https://github.com/equinor/dlisio',\n    packages = ['dlisio', 'dlisio.dlis', 'dlisio.lis', 'dlisio.common', 'dlisio.dlis.utils'],\n    license = 'LGPL-3.0',\n    platforms = 'any',\n    install_requires = ['numpy'],\n    setup_requires = ['setuptools >= 28',\n                      'pybind11 >= 2.3',\n                      'setuptools_scm',\n                      'pytest-runner',\n    ],\n    tests_require = ['pytest'],\n    # we're building with the pybind11 fetched from pip. Since we don't rely on\n    # a cmake-installed pybind there's also no find_package(pybind11) -\n    # instead, the get include dirs from the package and give directly from\n    # here\n    cmake_args = [\n        '-DPYBIND11_INCLUDE_DIRS=' + ';'.join(pybind_includes),\n        # we can safely pass OSX_DEPLOYMENT_TARGET as it's ignored on\n        # everything not OS X. We depend on C++11, which makes our minimum\n        # supported OS X release 10.9\n        '-DCMAKE_OSX_DEPLOYMENT_TARGET=10.9',\n    ],\n    # skbuild's test imples develop, which is pretty obnoxious instead, use a\n    # manually integrated pytest.\n    cmdclass = { 'test': setuptools.command.test.test },\n)\n",
    "python/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools >= 40\",\n    \"scikit-build\",\n    \"wheel\",\n    \"pybind11\",\n    \"pytest-runner\",\n]\n\n[tool.cibuildwheel]\nbefore-all = [\n    \"\"\"curl                                                             \\\n        -L https://github.com/fmtlib/fmt/archive/refs/tags/7.1.3.tar.gz \\\n        -o fmt-7.1.3.tar.gz                                             \\\n    \"\"\",\n    \"tar xf fmt-7.1.3.tar.gz\",\n    \"\"\"cmake                \\\n        -S fmt-7.1.3        \\\n        -B fmt-7.1.3/build  \\\n        -DFMT_TEST=OFF      \\\n        -DFMT_DOC=OFF       \\\n    \"\"\",\n    \"\"\"cmake                    \\\n        --build fmt-7.1.3/build \\\n        --target install        \\\n        --config Release        \\\n    \"\"\",\n    \"\"\"git clone https://github.com/equinor/layered-file-protocols.git\"\"\",\n    \"\"\"cmake                                    \\\n        -S layered-file-protocols               \\\n        -B layered-file-protocols/build         \\\n        -DCMAKE_POSITION_INDEPENDENT_CODE=ON    \\\n        -DLFP_FMT_HEADER_ONLY=ON                \\\n        -DBUILD_TESTING=OFF                     \\\n    \"\"\",\n    \"\"\"cmake                                    \\\n        --build layered-file-protocols/build    \\\n        --target install                        \\\n        --config Release                        \\\n    \"\"\",\n    \"\"\"curl                                                                 \\\n        -L https://github.com/mpark/variant/archive/refs/tags/v1.4.0.tar.gz \\ \n        -o variant-1.4.0.tar.gz                                             \\\n    \"\"\",\n    \"tar xf variant-1.4.0.tar.gz\",\n    \"\"\"cmake                    \\\n        -S variant-1.4.0        \\\n        -B variant-1.4.0/build  \\\n    \"\"\",\n    \"\"\"cmake                        \\\n        --build variant-1.4.0/build \\\n        --target install            \\\n        --config Release            \\\n    \"\"\",\n]\n\nbefore-build = [\n    \"\"\"cmake                                 \\\n        -S .                                 \\\n        -B build                             \\\n        -DCMAKE_BUILD_TYPE=Release           \\\n        -DCMAKE_POSITION_INDEPENDENT_CODE=ON \\\n        -DBUILD_TESTING=OFF                  \\\n        -DBUILD_PYTHON=OFF                   \\\n    \"\"\",\n    \"\"\"cmake             \\\n        --build build    \\\n        --parallel       \\\n        --target install \\\n        --config Release \\\n    \"\"\",\n]\n\ntest-requires = \"pytest\"\n\n# Cibuildwheel doesn't run tests from the project directory. This is to ensure\n# the wheel is imported by the tests, and not the source copy. Normally, one\n# would run pytest using the cibw project variable like so: 'pytest\n# {project}/tests'.  This doesn't work for us however, because our tests use\n# relative paths to our test data folder python/data. The workaround is to copy\n# out the tests/ and data/ directories to the current folder. This has to be\n# done in 'test-command' and not in 'before-test' because there is no guarantee\n# they are run from the same directory.\ntest-command = [\n    \"\"\"python {project}/.github/utils.py copy --src {package}/tests --dst testdir/tests\"\"\",\n    \"\"\"python {project}/.github/utils.py copy --src {package}/data  --dst testdir/data\"\"\",\n    \"\"\"cd testdir\"\"\",\n    \"\"\"pytest tests\"\"\",\n    \"\"\"python {project}/.github/utils.py remove --paths tests data\"\"\",\n]\n\n[tool.cibuildwheel.linux]\nmanylinux-x86_64-image = \"manylinux2010\"\n\n[[tool.cibuildwheel.overrides]]\nselect = \"cp311*\"\nmanylinux-x86_64-image = \"manylinux2014\"\n\n[tool.cibuildwheel.macos]\nenvironment = { CXXFLAGS=\"-L/usr/local/lib\" }\n",
    "python/setup.cfg": "[metadata]\nversion = 0.3.7\n\n[aliases]\ntest = pytest\n"
  },
  "equinor/xtgeo": {
    "setup.py": "#!/usr/bin/env python3\n\"\"\"Setup for XTGeo - subsurface reservoir tool for maps, 3D grids etc.\"\"\"\nimport os\nimport sys\n\ntry:\n    import setuptools\n    from setuptools import setup as setuptools_setup\nexcept ImportError:\n    print(\"\\n*** Some requirements are missing, please run:\")\n    print(\"\\n*** pip install -r requirements/requirements_setup.txt\\n\\n\")\n    raise\n\ntry:\n    import skbuild\nexcept ImportError:\n    print(\"\\n*** Some requirements are missing, please run:\")\n    print(\"\\n*** pip install -r requirements/requirements_setup.txt\\n\")\n    raise\n\nfrom scripts import setup_utilities as setuputils\n\nCMD = sys.argv[1]\n\nREADME = setuputils.readmestuff(\"README.md\")\nHISTORY = setuputils.readmestuff(\"HISTORY.md\")\n\nREQUIREMENTS = setuputils.parse_requirements(\"requirements/requirements.txt\")\n\nTEST_REQUIREMENTS = setuputils.parse_requirements(\"requirements/requirements_test.txt\")\nSETUP_REQUIREMENTS = setuputils.parse_requirements(\n    \"requirements/requirements_setup.txt\"\n)\nDOCS_REQUIREMENTS = setuputils.parse_requirements(\"requirements/requirements_docs.txt\")\nEXTRAS_REQUIRE = {\"tests\": TEST_REQUIREMENTS, \"docs\": DOCS_REQUIREMENTS}\n\nCMDCLASS = {\"clean\": setuputils.CleanUp}\n\n\ndef src(anypath):\n    root = os.path.dirname(__file__)\n    return os.path.abspath(os.path.join(root, anypath))\n\n\nskbuild.setup(\n    name=\"xtgeo\",\n    description=\"XTGeo is a Python library for 3D grids, surfaces, wells, etc\",\n    use_scm_version={\n        \"root\": src(\"\"),\n        \"write_to\": src(\"src/xtgeo/_theversion.py\"),\n    },\n    long_description=README + \"\\n\\n\" + HISTORY,\n    long_description_content_type=\"text/markdown\",\n    author=\"Equinor R&T\",\n    url=\"https://github.com/equinor/xtgeo\",\n    project_urls={\n        \"Documentation\": \"https://xtgeo.readthedocs.io/\",\n        \"Issue Tracker\": \"https://github.com/equinor/xtgeo/issues\",\n    },\n    license=\"LGPL-3.0\",\n    cmake_args=[\"-DCMAKE_VERBOSE_MAKEFILE:BOOL=ON\"],\n    packages=setuptools.find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmdclass=CMDCLASS,\n    zip_safe=False,\n    keywords=\"xtgeo\",\n    command_options=setuputils.CMDSPHINX,\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: GNU Lesser General Public \"\n        \"License v3 or later (LGPLv3+)\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Natural Language :: English\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Physics\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Topic :: Utilities\",\n    ],\n    test_suite=\"tests\",\n    install_requires=REQUIREMENTS,\n    setup_requires=SETUP_REQUIREMENTS,\n    tests_require=TEST_REQUIREMENTS,\n    extras_require=EXTRAS_REQUIRE,\n)\n\n# Below is a hack to make \"python setup.py develop\" or \"pip install -e .\" to work.\n# Without this, the xtgeo.egg-link file will be wrong, e.g.:\n# /home/jan/work/git/xtg/xtgeo\n# .\n#\n# instead of the correct:\n# /home/jan/work/git/xtg/xtgeo/src\n# ../\n#\n# The wrong egg-link comes when find_packages(where=\"src\") finds a list of packages in\n# scikit-build version of setup(). No clue why...\n\nif CMD == \"develop\":\n    print(\"Run in DEVELOP mode\")\n    setuptools_setup(  # use setuptools version of setup\n        name=\"xtgeo\",\n        use_scm_version={\n            \"root\": src(\"\"),\n            \"write_to\": src(\"src/xtgeo/_theversion.py\"),\n        },\n        packages=setuptools.find_packages(where=\"src\"),\n        package_dir={\"\": \"src\"},\n        zip_safe=False,\n        test_suite=\"tests\",\n        install_requires=REQUIREMENTS,\n        setup_requires=SETUP_REQUIREMENTS,\n        tests_require=TEST_REQUIREMENTS,\n        extras_require=EXTRAS_REQUIRE,\n    )\n",
    "pyproject.toml": "# NOTE: you have to use single-quoted strings in TOML for regular expressions.\n\n[tool.black]\nline-length = 88\ntarget-version = ['py37', 'py38', 'py39', 'py310', 'py311']\ninclude = '\\.pyi?$'\nexclude = '''\n/(\n    \\.eggs\n  | \\.git\n  | \\.hg\n  | \\.mypy_cache\n  | \\.tox\n  | \\.venv\n  | _build\n  | buck-out\n  | build\n  | dist\n  # The following are specific to Black, you probably don't want those.\n  | blib2to3\n  | tests/data\n  | profiling\n)/\n'''\n\n# numpy version scheme to fulfill Roxar API compatibility:\n# RMS 12.1.*  -->  numpy == 1.19.2 with python 3.8\n\n[build-system]\nrequires = [\n  \"setuptools>=43\",\n  \"wheel\",\n  \"scikit-build<0.17\",\n  'cmake==3.15.3; python_version >= \"3.7\" and platform_system == \"Linux\"',\n  'cmake==3.18.0; platform_system != \"Linux\"',\n  \"ninja\",\n  \"setuptools_scm>=3.2.0\",\n  'numpy>=1.15.4; python_version == \"3.7\"',\n  'numpy==1.19.2; python_version == \"3.8\"',\n  'numpy==1.19.5; python_version == \"3.9\"',\n  'numpy==1.21.6; python_version == \"3.10\"',\n  'numpy==1.23.5; python_version == \"3.11\"',\n  'Sphinx<4.0',\n  'sphinx-rtd-theme',\n  'sphinx-toolbox',\n  'autoclasstoc',\n  'myst-parser',\n]\n",
    "setup.cfg": "[flake8]\nexclude = docs/conf.py, src/xtgeo/cxtgeo/*.py, .eggs, _skbuild, tests/**/snapshots\nmax-line-length = 88\nignore = E402, W503, E203, C901\n\n[pydocstyle]\nconvention = google\nmatch = (?!(test_|_)).*\\.py\n\n[aliases]\ntest = pytest\n"
  },
  "ksahlin/StrobeAlign": {
    "setup.py": "from skbuild import setup\nimport nanobind\n\nsetup(\n    name=\"strobealign\",\n    description=\"Python bindings for strobealign\",\n    license=\"MIT\",\n    version=\"0.9.0\",\n    packages=[\"strobealign\"],\n    package_dir={\"\": \"src/python\"},\n    cmake_install_dir=\"src/python\",\n    cmake_args=[\"-DPYTHON_BINDINGS=ON\"],\n)\n",
    "pyproject.toml": "[build-system]\nbuild-backend = \"setuptools.build_meta\"\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build>=0.13\",\n    \"cmake>=3.18\",\n    \"ninja; platform_system!='Windows'\",\n    \"nanobind>=0.2.0\",\n]\n"
  },
  "arbor-sim/arbor": {
    "setup.py": "from sys import executable as python\nfrom skbuild import setup\n\n# Hard coded options, because scikit-build does not do build options.\n# Override by instructing CMAKE, e.g.:\n# pip install . -- -DARB_USE_BUNDLED_LIBS=ON -DARB_WITH_MPI=ON -DARB_GPU=cuda\nwith_mpi = False\nwith_gpu = \"none\"\nwith_vec = False\narch = \"none\"\nuse_libs = True\nbuild_type = \"Release\"  # this is ok even for debugging, as we always produce info\n\nsetup(\n    cmake_args=[\n        \"-DARB_WITH_PYTHON=on\",\n        f\"-DPYTHON_EXECUTABLE={python}\",\n        f\"-DARB_WITH_MPI={with_mpi}\",\n        f\"-DARB_VECTORIZE={with_vec}\",\n        f\"-DARB_ARCH={arch}\",\n        f\"-DARB_GPU={with_gpu}\",\n        f\"-DARB_USE_BUNDLED_LIBS={use_libs}\",\n        f\"-DCMAKE_BUILD_TYPE={build_type}\",\n    ],\n)\n",
    "pyproject.toml": "[project]\nname = \"arbor\"\ndynamic = [\"version\", \"readme\"]\nlicense = {file = \"LICENSE\"}\ndescription = \"High performance simulation of networks of multicompartment neurons.\"\nrequires-python = \">=3.7\"\nkeywords = [\"simulator\", \"neuroscience\", \"morphological detail\", \"HPC\", \"GPU\", \"C++\"]\nauthors = [\n    {name = \"Arbor Dev Team\", email = \"contact@arbor-sim.org\"}\n]\nmaintainers = [\n    {name = \"Arbor Dev Team\", email = \"contact@arbor-sim.org\"}\n]\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Science/Research\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: C++\"\n]\ndependencies = [\n    \"numpy\"\n]\n\n[tool.black]\nline-length = 88\ntarget-version = ['py37', 'py38', 'py39', 'py310', 'py311']\ninclude = '\\.pyi?$'\nextend-exclude='^/(ext|doc/scripts/.*_theme|doc/scripts/inputs.py)'\n\n[tool.setuptools]\npy-modules = [\"arbor\"]\n\n[tool.setuptools.dynamic]\nversion = {file = [\"VERSION\"]}\nreadme = {file = [\"python/readme.rst\"]}\n\n[project.urls]\nhomepage = \"https://arbor-sim.org\"\ndocumentation = \"https://docs.arbor-sim.org\"\nrepository = \"https://github.com/arbor-sim/arbor\"\nchangelog = \"https://github.com/arbor-sim/arbor/releases\"\n\n[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake>=3.19\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild-frontend = \"build\"\nbuild = [\"cp3*-manylinux_x86_64\",\"cp3*-macosx_universal2\"]#,\"cp3*-musllinux_x86_64\",\"cp3*-musllinux_aarch64\"]\nskip = \"cp36-*\"\ntest-command = \"python3 -m unittest discover -v -s {project}/python\"\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"universal2\", \"arm64\"]\n\n[tool.cibuildwheel.macos.environment]\nMACOSX_DEPLOYMENT_TARGET = \"10.15\"\n\n[tool.cibuildwheel.linux]\narchs = [\"x86_64\"]\nmanylinux-x86_64-image = \"manylinux2014\"\nrepair-wheel-command = \"auditwheel repair -w {dest_dir} {wheel} && python3 /project/scripts/patchwheel.py {dest_dir}\"\n\n[[tool.cibuildwheel.overrides]]\nselect = \"*-musllinux*\"\n"
  },
  "boschmitt/tweedledum": {
    "setup.py": "# -------------------------------------------------------------------------------\n# Part of Tweedledum Project.  This file is distributed under the MIT License.\n# See accompanying file /LICENSE for details.\n# -------------------------------------------------------------------------------\nimport os\nimport sys\nimport skbuild\nimport setuptools\n\nbuild_dev_version = os.environ.get(\"TWEEDLEDUM_DEV_VERSION\", False)\n\n\ndef get_name():\n    if build_dev_version:\n        return \"tweedledum-dev\"\n    else:\n        return \"tweedledum\"\n\n\ndef get_version():\n    if build_dev_version:\n        return \"1.2.0.dev\" + str(build_dev_version)\n    else:\n        return \"1.1.0\"\n\n\nskbuild.setup(\n    name=get_name(),\n    version=get_version(),\n    package_dir={\"\": \"python\"},\n    packages=setuptools.find_packages(\n        where=\"python\", include=[\"tweedledum\", \"tweedledum.*\"]\n    ),\n    include_package_data=True,\n    zip_safe=False,\n    python_requires=\">=3.6\",\n    cmake_install_dir=\"python\",\n)\n\n# /!\\ This is a 'gambiarra':\n# For whatever reason, whenever I try to install `tweedledum` in development\n# mode, i.e., `pip install -e .`, the easy_path and egg-link are wrong! Hence,\n# I basically fix them by hand because I couldn't figure out a better way of\n# doing it!\nif len(sys.argv) > 1 and sys.argv[1] == \"develop\":\n    from pathlib import Path\n    import fileinput\n    import shutil\n    import site\n\n    easy_install = Path(site.getsitepackages()[0]) / \"easy-install.pth\"\n    egg_link = Path(site.getsitepackages()[0]) / \"tweedledum.egg-link\"\n    for line in fileinput.input([easy_install, egg_link], inplace=True):\n        print(line.replace(\"tweedledum\", \"tweedledum/python\"), end=\"\")\n    shutil.rmtree(\"tweedledum.egg-info\", ignore_errors=True)\n",
    "pyproject.toml": "[project]\nrequires-python = \">=3.6\"\n\n[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"cmake>=3.18\",\n    \"ninja\",\n    \"scikit-build>=0.12.0\",\n]\n",
    "setup.cfg": "[metadata]\ndescription = A library for synthesizing and manipulating quantum circuits\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nurl = https://github.com/boschmitt/tweedledum\nauthor = Bruno Schmitt\nlicense = MIT\nlicense_file = LICENSE\nplatforms = unix, linux, osx, cygwin, win32\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    License :: OSI Approved :: MIT License\n    Intended Audience :: Developers\n    Intended Audience :: Science/Research\n    Operating System :: Microsoft :: Windows\n    Operating System :: MacOS\n    Operating System :: POSIX :: Linux\n    Programming Language :: C++\n    Programming Language :: Python :: 3 :: Only\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3.11\n    Topic :: Software Development :: Compilers\n    Topic :: Software Development :: Libraries\n"
  },
  "PDAL/python": {
    "setup.py": "from skbuild import setup\n\n# Get the version from the pdal module\nwith open(\"pdal/__init__.py\", \"r\") as fp:\n    for line in fp:\n        if line.startswith(\"__version__\"):\n            version = line.split(\"=\")[1].strip().strip(\"\\\"'\")\n            break\n    else:\n        raise ValueError(\"Could not determine Python package version\")\n\nwith open(\"README.rst\", \"r\", encoding=\"utf-8\") as fp:\n    readme = fp.read()\n\nwith open(\"CHANGES.txt\", \"r\", encoding=\"utf-8\") as fp:\n    changes = fp.read()\n\nsetup(\n    name=\"pdal\",\n    version=version,\n    description=\"Point cloud data processing\",\n    license=\"BSD\",\n    keywords=\"point cloud spatial\",\n    author=\"Howard Butler\",\n    author_email=\"howard@hobu.co\",\n    maintainer=\"Howard Butler\",\n    maintainer_email=\"howard@hobu.co\",\n    url=\"https://pdal.io\",\n    long_description=readme + \"\\n\\n\" + changes,\n    long_description_content_type=\"text/x-rst\",\n    packages=[\"pdal\"],\n    install_requires=[\"numpy\"],\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Topic :: Scientific/Engineering :: GIS\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"scikit-build\", \"cmake>=3.11\", \"ninja\", \"numpy\",  \"pybind11[global]\"]\n"
  },
  "DragonFlyBSD/DPorts": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "steineggerlab/foldcomp": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    name=\"foldcomp\",\n    version=\"0.0.5\",\n    description=\"Foldcomp compresses protein structures with torsion angles effectively. It compresses the backbone atoms to 8 bytes and the side chain to additionally 4-5 byes per residue, an averaged-sized protein of 350 residues requires ~4.2kb. Foldcomp is a C++ library with Python bindings.\",\n    long_description=open(\"README.md\").read(),\n    long_description_content_type=\"text/markdown\",\n    author=\"Milot Mirdita <milot@mirdita.de>, Hyunbin Kim <khb7840@gmail.com>, Martin Steinegger <themartinsteinegger@gmail.com>\",\n    license=\"GPLv3\",\n    cmake_args=[\"-DBUILD_PYTHON:BOOL=ON\"],\n    python_requires=\">=3.7\",\n    packages=[\"foldcomp\"],\n    include_package_data=False,\n    install_requires=[\n        \"httpx >= 0.23.0\",\n    ],\n    extras_require={\"test\": [\"pytest\"]},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"cmake>=3.22\",\n    \"scikit-build>=0.15.0\",\n    \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild = \"*\"\nskip = \"pp* *-win32 *-manylinux_i686 *-musllinux_i686\"\ntest-command = \"pytest {project}/test\"\ntest-extras = [\"test\"]\ntest-skip = [\"*universal2:arm64\"]\n"
  },
  "rpm-software-management/createrepo_c": {
    "setup.py": "from skbuild import setup\n\n\nwith open('VERSION.cmake', 'r+') as version_file:\n    lines = version_file.read().splitlines()\n    # parse out digit characters from the line, convert to int\n    numbers = [int(\"\".join(filter(str.isdigit, line))) for line in lines]\n    # build version string\n    version = '{major}.{minor}.{patch}'.format(\n        major=numbers[0],\n        minor=numbers[1],\n        patch=numbers[2]\n    )\n\nsetup(\n    name='createrepo_c',\n    description='C implementation of createrepo',\n    version=version,\n    license='GPLv2+',\n    author='RPM Software Management',\n    author_email='rpm-ecosystem@lists.rpm.org',\n    url='https://github.com/rpm-software-management',\n    classifiers=[\n        'License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)',\n        'Operating System :: POSIX :: Linux',\n        'Programming Language :: C',\n        'Topic :: System :: Software Distribution',\n        'Topic :: System :: Systems Administration',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n    ],\n    packages=['createrepo_c'],\n    package_dir={\n        'createrepo_c': 'src/python/createrepo_c'\n    },\n    cmake_args=[\n        '-DBIN_INSTALL_DIR:PATH=src/python/createrepo_c/data/bin',\n        '-DBUILD_LIBCREATEREPO_C_SHARED:BOOL=OFF',\n        '-DCREATEREPO_C_INSTALL_DEVELOPMENT:BOOL=OFF',\n        '-DCREATEREPO_C_INSTALL_MANPAGES:BOOL=OFF',\n        '-DENABLE_BASHCOMP:BOOL=OFF',\n        '-DENABLE_DRPM:BOOL=OFF',\n        '-DWITH_LEGACY_HASHES:BOOL=ON',\n    ],\n    cmake_languages=['C'],\n    entry_points={\n        'console_scripts': [\n            'createrepo_c=createrepo_c:createrepo_c',\n            'mergerepo_c=createrepo_c:mergerepo_c',\n            'modifyrepo_c=createrepo_c:modifyrepo_c',\n            'sqliterepo_c=createrepo_c:sqliterepo_c'\n        ]\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools >= 40.8.0\",\n    \"wheel >= 0.29.0\",\n    \"scikit-build\"\n]\nbuild-backend = 'setuptools.build_meta'\n"
  },
  "equinor/ecl": {
    "setup.py": "import os\nimport sys\nimport skbuild\nimport setuptools\nfrom setuptools_scm import get_version\n\n\nversion = get_version(relative_to=__file__, write_to=\"python/ecl/version.py\")\n\n\n# Corporate networks tend to be behind a proxy server with their own non-public\n# SSL certificates. Conan keeps its own certificates, whose path we can override\nif \"CONAN_CACERT_PATH\" not in os.environ:\n    # Look for a RHEL-compatible system-wide file\n    for file_ in (\"/etc/pki/tls/cert.pem\",):\n        if not os.path.isfile(file_):\n            continue\n        os.environ[\"CONAN_CACERT_PATH\"] = file_\n        break\n\n\nwith open(\"README.md\") as f:\n    long_description = f.read()\n\n\ndef utility_wrappers():\n    \"\"\"\n    Wrappers around ecl's \"application\" utilities. These are only supported on\n    Linux at this time so only create the wrapper when on Linux.\n    \"\"\"\n    if sys.platform != \"linux\":\n        return []\n\n    return [\n        name + \" = ecl.bin:main\"\n        for name in (\n            \"CF_dump\",\n            \"convert.x\",\n            \"ecl_pack.x\",\n            \"ecl_unpack.x\",\n            \"grdecl_grid\",\n            \"grdecl_test.x\",\n            \"grid_dump.x\",\n            \"grid_dump_ascii.x\",\n            \"grid_info.x\",\n            \"kw_extract\",\n            \"kw_list.x\",\n            \"load_test.x\",\n            \"make_grid\",\n            \"ri_well_test\",\n            \"segment_info\",\n            \"select_test.x\",\n            \"summary.x\",\n        )\n    ]\n\n\nskbuild.setup(\n    name=\"ecl\",\n    author=\"Equinor ASA\",\n    author_email=\"fg_sib-scout@equinor.com\",\n    description=\"Package for reading and writing the result files from the ECLIPSE reservoir simulator\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/equinor/ecl\",\n    packages=setuptools.find_packages(\n        where=\"python\",\n        exclude=[\"*.tests\", \"*.tests.*\", \"tests.*\", \"tests\", \"ert.*\", \"ert\"],\n    ),\n    package_dir={\"\": \"python\"},\n    license=\"GPL-3.0\",\n    platforms=\"any\",\n    install_requires=[\n        \"cwrap\",\n        \"numpy\",\n        \"pandas\",\n    ],\n    entry_points={\"console_scripts\": utility_wrappers()},\n    cmake_args=[\n        \"-DECL_VERSION=\" + version,\n        \"-DBUILD_APPLICATIONS=\" + (\"ON\" if sys.platform == \"linux\" else \"OFF\"),\n        \"-DCMAKE_EXPORT_COMPILE_COMMANDS=ON\",\n        \"-DCMAKE_INSTALL_BINDIR=python/ecl/.bin\",\n        \"-DCMAKE_INSTALL_LIBDIR=python/ecl/.libs\",\n        \"-DCMAKE_INSTALL_INCLUDEDIR=python/ecl/.include\",\n        # we can safely pass OSX_DEPLOYMENT_TARGET as it's ignored on\n        # everything not OS X. We depend on C++11, which makes our minimum\n        # supported OS X release 10.9\n        \"-DCMAKE_OSX_DEPLOYMENT_TARGET=10.9\",\n    ],\n    # skbuild's test imples develop, which is pretty obnoxious instead, use a\n    # manually integrated pytest.\n    cmdclass={\"test\": setuptools.command.test.test},\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Environment :: Other Environment\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n        \"Natural Language :: English\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Physics\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Topic :: Utilities\",\n    ],\n    version=version,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"setuptools_scm\", \"wheel\", \"scikit-build\", \"cmake\", \"conan<2\"]\n",
    "setup.cfg": "[aliases]\ntest = pytest\n\n[flake8]\nmax-line-length = 88\n"
  },
  "yushulx/python-capture-device-list": {
    "setup.py": "from skbuild import setup\nimport io\n\nlong_description = io.open(\"README.md\", encoding=\"utf-8\").read()\npackages = ['device']\n\nsetup (name = 'windows-capture-device-list',\n            version = '1.1.0',\n            description = 'Get device list with Windows DirectShow',\n            long_description=long_description,\n            long_description_content_type=\"text/markdown\",\n            author='yushulx',\n            url='https://github.com/yushulx/python-capture-device-list',\n            license='MIT',\n            packages=packages,\n            include_package_data=True,\n            classifiers=[\n                \"Development Status :: 5 - Production/Stable\",\n                \"Environment :: Console\",\n                \"Intended Audience :: Developers\",\n                \"Intended Audience :: Education\",\n                \"Intended Audience :: Information Technology\",\n                \"Intended Audience :: Science/Research\",\n                \"License :: OSI Approved :: MIT License\",\n                \"Operating System :: Microsoft :: Windows\",\n                \"Programming Language :: Python\",\n                \"Programming Language :: Python :: 3\",\n                \"Programming Language :: Python :: 3 :: Only\",\n                \"Programming Language :: Python :: 3.6\",\n                \"Programming Language :: Python :: 3.7\",\n                \"Programming Language :: Python :: 3.8\",\n                \"Programming Language :: Python :: 3.9\",\n                \"Programming Language :: Python :: 3.10\",\n                \"Programming Language :: C++\",\n                \"Programming Language :: Python :: Implementation :: CPython\",\n                \"Topic :: Scientific/Engineering\",\n                \"Topic :: Software Development\",\n            ],\n          )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13\",\n    \"cmake>=3.18\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "mutationpp/Mutationpp": {
    "setup.py": "import re\nimport sys\n\nfrom pathlib import Path\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nROOT_CMAKELISTS = \"./CMakeLists.txt\"\n\nDESCRIPTION = \"\"\"An open-source library providing thermodynamic, transport,\\\nchemistry, and energy transfer properties associated with subsonic to\\\nhypersonic flows.\"\"\"\n\n\ndef get_version_from_cmake(root_cmakelists):\n    \"\"\"A helper function to parse the root CMakeLists.txt and retrieve the\n    version from there in order to have a single point holding the version\n    info, easier to update\"\"\"\n\n    pattern = re.compile(r\" *VERSION *(\\d+\\.\\d+\\.\\d+)\")\n\n    root_file = Path(root_cmakelists)\n\n    with open(root_file, \"r\") as f:\n        for line in f:\n            match = pattern.search(line)\n            if match is not None:\n                return match.group(1)\n\n    raise RuntimeError(\n        \"Couldn't parse CMakeLists.txt file to find a version statement\"\n    )\n\n\nsetup(\n    name=\"mutationpp\",\n    version=get_version_from_cmake(ROOT_CMAKELISTS),\n    description=DESCRIPTION,\n    long_description=DESCRIPTION,\n    author=\"James B. Scoggins\",\n    license=\"LGPL3\",\n    package_dir={\"\": \"interface/python\"},\n    packages=[\"mutationpp\"],\n    extras_require={\n        \"test\": [\"numpy\", \"pytest\"],\n    },\n    cmake_install_dir=\"interface/python/mutationpp\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\ntestpaths = [\n    \"tests/python\",\n]\n"
  },
  "equinor/ert": {
    "setup.py": "import os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom setuptools import Command, find_packages\nfrom setuptools.command.egg_info import egg_info\nfrom skbuild import setup\n\n# list of pair of .proto file and out directory\nPROTOBUF_FILES = [(\"src/_ert_com_protocol/_schema.proto\", \"src/_ert_com_protocol\")]\n\n\ndef compile_protocol_buffers():\n    for proto, out_dir in PROTOBUF_FILES:\n        proto_path = Path(proto).parent\n        subprocess.run(\n            [\n                sys.executable,\n                \"-m\",\n                \"grpc_tools.protoc\",\n                \"-I\",\n                proto_path,\n                f\"--python_out={out_dir}\",\n                proto,\n            ],\n            check=True,\n        )\n\n\nclass EggInfo(egg_info):\n    \"\"\"scikit-build uses the metadata of ert to determine what to include when building\n    the project. This determination results in files being copied to a special build\n    folder. If ert wants to compile e.g. protobuf files and have those included in the\n    distribution, those files needs to be a part of the distribution metadata, i.e. it\n    needs to happen in egg_info so that the compiled files are copied to the build\n    folder.\"\"\"\n\n    def run(self):\n        compile_protocol_buffers()\n        egg_info.run(self)  # old style class, no super()\n\n\nclass CompileProtocolBuffers(Command):\n    user_options = []\n\n    def initialize_options(self) -> None:\n        pass\n\n    def finalize_options(self) -> None:\n        pass\n\n    def run(self):\n        compile_protocol_buffers()\n\n\n# Corporate networks tend to be behind a proxy server with their own non-public\n# SSL certificates. Conan keeps its own certificates,\n# whose path we can override\nif \"CONAN_CACERT_PATH\" not in os.environ:\n    # Look for a RHEL-compatible system-wide file\n    for file_ in (\"/etc/pki/tls/cert.pem\",):\n        if not os.path.isfile(file_):\n            continue\n        os.environ[\"CONAN_CACERT_PATH\"] = file_\n        break\n\n\ndef package_files(directory):\n    paths = []\n    for path, _, filenames in os.walk(directory):\n        for filename in filenames:\n            paths.append(os.path.join(\"..\", \"..\", path, filename))\n    return paths\n\n\nwith open(\"README.md\") as f:\n    long_description = f.read()\n\n\nargs = dict(\n    name=\"ert\",\n    author=\"Equinor ASA\",\n    author_email=\"fg_sib-scout@equinor.com\",\n    description=\"Ensemble based Reservoir Tool (ERT)\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/equinor/ert\",\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    package_data={\n        \"ert\": package_files(\"src/ert/gui/resources/\")\n        + package_files(\"src/ert/shared/share/\")\n        + [\"logging/logger.conf\", \"logging/storage_log.conf\"]\n        + [\n            \"_c_wrappers/fm/rms/rms_config.yml\",\n            \"_c_wrappers/fm/ecl/ecl300_config.yml\",\n            \"_c_wrappers/fm/ecl/ecl100_config.yml\",\n            \"_c_wrappers/job_queue/qstat_proxy.sh\",\n        ],\n    },\n    include_package_data=True,\n    license=\"GPL-3.0\",\n    platforms=\"any\",\n    python_requires=\">=3.8\",\n    install_requires=[\n        \"aiofiles\",\n        \"aiohttp\",\n        \"alembic\",\n        \"ansicolors==1.1.8\",\n        \"async-generator\",\n        \"beartype > 0.11\",\n        \"cloudevents>=1.6.0\",\n        \"cloudpickle\",\n        \"tqdm>=4.62.0\",\n        \"cryptography\",\n        \"cwrap\",\n        \"dask_jobqueue\",\n        \"decorator\",\n        \"deprecation\",\n        \"dnspython >= 2\",\n        \"ecl >= 2.14.1\",\n        \"ert-storage >= 0.3.16\",\n        \"fastapi\",\n        \"filelock\",\n        \"graphlib_backport; python_version < '3.9'\",\n        \"iterative_ensemble_smoother>=0.1.1\",\n        \"typing_extensions>=4.4\",\n        \"jinja2\",\n        \"lark\",\n        \"matplotlib\",\n        \"numpy\",\n        \"packaging\",\n        \"pandas\",\n        \"pluggy\",\n        \"prefect<2\",\n        \"protobuf<4\",\n        \"psutil\",\n        \"pydantic >= 1.9\",\n        \"PyQt5\",\n        \"pyrsistent\",\n        \"python-dateutil\",\n        \"pyyaml\",\n        \"qtpy\",\n        \"requests\",\n        \"SALib\",\n        \"scipy<1.9.2\",\n        \"sqlalchemy\",\n        \"uvicorn >= 0.17.0\",\n        \"websockets >= 9.0.1, <11.0\",\n        \"httpx\",\n        \"tables\",\n        \"xarray\",\n        \"xtgeo\",\n    ],\n    entry_points={\n        \"console_scripts\": [\n            \"ert=ert.__main__:main\",\n            \"job_dispatch.py = _ert_job_runner.job_dispatch:main\",\n        ]\n    },\n    cmake_args=[\n        \"-DBUILD_TESTS=OFF\",\n        # we can safely pass OSX_DEPLOYMENT_TARGET as it's ignored on\n        # everything not OS X. We depend on C++17, which makes our minimum\n        # supported OS X release 10.15\n        \"-DCMAKE_OSX_DEPLOYMENT_TARGET=10.15\",\n    ],\n    cmake_source_dir=\"src/clib/\",\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Environment :: Other Environment\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n        \"Natural Language :: English\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Physics\",\n    ],\n    cmdclass={\n        \"egg_info\": EggInfo,\n        \"compile_protocol_buffers\": CompileProtocolBuffers,\n    },\n)\n\nsetup(**args)\n\n# workaround for https://github.com/scikit-build/scikit-build/issues/546 :\n# This increases time taken to run `pip install -e .` somewhat until we\n# have only one top level package at which point we can use the workaround\n# in the issue\nif sys.argv[1] == \"develop\":\n    from setuptools import setup as setuptools_setup\n\n    del args[\"cmake_args\"]\n    del args[\"cmake_source_dir\"]\n    setuptools_setup(**args)\n",
    "pyproject.toml": "[build-system]\n\nrequires = [\n    \"setuptools<64\",\n    \"setuptools_scm[toml]>=6.2\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja\",\n    \"ecl\",\n    \"conan<2\",\n    \"pybind11>=2.10.0\",  # If this comes out of sync with the version installed by Conan please update the version in CMakeLists\n    \"grpcio-tools==1.41.0\",\n]\n\n\n[tool.pytest.ini_options]\naddopts = \"-ra --strict-markers\"\nmarkers = [\n    \"integration_test\",\n    \"quick_only\",\n    \"requires_eclipse\",\n    \"requires_ert_storage\",\n    \"requires_window_manager\",\n    \"script\",\n    \"slow\",\n    \"unstable\",\n]\nlog_cli = \"false\"\nasyncio_mode = \"auto\"\n\n[tool.isort]\nprofile = \"black\"\n\n[tool.black]\ninclude = '(\\.pyi?|\\.ipynb|\\.py\\.j2)$'\n\n[tool.setuptools_scm]\nwrite_to = \"src/ert/shared/version.py\"\n",
    "setup.cfg": "[aliases]\ntest = pytest\n\n[flake8]\nper-file-ignores =\n     # long redefinition of signatures prevents per-line ignores, so ignore E501 (line-too-long) for the entire file\n     src/ert/experiment_server/_server.py: E501\n     # Ignore all protobuf v2 files\n    *_pb2.py: E\n# We ignore only things that black takes (better) care of:\nignore =\n    E203\n    W503\nmax-line-length = 88\n"
  },
  "theengs/decoder": {
    "setup.py": "# read the contents of your README file\nfrom pathlib import Path\n\n\nfrom packaging import version\nfrom skbuild import setup\nfrom skbuild.cmaker import get_cmake_version\nfrom skbuild.exceptions import SKBuildError\n\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text(encoding=\"utf-8\")\n\n\n# Copy the python dist files to a folder in the root directory to resolve installation issues related to incorrect file location\nimport shutil\ndirpath = Path('python') / 'TheengsDecoder'\nif dirpath.exists() and dirpath.is_dir():\n    shutil.copytree('python/TheengsDecoder', 'TheengsDecoder')\n\n\n# Add CMake as a build requirement if cmake is not installed\n# or is too low a version\nsetup_requires = []\ntry:\n    if version.parse(get_cmake_version()) < version.parse(\"3.4\"):\n        setup_requires.append(\"cmake\")\nexcept SKBuildError:\n    setup_requires.append(\"cmake\")\n\nsetup(\n    name=\"TheengsDecoder\",\n    version=\"version_tag\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    description=\"A message decoder for the Internet of Things\",\n    author='Theengs',\n    license=\" GPL-3.0 License\",\n    packages=['TheengsDecoder'],\n    setup_requires=setup_requires,\n)\n\n# Cleanup after building source dist\nif dirpath.exists() and dirpath.is_dir():\n    shutil.rmtree('TheengsDecoder')\n    shutil.rmtree('TheengsDecoder.egg-info')\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"",
    "python/setup.py": "from skbuild import setup \n\nsetup(\n    name=\"TheengsDecoder\",\n    version=\"version_tag\",\n    description=\"A message decoder for the Internet of Things\",\n    author='Theengs',\n    license=\" GPL-3.0 License\",\n    packages=['TheengsDecoder'],\n)\n\n",
    "python/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]"
  },
  "AMYPAD/CuVec": {
    "setup.py": "#!/usr/bin/env python3\nimport logging\nimport re\nimport sys\nfrom pathlib import Path\n\nfrom setuptools import find_packages\nfrom setuptools_scm import get_version\nfrom skbuild import setup\n\n__version__ = get_version(root=\".\", relative_to=__file__)\n\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(\"cuvec.setup\")\n\nbuild_ver = \".\".join(__version__.split('.')[:3]).split(\".dev\")[0]\ncmake_args = [f\"-DCUVEC_BUILD_VERSION={build_ver}\", f\"-DPython3_ROOT_DIR={sys.prefix}\"]\ntry:\n    from miutil import cuinfo\n    nvcc_arch_raw = map(cuinfo.compute_capability, range(cuinfo.num_devices()))\n    nvcc_arches = {\"%d%d\" % i for i in nvcc_arch_raw if i >= (3, 5)}\n    if nvcc_arches:\n        cmake_args.append(\"-DCMAKE_CUDA_ARCHITECTURES=\" + \";\".join(sorted(nvcc_arches)))\nexcept Exception as exc:\n    if \"sdist\" not in sys.argv or any(i in sys.argv for i in [\"build\", \"bdist\", \"wheel\"]):\n        log.warning(\"Import or CUDA device detection error:\\n%s\", exc)\nfor i in (Path(__file__).resolve().parent / \"_skbuild\").rglob(\"CMakeCache.txt\"):\n    i.write_text(re.sub(\"^//.*$\\n^[^#].*pip-build-env.*$\", \"\", i.read_text(), flags=re.M))\nsetup(use_scm_version=True, packages=find_packages(exclude=[\"docs\", \"tests\"]),\n      cmake_source_dir=\"cuvec\", cmake_languages=(\"C\", \"CXX\"),\n      cmake_minimum_required_version=\"3.18\", cmake_args=cmake_args)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"setuptools_scm[toml]>=3.4\",\n            \"miutil[cuda]>=0.4.0\",\n            \"scikit-build>=0.11.0\", \"cmake>=3.18\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"cuvec/_dist_ver.py\"\nwrite_to_template = \"__version__ = '{version}'\\n\"\n\n[project.urls]\ndocumentation = \"https://amypad.github.io/CuVec\"\nrepository = \"https://github.com/AMYPAD/CuVec\"\nchangelog = \"https://github.com/AMYPAD/CuVec/releases\"\n\n[project]\nname = \"cuvec\"\ndynamic = [\"version\"]\nauthors = [{name = \"Casper da Costa-Luis\", email = \"casper.dcl@physics.org\"}]\ndescription = \"Unifying Python/C++/CUDA memory: Python buffered array -> C++11 `std::vector` -> CUDA managed memory\"\nreadme = \"README.rst\"\nrequires-python = \">=3.7\"\nkeywords = [\"Python\", \"C\", \"C++\", \"buffer\", \"vector\", \"array\", \"CUDA\", \"CPython\", \"SWIG\", \"extensions\", \"API\"]\nlicense = {text = \"MPL-2.0\"}\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Developers\",\n    \"Environment :: GPU\",\n    \"Environment :: GPU :: NVIDIA CUDA\",\n    \"Intended Audience :: Education\",\n    \"Intended Audience :: Science/Research\",\n    \"License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)\",\n    \"Operating System :: Microsoft :: Windows\",\n    \"Operating System :: POSIX :: Linux\",\n    \"Programming Language :: C\",\n    \"Programming Language :: C++\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3 :: Only\",\n    \"Topic :: Software Development :: Libraries\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n    \"Topic :: Utilities\"]\ndependencies = ['importlib_resources; python_version < \"3.9\"', \"numpy\"]\n\n[project.optional-dependencies]\ndev = [\"pytest>=6\", \"pytest-cov\", \"pytest-timeout\", \"pytest-xdist\"]\n\n[tool.flake8]\nmax_line_length = 99\nextend_ignore = [\"E261\"]\nexclude = [\".git\", \"__pycache__\", \"build\", \"dist\", \".eggs\"]\n\n[tool.yapf]\nspaces_before_comment = [15, 20]\narithmetic_precedence_indication = true\nallow_split_before_dict_value = false\ncoalesce_brackets = true\ncolumn_limit = 99\neach_dict_entry_on_separate_line = false\nspace_between_ending_comma_and_closing_bracket = false\nsplit_before_named_assigns = false\nsplit_before_closing_bracket = false\nblank_line_before_nested_class_or_def = false\n\n[tool.isort]\nprofile = \"black\"\nline_length = 99\nknown_first_party = [\"cuvec\", \"tests\"]\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\ntimeout = 30\nlog_level = \"INFO\"\npython_files = [\"tests/test_*.py\"]\ntestpaths = [\"tests\"]\naddopts = \"-v --tb=short -rxs -W=error -n=2 --durations=0 --durations-min=1 --cov=cuvec --cov-report=term-missing --cov-report=xml\"\n"
  },
  "OpenJij/OpenJij": {
    "setup.py": "# Copyright 2023 Jij Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    from setuptools import setup\n\nsetup_requires = [\n    \"numpy\",\n    \"pybind11 >=2.10.0, < 2.11.0\",\n    \"cmake > 3.20\",\n    \"scikit-build > 0.16.0\"\n]\n\nif any(arg in sys.argv for arg in (\"pytest\", \"test\")):\n    setup_requires.append(\"pytest-runner\")\n\nsetup(\n    setup_requires=setup_requires,\n    packages=[\n        \"openjij\",\n        \"openjij.model\",\n        \"openjij.sampler\",\n        \"openjij.sampler.chimera_gpu\",\n        \"openjij.utils\",\n    ],\n    cmake_install_dir=\"openjij\",\n    include_package_data=False,\n    zip_safe=False,\n)\n",
    "pyproject.toml": "# Copyright 2023 Jij Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nrequires = [\n   'setuptools_scm[toml]', \n   'setuptools',\n   'wheel',\n   'build',\n   'oldest-supported-numpy',\n   'pybind11',\n   'scikit-build',\n   ]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"openjij/_version.py\"\n\n[tool.pytest.ini_options]\naddopts = \"--continue-on-collection-errors --full-trace --color=yes --code-highlight=yes --cov-context=test --cov --cov-append --cov-report term --randomly-seed=last -vv -v --capture=no\"\ntestpaths = [\n    \"tests\",\n]\nspec_header_format = \"{module_path}:\"\nspec_test_format = \"{result} {name}\"\nlog_level = \"INFO\"\nlog_cli_level = \"INFO\"\nconsole_output_style = \"count\"\nlog_auto_indent = true\njunit_logging = \"all\"\n\n[tool.flake8] \nshow-source = true\nstatistics = true\ndoctests = true\nmax-complexity = 10\nmax-line-length = 999 \n\n[tool.isort]\nprofile= \"black\"\nmulti_line_output = 3\nforce_grid_wrap = 0\ninclude_trailing_comma = false\nensure_newline_before_comments = true\nuse_parentheses = true \nbalanced_wrapping = false\nlines_between_types = 1\n#order_by_type = true \ncombine_as_imports = true\ncombine_star = true\ncombine_straight_imports = true\ngroup_by_package = true\nauto_identify_namespace_packages = true\nsrc_paths = [\"openjij\", \"tests\"]\n\n[tool.black]\ntarget-version = ['py39', 'py310']\n\n[tool.mypy]\nignore_missing_imports = true\n#show_traceback = true\nwarn_return_any = true\nwarn_unused_configs = true\nwarn_unreachable = true\nnamespace_packages = true\nexplicit_package_bases = true\n#show_error_context = true \n#show_column_numbers = true\n\n[tool.pyright]\npythonVersion = \"3.9\"\ntypeCheckingMode = \"basic\"\ninclude = [\n    \"openjij\", \n    \"tests\",\n  ]\nignore = [ \n  \"*.c\", \n  \"*.so\",\n]\nreportImportCycles = 'warning'\nreportUnusedImport = 'warning'\nreportUnusedVariable =  'warning'\nreportDuplicateImport = 'warning'\n\n[tool.cibuildwheel]\nskip = [\"cp36*\", \"cp311*\", \"*musllinux_x86_64\", \"*musllinux_aarch64\", \"pp*\"]\nbuild-verbosity = 1\ndependency-versions = \"latest\"\n\n[tool.cibuildwheel.linux]\narchs = [\"x86_64\", \"aarch64\"]\nbuild-frontend = \"build\"\n#environment = \"-CFLAGS='-march=haswell' -CXXFLAGS='-march=haswell' -FFLAGS='-march=haswell'\"\nmanylinux-x86_64-image =\"quay.io/pypa/manylinux_2_28_x86_64:latest\"\nmanylinux-aarch64-image = \"quay.io/pypa/manylinux_2_28_aarch64:latest\"\n#before-all = [ \n#    \"dnf config-manager --set-enabled powertools\",\n#    \"dnf makecache --refresh\",\n#    \"dnf -y --enablerepo=powertools install openblas-static\",\n#    \"dnf -y --enablerepo=powertools install lapack-static\",\n#    \"dnf -y install gcc-toolset-11\", \n#    \"dnf -y --enablerepo=powertools install eigen3-devel\",\n#]\nbefore-build = [ \n    \"source scl_source enable gcc-toolset-11\",\n    \"pip install --upgrade pip wheel build pybind11 cmake ninja\", \n]\nrepair-wheel-command = \"auditwheel repair --lib-sdir . -w {dest_dir} {wheel}\"\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"arm64\"]\nbuild-frontend = \"build\"\n#before-all = [ \n#    \"brew install eigen nlohmann-json\",\n#]\n#environment = \"CFLAGS='-O3 -pipe' CXXFLAGS='-O3 -pipe'\" \nbefore-build = [ \n    \"pip install --upgrade pip wheel build pybind11 cmake ninja\", \n]\n\n[tool.cibuildwheel.windows]\narchs = [\"AMD64\"]\n#build-frontend = \"build\"\n#environment = \"CMAKE_TOOLCHAIN_FILE='C:/vcpkg/scripts/buildsystems/vcpkg.cmake'\" \n#before-all = [ \n#    \"vcpkg update\",\n#    \"vcpkg --triplet x64-windows install eigen3 --recurse\", \n#    \"vcpkg --triplet x64-windows install nlohmann-json --recurse\",\n#    \"vcpkg --triplet x64-windows-static install eigen3 --recurse\",\n#    \"vcpkg --triplet x64-windows-static install nlohmann-json --recurse\",  \n#    \"vcpkg integrate install\",\n#]\n#\"vcpkg --triplet x64-windows-static install openblas[threads] --recurse\", \n#\"vcpkg --triplet x64-windows-static install clapack --recurse\", \nbefore-build = [ \n    \"pip install --upgrade pip wheel build cmake pybind11 delvewheel\", \n]\nrepair-wheel-command = \"delvewheel repair -w {dest_dir} {wheel}\"\n",
    "setup.cfg": "# Copyright 2023 Jij Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[install_lib]\noptimize = 1\ncompile = 1\n\n[aliases]\ntest=pytest\n\n[metadata]\nname = openjij\nurl = https://www.openjij.org\nauthor = Jij Inc.\nauthor_email = info@openjij.org\ndescription = Framework for the Ising model and QUBO.\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nlicense_files = LICENSE\nlicense = Apache License 2.0\nclassifiers =\n    License :: OSI Approved :: Apache Software License\n    Intended Audience :: Science/Research\n    Programming Language :: Python\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3 :: Only\n    Programming Language :: Python :: Implementation :: CPython\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX\n    Operating System :: Unix\n    Operating System :: MacOS \nproject_urls =\n    Source=https://github.com/OpenJij/OpenJij\n    Documentation=https://openjij.github.io/OpenJij\n    Reference=https://ref.openjij.org/index.html\n\n[options]\npython_requires = >=3.7, <3.11\ninstall_requires =\n    numpy >=1.17.3, < 1.25.0\n    dimod < 0.13.0\n    scipy >= 1.7.3, < 1.11.0\n    requests >= 2.28.0, < 2.29.0\n    jij-cimod >= 1.4.42, < 1.5.0\n    typing-extensions >= 4.2.0\ntests_require =\n    pytest\n    pytest-mock\n    pytest-cov\n    pytest-runner\n    pytest-randomly\n    pytest-spec\n    coverage\n"
  },
  "scipp/scipp": {
    "setup.py": "# SPDX-License-Identifier: BSD-3-Clause\n# Copyright (c) 2023 Scipp contributors (https://github.com/scipp)\n# @author Simon Heybrock\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\ndef get_version():\n    import subprocess\n\n    return (\n        subprocess.run(\n            ['git', 'describe', '--tags', '--abbrev=0'], stdout=subprocess.PIPE\n        )\n        .stdout.decode('utf8')\n        .strip()\n    )\n\n\ndef get_cmake_args():\n    # Note: We do not specify '-DCMAKE_OSX_DEPLOYMENT_TARGET' here. It is set using the\n    # MACOSX_DEPLOYMENT_TARGET environment variable in the github workflow. The reason\n    # is that I am not sure if cibuildwheel uses this for anything else apart from\n    # configuring the actual build.\n    return []\n\n\nlong_description = \"\"\"# Multi-dimensional data arrays with labeled dimensions\n\n*A Python library enabling a modern and intuitive way of working with scientific data in Jupyter notebooks*\n\n**scipp** is heavily inspired by [xarray](https://xarray.pydata.org>).\nIt enriches raw NumPy-like multi-dimensional arrays of data by adding named dimensions and associated coordinates.\nMultiple arrays can be combined into datasets.\nWhile for many applications xarray is certainly more suitable (and definitely much more matured) than scipp, there is a number of features missing in other situations.\nIf your use case requires one or several of the items on the following list, using scipp may be worth considering:\n\n- **Physical units** are stored with each data or coord array and are handled in arithmetic operations.\n- **Propagation of uncertainties**.\n- Support for **histograms**, i.e., **bin-edge axes**, which are by 1 longer than the data extent.\n- Support for scattered data and **non-destructive binning**.\n  This includes first and foremost **event data**, a particular form of sparse data with arrays of random-length lists, with very small list entries.\n- Support for **masks stored with data**.\n- Internals written in C++ for better performance (for certain applications), in combination with Python bindings.\n\"\"\"  # noqa #501\n\nsetup(\n    name='scipp',\n    version=get_version(),\n    description='Multi-dimensional data arrays with labeled dimensions',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    author='Scipp contributors (https://github.com/scipp)',\n    url='https://github.com/scipp/scipp',\n    project_urls={\n        'Documentation': 'https://scipp.github.io/',\n        'Bug Tracker': 'https://github.com/scipp/scipp/issues',\n        'Changelog': 'https://scipp.github.io/about/release-notes.html',\n    },\n    license='BSD-3-Clause',\n    packages=find_packages(where=\"src\"),\n    package_dir={'': 'src'},\n    cmake_args=get_cmake_args(),\n    cmake_install_dir='src/scipp',\n    include_package_data=True,\n    python_requires='>=3.8',\n    install_requires=['confuse', 'graphlib-backport', 'numpy>=1.20'],\n    extras_require={\n        \"test\": [\n            \"pytest\",\n            \"matplotlib\",\n            \"xarray\",\n            \"pandas\",\n            \"pythreejs\",\n            \"bs4\",\n            \"numba;python_version<'3.11'\",  # numba does not support 3.11 yet\n        ],\n        'all': ['h5py', 'scipy>=1.7.0', 'graphviz', 'pooch', 'plopp', 'matplotlib'],\n        'interactive': [\n            'ipympl',\n            'ipython',\n            'ipywidgets',\n            'matplotlib',\n            'jupyterlab',\n            'jupyterlab-widgets',\n            'jupyter_nbextensions_configurator',\n            'nodejs',\n            'plopp',\n            'pythreejs',\n        ],\n    },\n    classifiers=[\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: BSD License',\n        'Natural Language :: English',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX :: Linux',\n        'Topic :: Scientific/Engineering',\n        'Typing :: Typed',\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools>=42\",\n  \"wheel\",\n  \"cmake>=3.21\",\n  \"conan==1.57.0\",\n  \"ninja\",\n  \"scikit-build==0.13.1\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\narchs = [\"auto64\"]\ntest-requires = [\"scipy\", \"graphviz\", \"pooch\"]\ntest-extras = [\"test\"]\ntest-command = \"pytest --ignore {project}/tests/plotting --ignore {project}/tests/hypothesis/ --ignore {project}/tests/experimental/ {project}/tests\"\n# PyPy builds fail with an error about ninja, probably https://github.com/pypa/setuptools/issues/2912\n# tbb-devel not available for musllinux\nskip = [\"pp*\", \"*musllinux*\"]\nbuild-verbosity = 1\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"arm64\"]\n\n[tool.bandit]\nexclude_dirs = [\n  \"install\",\n  \"conda/cmake-package-test\",\n  \"tools\",\n  \"setup.py\",\n  \"docs/conf.py\",\n]\n\n[tool.bandit.assert_used]\nskips = [\n  \"*/*_test.py\",\n  \"src/scipp/testing/assertions.py\"\n]\n\n[tool.codespell]\nignore-words-list = \"elemt\"\nskip = \"./.git,./install,./build,./cmake-build*,./lib/cmake/sanitizers-cmake,./.tox,*/*_cache,*/.virtual_documents,*/.ipynb_checkpoints,*.pdf,*.svg\"\n\n[tool.black]\n# Runs into a bug with this file. But since it is autogenerated, we don't want to reformat it anyway.\nforce-exclude = \"src/scipp/core/cpp_classes.pyi\"\nskip-string-normalization = true\n\n[tool.isort]\nskip_gitignore = true\nprofile = \"black\"\nskip_glob = [\"src/scipp/__init__.py\", \"src/scipp/core/__init__.py\"]\n\n[tool.pytest.ini_options]\nminversion = \"7.0\"\ntestpaths = \"tests\"\naddopts = \"\"\"\n--strict-config\n--strict-markers\n-ra\n-v\n\"\"\"\nfilterwarnings = [\n  'error',\n  'ignore:You are running a \"Debug\" build of scipp:',\n  'ignore:sc.geometry.rotation_matrix_from_quaternion_coeffs has been deprecated:scipp.VisibleDeprecationWarning',\n  # Comes from pytest_asyncio and is not our fault.\n  \"ignore:The 'asyncio_mode' default value will change to 'strict' in future:DeprecationWarning\",\n  'ignore::scipy.optimize._optimize.OptimizeWarning',\n  # Plotting related warnings.\n  \"ignore:You are using Scipp's deprecated plotting backend:scipp.VisibleDeprecationWarning\",\n  'ignore:Attempt to set non-positive :UserWarning',\n  'ignore:Widget. :DeprecationWarning',\n  'ignore:Attempting to set identical low and high ylims makes transformation singular; automatically expanding.:UserWarning',\n  # TODO Plotting related deprecation warnings which should be addressed!\n  'ignore:NONE is deprecated and will be removed in Pillow 10 \\(2023-07-01\\). Use Resampling.NEAREST or Dither.NONE instead.:DeprecationWarning',\n  'ignore:ADAPTIVE is deprecated and will be removed in Pillow 10 \\(2023-07-01\\). Use Palette.ADAPTIVE instead.:DeprecationWarning',\n  'ignore:\\n            Sentinel is not a public part of the traitlets API:DeprecationWarning',\n  'ignore:Keyword `trait` is deprecated in traitlets 5.0, use `value_trait` instead:DeprecationWarning',\n  'ignore:Keyword `traits` is deprecated in traitlets 5.0, use `per_key_traits` instead:DeprecationWarning',\n  'ignore:Support for mapping types has been deprecated and will be dropped in a future release.:DeprecationWarning',\n]\n",
    "setup.cfg": "[flake8]\n# See https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#line-length\nmax-line-length = 88\nextend-ignore = E203\nextend-select = B904\nexclude = .*,__pycache__,build,dist,cmake-build*,install\n"
  },
  "lab-cosmo/librascal": {
    "setup.py": "import sys\nimport os\nfrom os.path import join\nfrom distutils.sysconfig import get_python_lib\n\nfrom setuptools import find_packages\nfrom skbuild import setup\nfrom skbuild.constants import CMAKE_INSTALL_DIR\nimport re\n\n# read the version number from the library\npattern = r\"[0-9]\\.[0-9]\\.[0-9]\"\nversion = None\nwith open(\"./bindings/rascal/__init__.py\", \"r\") as fp:\n    for line in fp.readlines():\n        if \"__version__\" in line:\n            version = re.findall(pattern, line)[0]\nif version is None:\n    raise ValueError(\"Version number not found.\")\n\nwith open(\"./requirements_pip.txt\", \"r\") as fp:\n    requirements = list(filter(lambda x: \"#\" not in x, (line.strip() for line in fp)))\n\nsetup(\n    name=\"rascal\",\n    version=version,\n    description=\"\"\"A versatile and scalable computation of representations of \\\n    atomic structures for machine learning.\"\"\",\n    author=\"librascal developers\",\n    license=\"LGPL-2.1-or-later\",\n    cmake_args=[\n        \"-DINSTALL_PATH:STRING=\" + join(os.getcwd(), CMAKE_INSTALL_DIR()),\n        \"-DBUILD_EXAMPLES:BOOL=OFF\",\n    ],\n    package_dir={\"\": \"bindings\"},\n    packages=find_packages(where=\"bindings\"),\n    install_requires=requirements,\n    # include_package_data=True,\n    package_data={\"\": [\"lib/librascal.*\"]},\n    zip_safe=False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "OpenWaterAnalytics/epanet-python": {
    "owa-epanet/setup.py": "from skbuild import setup\nfrom setuptools import find_packages\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name = \"owa-epanet\",\n    version = \"2.2.4\",\n    author = \"Sam Hatchett\",\n    author_email = \"samhatchett@gmail.com\",\n    description = \"a thin wrapper for epanet hydraulic toolkit\",\n    long_description = long_description,\n    long_description_content_type=\"text/markdown\",\n    url = \"https://github.com/OpenWaterAnalytics/epanet-python\",\n    cmake_args=[\"-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9\"],\n    #cmake_with_sdist = True,\n    package_dir = {\"\":\"packages\"},\n    packages = [\"epanet\"],\n    package_data = {\"epanet\":[\"*.dylib\", \"*.dll\", \"*.so\"]},\n    zip_safe=False\n)\n",
    "owa-epanet/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\"]\n"
  },
  "wkentaro/octomap-python": {
    "setup.py": "import subprocess\nimport sys\n\nfrom setuptools import Extension\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef install_packages(*requirements):\n    # No more convenient way until PEP 518 is implemented;\n    # setuptools only handles eggs\n    subprocess.check_call(\n        [sys.executable, \"-m\", \"pip\", \"install\"] + list(requirements)\n    )\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef get_or_install(name, version=None):\n    # Do not import 3rd-party modules into the current process\n    import json\n\n    js_packages = json.loads(\n        subprocess.check_output(\n            [sys.executable, \"-m\", \"pip\", \"list\", \"--format\", \"json\"]\n        ).decode(\"ascii\")\n    )  # valid names & versions are ASCII as per PEP 440\n    try:\n        [package] = (\n            package for package in js_packages if package[\"name\"] == name\n        )\n    except ValueError:\n        install_packages(\"%s==%s\" % (name, version) if version else name)\n        return version\n    else:\n        return package[\"version\"]\n\n\ndef get_long_description():\n    with open(\"README.md\") as f:\n        long_description = f.read()\n\n    try:\n        import github2pypi\n\n        return github2pypi.replace_url(\n            slug=\"wkentaro/octomap-python\", content=long_description\n        )\n    except Exception:\n        return long_description\n\n\ndef main():\n    get_or_install(\"cython\")\n    get_or_install(\"numpy\")\n    get_or_install(\"scikit-build\")\n\n    from Cython.Distutils import build_ext\n    import numpy\n    import skbuild\n\n    ext_modules = [\n        Extension(\n            \"octomap\",\n            [\"octomap/octomap.pyx\"],\n            include_dirs=[\n                \"src/octomap/octomap/include\",\n                \"src/octomap/dynamicEDT3D/include\",\n                numpy.get_include(),\n            ],\n            library_dirs=[\n                \"src/octomap/lib\",\n            ],\n            libraries=[\n                \"dynamicedt3d\",\n                \"octomap\",\n                \"octomath\",\n            ],\n            language=\"c++\",\n        )\n    ]\n\n    skbuild.setup(\n        name=\"octomap-python\",\n        version=\"1.8.0.post12\",\n        install_requires=[\"numpy\"],\n        extras_require={\n            \"example\": [\"glooey\", \"imgviz>=1.2.0\", \"pyglet\", \"trimesh[easy]\"],\n        },\n        license=\"BSD\",\n        maintainer=\"Kentaro Wada\",\n        maintainer_email=\"www.kentaro.wada@gmail.com\",\n        url=\"https://github.com/wkentaro/octomap-python\",\n        description=\"Python binding of the OctoMap library.\",\n        long_description=get_long_description(),\n        long_description_content_type=\"text/markdown\",\n        classifiers=[\n            \"Development Status :: 5 - Production/Stable\",\n            \"Intended Audience :: Developers\",\n            \"Natural Language :: English\",\n            \"Programming Language :: Python\",\n            \"Programming Language :: Python :: 2\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: Implementation :: CPython\",\n            \"Programming Language :: Python :: Implementation :: PyPy\",\n        ],\n        ext_modules=ext_modules,\n        cmdclass={\"build_ext\": build_ext},\n        cmake_source_dir=\"src/octomap\",\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject.toml": "[tool.black]\nline-length = 79\nexclude = '''\n(\n    ^/\\..*\n  | ^/src/\n  | ^/github2pypi/\n)\n'''\n",
    "setup.cfg": "[flake8]\nexclude=.anaconda*,examples/legacy,tests,src\n"
  },
  "IntelPython/dpnp": {
    "setup.py": "from skbuild import setup\nimport os\nimport importlib.machinery as imm\n\n\n\"\"\"\nGet the project version\n\"\"\"\nthefile_path = os.path.abspath(os.path.dirname(__file__))\nversion_mod = imm.SourceFileLoader('version', os.path.join(thefile_path, 'dpnp', 'version.py')).load_module()\n__version__ = version_mod.__version__\n\nsetup(\n    name=\"dpnp\",\n    version=__version__,\n    description=\"\",\n    long_description=\"\",\n    long_description_content_type=\"text/markdown\",\n    license=\"Apache 2.0\",\n    author=\"Intel Corporation\",\n    url=\"https://github.com/IntelPython/dpnp\",\n    packages=['dpnp',\n              'dpnp.dpnp_algo',\n              'dpnp.dpnp_utils',\n              'dpnp.fft',\n              'dpnp.linalg',\n              'dpnp.random'\n    ],\n    package_data={'dpnp': ['libdpnp_backend_c.so', 'dpnp_backend_c.lib', 'dpnp_backend_c.dll']},\n    include_package_data=True,\n)\n",
    "pyproject.toml": "[tool.coverage.run]\nplugins = [\n    \"Cython.Coverage\"\n]\nbranch = true\nsource = [\n    \"dpnp\",\n]\nomit = [\n    \"tests/*\",\n    \"dpnp/_version.py\",\n]\n\n[tool.coverage.report]\nomit = [\n    \"tests/*\",\n    \"dpnp/_version.py\",\n]\n\n[tool.pytest.ini.options]\nminversion = \"6.0\"\nnorecursedirs= [\n    \".*\", \"*.egg*\", \"build\", \"dist\", \"conda-recipe\",\n]\naddopts = [\n    \"--junitxml=junit.xml\",\n    \"--ignore setup.py\",\n    \"--ignore run_test.py\",\n    \"--cov-report term-missing\",\n    \"--tb native\",\n    \"--strict\",\n    \"--durations=20\",\n    \"-q -ra\",\n]\n",
    "setup.cfg": "[pycodestyle]\nmax_line_length = 120\nignore = E201\n\n[flake8]\nmax_line_length = 120\nignore = F405\n\n[tool:pytest]\naddopts = -p no:warnings --tb=short\nnorecursedirs = tests_perf\ntestpaths = tests\n"
  },
  "cmpute/pcl.py": {
    "setup.py": "import glob\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    raise ImportError('scikit-build is required for installing')\n\nsetup(\n    name=\"pcl-py\",\n    version=\"0.2.11\",\n    description=\"Cython bindings of Point Cloud Library (PCL)\",\n    long_description='(see project homepage)',\n    author='Jacob Zhong',\n    author_email='cmpute@gmail.com',\n    url='https://github.com/cmpute/pcl.py',\n    download_url='https://github.com/cmpute/pcl.py/archive/master.zip',\n    license='BSD-3-Clause',\n    packages=['pcl', 'pcl.common', 'pcl.filters', 'pcl.io', 'pcl.visualization'],\n    install_requires=['numpy>=1.11'],\n    setup_requires=['cython>=0.29', 'scikit-build'],\n    extras_require={'test': ['pytest']},\n    package_data={'pcl': [p.lstrip(\"pcl/\") for p in (glob.glob(\"pcl/*.pyi\") + glob.glob(\"pcl/**/*.pyi\"))]},\n    classifiers=[\n        'Programming Language :: C++',\n        'Programming Language :: Cython',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: OS Independent',\n        'Development Status :: 2 - Pre-Alpha',\n        'Topic :: Scientific/Engineering'\n    ],\n    keywords=['pcl', 'pointcloud', 'numpy', 'cython', 'binding'],\n)\n"
  },
  "python-packaging-tutorial/python-packaging-tutorial": {
    "test_recipes/hello-cython/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"hello-cython\",\n    version=\"1.2.3\",\n    description=\"a minimal example package (cython version)\",\n    author=\"The scikit-build team\",\n    license=\"MIT\",\n    packages=[\"hello_cython\"],\n    package_dir={\"hello_cython\": \"hello\"},\n)\n"
  },
  "IntelPython/dpctl": {
    "examples/pybind11/use_dpctl_sycl_queue/setup.py": "#                      Data Parallel Control (dpctl)\n#\n# Copyright 2020-2022 Intel Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom skbuild import setup\n\nsetup(\n    name=\"use_queue_device\",\n    version=\"0.0.1\",\n    description=\"an example of SYCL-powered Python package (with pybind11)\",\n    author=\"Intel Scripting\",\n    license=\"Apache 2.0\",\n    packages=[\"use_queue_device\"],\n)\n",
    "examples/pybind11/onemkl_gemv/setup.py": "#                      Data Parallel Control (dpctl)\n#\n# Copyright 2020-2022 Intel Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom skbuild import setup\n\nsetup(\n    name=\"sycl_gemm\",\n    version=\"0.0.1\",\n    description=\"an example of SYCL-powered Python package (with pybind11)\",\n    author=\"Intel Scripting\",\n    license=\"Apache 2.0\",\n    packages=[\"sycl_gemm\"],\n)\n",
    "examples/pybind11/use_dpctl_sycl_kernel/setup.py": "#                      Data Parallel Control (dpctl)\n#\n# Copyright 2020-2022 Intel Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom skbuild import setup\n\nsetup(\n    name=\"use_kernel\",\n    version=\"0.0.1\",\n    description=\"an example of SYCL-powered Python package (with pybind11)\",\n    author=\"Intel Scripting\",\n    license=\"Apache 2.0\",\n    packages=[\"use_kernel\"],\n)\n",
    "setup.py": "#               Data Parallel Control Library (dpctl)\n#\n# Copyright 2020-2022 Intel Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport glob\nimport os.path\nimport pathlib\nimport shutil\nimport sys\n\nimport skbuild\nimport skbuild.setuptools_wrap\nimport skbuild.utils\nfrom skbuild.command.build_py import build_py as _skbuild_build_py\nfrom skbuild.command.install import install as _skbuild_install\n\nimport versioneer\n\n# Get long description\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as file:\n    long_description = file.read()\n\n\ndef cleanup_destination(cmake_manifest):\n    \"\"\"Delete library files from dpctl/ folder before\n    letting skbuild copy them over to avoid errors.\n    \"\"\"\n    _to_unlink = []\n    for fn in cmake_manifest:\n        bn = os.path.basename(fn)\n        # delete\n        if \"DPCTLSyclInterface\" in bn:\n            lib_fn = os.path.join(\"dpctl\", bn)\n            if os.path.exists(lib_fn):\n                _to_unlink.append(lib_fn)\n    for fn in _to_unlink:\n        pathlib.Path(fn).unlink()\n    return cmake_manifest\n\n\ndef _patched_copy_file(\n    src_file, dest_file, hide_listing=True, preserve_mode=True\n):\n    \"\"\"Copy ``src_file`` to ``dest_file`` ensuring parent directory exists.\n\n    By default, message like `creating directory /path/to/package` and\n    `copying directory /src/path/to/package -> path/to/package` are displayed\n    on standard output. Setting ``hide_listing`` to False avoids message from\n    being displayed.\n\n    NB: Patched here to not follows symbolic links\n    \"\"\"\n    # Create directory if needed\n    dest_dir = os.path.dirname(dest_file)\n    if dest_dir != \"\" and not os.path.exists(dest_dir):\n        if not hide_listing:\n            print(\"creating directory {}\".format(dest_dir))\n        skbuild.utils.mkdir_p(dest_dir)\n\n    # Copy file\n    if not hide_listing:\n        print(\"copying {} -> {}\".format(src_file, dest_file))\n    shutil.copyfile(src_file, dest_file, follow_symlinks=False)\n    shutil.copymode(src_file, dest_file, follow_symlinks=False)\n\n\nskbuild.setuptools_wrap._copy_file = _patched_copy_file\n\n\nclass BuildPyCmd(_skbuild_build_py):\n    def copy_file(self, src, dst, preserve_mode=True):\n        _patched_copy_file(src, dst, preserve_mode=preserve_mode)\n        return (dst, 1)\n\n    def build_package_data(self):\n        \"\"\"Copy data files into build directory\"\"\"\n        for package, src_dir, build_dir, filenames in self.data_files:\n            for filename in filenames:\n                target = os.path.join(build_dir, filename)\n                self.mkpath(os.path.dirname(target))\n                srcfile = os.path.join(src_dir, filename)\n                outf, copied = self.copy_file(srcfile, target)\n                srcfile = os.path.abspath(srcfile)\n\n\nclass InstallCmd(_skbuild_install):\n    def run(self):\n        ret = super().run()\n        if \"linux\" in sys.platform:\n            this_dir = os.path.dirname(os.path.abspath(__file__))\n            dpctl_build_dir = os.path.join(this_dir, self.build_lib, \"dpctl\")\n            dpctl_install_dir = os.path.join(self.install_libbase, \"dpctl\")\n            sofiles = glob.glob(\n                os.path.join(dpctl_build_dir, \"*DPCTLSyclInterface.so*\")\n            )\n            # insert actual file at the beginning of the list\n            pos = [i for i, fn in enumerate(sofiles) if not os.path.islink(fn)]\n            if pos:\n                hard_file = sofiles.pop(pos[0])\n                sofiles.insert(0, hard_file)\n            for fn in sofiles:\n                base_fn = os.path.basename(fn)\n                src_file = os.path.join(dpctl_build_dir, base_fn)\n                dst_file = os.path.join(dpctl_install_dir, base_fn)\n                os.remove(dst_file)\n                _patched_copy_file(src_file, dst_file)\n        return ret\n\n\ndef _get_cmdclass():\n    cmdclass = versioneer.get_cmdclass(\n        cmdclass={\n            \"build_py\": BuildPyCmd,\n            \"install\": InstallCmd,\n        }\n    )\n    return cmdclass\n\n\nskbuild.setup(\n    name=\"dpctl\",\n    version=versioneer.get_version(),\n    cmdclass=_get_cmdclass(),\n    description=\"A lightweight Python wrapper for a subset of SYCL.\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    license=\"Apache 2.0\",\n    author=\"Intel Corporation\",\n    url=\"https://github.com/IntelPython/dpctl\",\n    packages=[\n        \"dpctl\",\n        \"dpctl.memory\",\n        \"dpctl.tensor\",\n        \"dpctl.program\",\n        \"dpctl.utils\",\n    ],\n    package_data={\"dpctl\": [\"tests/*.*\", \"tests/helper/*.py\"]},\n    include_package_data=True,\n    zip_safe=False,\n    setup_requires=[\"Cython\"],\n    install_requires=[\n        \"numpy\",\n    ],\n    extras_require={\n        \"docs\": [\n            \"Cython\",\n            \"sphinx\",\n            \"sphinx_rtd_theme\",\n            \"pydot\",\n            \"graphviz\",\n            \"sphinxcontrib-programoutput\",\n        ],\n        \"coverage\": [\"Cython\", \"pytest\", \"pytest-cov\", \"coverage\", \"tomli\"],\n    },\n    keywords=\"dpctl\",\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n    ],\n    cmake_process_manifest_hook=cleanup_destination,\n)\n",
    "pyproject.toml": "[tool.black]\nexclude = \"versioneer.py|dpctl/_version.py\"\nline-length = 80\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nensure_newline_before_comments = true\nline_length = 80\nskip = [\"versioneer.py\", \"dpctl/_version.py\"]\n\n[tool.coverage.run]\nplugins = [\n    \"Cython.Coverage\"\n]\nbranch = true\nsource = [\n    \"dpctl\"\n]\nomit = [\n    \"dpctl/tests/*\",\n    \"dpctl/_version.py\",\n    \"*/_cython_api*/stringsource\",\n]\n\n[tool.coverage.report]\nomit = [\n    \"dpctl/tests/*\",\n    \"dpctl/_version.py\",\n    \"*/_cython_api*/stringsource\",\n]\n\n[tool.pytest.ini.options]\nminversion = \"6.0\"\nnorecursedirs= [\n    \".*\", \"*.egg*\", \"build\", \"dist\", \"conda-recipe\",\n]\naddopts = [\n    \"--junitxml=junit.xml\",\n    \"--ignore setup.py\",\n    \"--ignore run_test.py\",\n    \"--cov-report term-missing\",\n    \"--tb native\",\n    \"--strict\",\n    \"--durations=20\",\n    \"-q -ra\",\n]\n",
    "setup.cfg": "[versioneer]\nVCS = git\nversionfile_source = dpctl/_version.py\nversionfile_build = dpctl/_version.py\ntag_prefix =\nparentdir_prefix = dpctl-\n\n[bdist_wheel]\nuniversal=1\n",
    "examples/pybind11/external_usm_allocation/setup.py": "#                      Data Parallel Control (dpctl)\n#\n# Copyright 2020-2022 Intel Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom skbuild import setup\n\nsetup(\n    name=\"external_usm_allocation\",\n    version=\"0.0.1\",\n    description=\"an example of SYCL-powered Python package (with pybind11)\",\n    author=\"Intel Scripting\",\n    license=\"Apache 2.0\",\n    packages=[\"external_usm_allocation\"],\n)\n"
  },
  "InsightSoftwareConsortium/ITKPythonPackage": {
    "scripts/setup.py.in": "\n# Generated using: @SETUP_GENERATOR@\n\nfrom __future__ import print_function\nfrom os import sys, path\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\n@SETUP_PRE_CODE@\n\nlong_description = '@SETUP_NAME@\\n'\nlong_description += '====================================\\n\\n'\nlong_description += '@SETUP_LONG_DESCRIPTION@\\n\\n'\n\nthis_directory = path.abspath(path.dirname(__file__))\nitk_readme_path = path.join(this_directory, 'ITK-source', 'ITK', 'README.md')\nif path.exists(itk_readme_path):\n    with open(itk_readme_path, encoding='utf-8') as f:\n        long_description += f.read()\nelse:\n    with open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n        long_description += f.read()\n\n\nsetup(\n    name='@SETUP_NAME@',\n    version=@SETUP_VERSION@,\n    author='Insight Software Consortium',\n    author_email='community@itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    cmake_args=[@SETUP_CMAKE_ARGS@],\n    py_modules=[@SETUP_PY_MODULES@],\n    download_url=r'@SETUP_DOWNLOAD_URL@',\n    description=r'@SETUP_DESCRIPTION@',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit @SETUP_EXTRA_KEYWORDS@',\n    url=r'https://itk.org/',\n    install_requires=[\n@SETUP_INSTALL_REQUIRES@\n    ]\n    )\n@SETUP_POST_CODE@\n",
    "setup.py": "\n# Generated using: python setup_py_configure.py 'itk'\n\nfrom __future__ import print_function\nfrom os import sys, path\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsys.path.append(path.dirname(path.dirname(path.abspath(__file__))))\nfrom itkVersion import get_versions\n\nthis_directory = path.abspath(path.dirname(__file__))\nitk_readme_path = path.join(this_directory, 'ITK-source', 'ITK', 'README.md')\nif path.exists(itk_readme_path):\n    with open(itk_readme_path, encoding='utf-8') as f:\n        long_description = f.read()\nelse:\n    with open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n        long_description = f.read()\n\nsetup(\n    name='itk',\n    version=get_versions()['package-version'],\n    author='Insight Software Consortium',\n    author_email='community@itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    cmake_args=[],\n    py_modules=[\n        'itkBase',\n        'itkConfig',\n        'itkExtras',\n        'itkLazy',\n        'itkTemplate',\n        'itkTypes',\n        'itkVersion',\n        'itkBuildOptions'\n    ],\n    download_url=r'https://itk.org/ITK/resources/software.html',\n    description=r'ITK is an open-source toolkit for multidimensional image analysis',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit segmentation registration image imaging',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'numpy',\n    ]\n    )\n"
  },
  "Nicholaswogan/numbalsoda": {
    "setup.py": "from skbuild import setup\n\nfrom os import path\nthis_directory = path.abspath(path.dirname(__file__))\nwith open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup(\n    name=\"numbalsoda\",\n    packages=['numbalsoda'],\n    version='0.3.6',\n    license='MIT',\n    install_requires=['numpy','numba'],\n    author = 'Nicholas Wogan',\n    author_email = 'nicholaswogan@gmail.com',\n    description = 'Python wrapper of LSODA (solving ODEs)'+\\\n                  ' which can be called from within numba functions.',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    python_requires='>3.6',\n    url = \"https://github.com/Nicholaswogan/numbalsoda\",\n    cmake_args=['-DSKBUILD=ON']\n    )",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\"]\n",
    "setup.cfg": "[metadata]\nlicense_file = LICENSE.txt\ndescription-file = README.md"
  },
  "ORNL/TASMANIAN": {
    "InterfacePython/PipInstaller/setup.py": "\nimport sys, site\n\n# do standard skbuild setup\nfrom packaging import version\nfrom skbuild.exceptions import SKBuildError\nfrom skbuild.cmaker import get_cmake_version\nfrom skbuild import setup  # This line replaces 'from setuptools import setup'\n\n# Add CMake as a build requirement if cmake is not installed or too old\nsetup_requires = []\ntry:\n    if version.parse(get_cmake_version()) < version.parse(\"3.19\"):\n        setup_requires.append('cmake>=3.19')\nexcept SKBuildError:\n    setup_requires.append('cmake>=3.19')\nsetup_requires.append('numpy>=1.10')\n\nwith open('README.md', 'r') as fh:\n     readme_file = fh.readlines()\n\nlong_description = \"\"\nfor line in readme_file[3:]:\n    if line.rstrip() == \"Quick Install\":\n        break\n    else:\n        long_description += line\n\nlong_description += \"### Quick Install\\n Tasmanian supports `--user` and venv install only, see the on-line documentation for details.\\n\"\n\n# find out whether this is a virtual environment, real_prefix is an older test, base_refix is the newer one\nif hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):\n    final_install_path = sys.prefix # sys.prefix points to the virtual environment root\n    isvirtual = True\nelse:\n    isvirtual = False\n    try:\n        final_install_path = site.getuserbase()\n    except:\n        import os\n        # some implementations do not provide compatible 'site' package, assume default Linux behavior\n        final_install_path = os.getenv('HOME') + \"/.local/\"\n\n# check if using OSX Framework environment\nisosxframework = False\nif sys.platform == 'darwin':\n    try:\n        if 'python/site-packages' in site.getusersitepackages():\n            # appears to be Mac Framework using Library/Python/X.Y/lib/python/site-packages\n            isosxframework = True\n    except:\n        # cannot determine if using Mac Framework\n        pass\n\n# setup cmake arguments\ncmake_args=[\n        '-DCMAKE_BUILD_TYPE=Release',\n        '-DBUILD_SHARED_LIBS=ON',\n        '-DTasmanian_ENABLE_RECOMMENDED:BOOL=ON',\n        '-DTasmanian_ENABLE_PYTHON:BOOL=ON',\n        '-DPython_EXECUTABLE:PATH={0:1s}'.format(sys.executable),\n        '-DTasmanian_python_pip_final:PATH={0:1s}/'.format(final_install_path),\n        ]\nif isvirtual:\n    cmake_args.append('-DTasmanian_windows_virtual:BOOL=ON')\nif isosxframework:\n    cmake_args.append('-DTasmanian_osx_framework:BOOL=ON')\n\n\n# call the actual package setup command\nsetup(\n    name='Tasmanian',\n    version='7.10beta1',\n    author='Miroslav Stoyanov',\n    author_email='stoyanovmk@ornl.gov',\n    description='UQ library for sparse grids, optimization and Bayesian inference',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url='https://tasmanian.ornl.gov',\n    classifiers=[\n        'Programming Language :: Python :: 3',\n        'Programming Language :: C++',\n        'Operating System :: OS Independent',\n    ],\n    install_requires=['numpy>=1.10'],\n    ### cmake portion of the setup, specific to skbuild ###\n    setup_requires=setup_requires,\n    cmake_args=cmake_args,\n    py_modules=[]\n)\n",
    "InterfacePython/PipInstaller/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build>=0.10.0\", \"packaging\"]\n"
  },
  "seung-lab/DracoPy": {
    "setup.py": "import setuptools\nimport os\nimport platform\nimport sys\n\nfrom skbuild import setup\nfrom skbuild.constants import CMAKE_INSTALL_DIR, skbuild_plat_name\nfrom skbuild.exceptions import SKBuildError\nfrom skbuild.cmaker import get_cmake_version\n\nimport numpy as np\nimport multiprocessing as mp\n\nif not \"CMAKE_BUILD_PARALLEL_LEVEL\" in os.environ:\n    os.environ[\"CMAKE_BUILD_PARALLEL_LEVEL\"] = str(mp.cpu_count())\n\ndef read(fname):\n  with open(os.path.join(os.path.dirname(__file__), fname), 'rt') as f:\n    return f.read()\n\n# Add CMake as a build requirement if cmake is not installed or is too low a version\nsetup_requires = ['cython']\nsetup_requires.append('cmake<3.15')\n\n# If you want to re-build the cython cpp file (DracoPy.cpp), run:\n# cython --cplus -3 -I./_skbuild/linux-x86_64-3.6/cmake-install/include/draco/ ./src/DracoPy.pyx\n# Replace \"linux-x86_64-3.6\" with the directory under _skbuild in your system\n# Draco must already be built/setup.py already be run before running the above command\n\nsrc_dir = './src'\nlib_dirs = [os.path.abspath(os.path.join(CMAKE_INSTALL_DIR(), 'lib/')),\n            os.path.abspath(os.path.join(CMAKE_INSTALL_DIR(), 'lib64/'))]\ncmake_args = []\n\noperating_system = platform.system().lower()\n\nis_macos = sys.platform == 'darwin' or operating_system == \"darwin\"\nis_windows = sys.platform == 'win32' or operating_system == \"windows\"\n\nif is_macos:\n    plat_name = skbuild_plat_name()\n    sep = [pos for pos, char in enumerate(plat_name) if char == '-']\n    assert len(sep) == 2\n    cmake_args = [\n        '-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING='+plat_name[sep[0]+1:sep[1]],\n        '-DCMAKE_OSX_ARCHITECTURES:STRING='+plat_name[sep[1]+1:]\n    ]\n    library_link_args = [\n        f'-l{lib}' for lib in ('draco',)\n    ]\nelif is_windows:\n    library_link_args = [\n        lib for lib in ('draco.lib',)\n    ]\nelse: # linux\n    library_link_args = [\n        f'-l:{lib}' for lib in ('libdraco.a',)\n    ]\n\ncmake_args.append(\"-DCMAKE_POSITION_INDEPENDENT_CODE=ON\") # make -fPIC code\n\nif is_windows:\n    extra_link_args = ['/LIBPATH:{0}'.format(lib_dir) for lib_dir in lib_dirs] + library_link_args\n    extra_compile_args = [\n      '/std:c++17', '/O2',\n    ]\nelse:\n    extra_link_args = ['-L{0}'.format(lib_dir) for lib_dir in lib_dirs] + library_link_args\n    extra_compile_args = [\n      '-std=c++11','-O3'\n    ]\n\nsetup(\n    name='DracoPy',\n    version='1.3.0',\n    description = 'Python wrapper for Google\\'s Draco Mesh Compression Library',\n    author = 'Manuel Castro, William Silversmith :: Contributors :: Fatih Erol, Faru Nuri Sonmez, Zeyu Zhao, Denis Riviere',\n    author_email = 'macastro@princeton.edu, ws9@princeton.edu',\n    url = 'https://github.com/seung-lab/DracoPy',\n    long_description=read('README.md'),\n    long_description_content_type=\"text/markdown\",\n    license = \"License :: OSI Approved :: Apache Software License\",\n    cmake_source_dir='./draco',\n    cmake_args=cmake_args,\n    setup_requires=setup_requires,\n    ext_modules=[\n        setuptools.Extension(\n            'DracoPy',\n            sources=[ os.path.join(src_dir, 'DracoPy.pyx') ],\n            depends=[ os.path.join(src_dir, 'DracoPy.h') ],\n            language='c++',\n            include_dirs = [\n                np.get_include(),\n                os.path.join(CMAKE_INSTALL_DIR(), 'include/'),\n            ],\n            extra_compile_args=extra_compile_args,\n            extra_link_args=extra_link_args\n        )\n    ],\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Topic :: Scientific/Engineering\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: Microsoft :: Windows :: Windows 10\",\n        \"Topic :: Utilities\",\n  ]\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n\t\"setuptools\",\n\t\"scikit-build >= 0.9.0\",\n\t\"wheel\",\n\t\"oldest-supported-numpy\"\n]"
  },
  "ssciwr/clang-format-wheel": {
    "setup.py": "\nfrom wheel.bdist_wheel import bdist_wheel as _bdist_wheel\nfrom skbuild import setup\n\nimport re\nimport os\n\nclass genericpy_bdist_wheel(_bdist_wheel):\n    def finalize_options(self):\n        _bdist_wheel.finalize_options(self)\n        self.root_is_pure = False\n\n    def get_tag(self):\n        python, abi, plat = _bdist_wheel.get_tag(self)\n        python, abi = \"py2.py3\", \"none\"\n        return python, abi, plat\n\n# Read the clang-format version from the \"single source of truth\"\ndef get_version():\n    with open(\"clang-format_version.cmake\", \"r\") as version_file:\n        parsed = {}\n        for line in version_file:\n            match = re.match(\"set\\((.*) (.*)\\)\", line)\n            if len(match.groups()) != 2:\n                raise ValueError(\"Version File not readable\")\n            parsed[match.groups()[0]] = match.groups()[1]\n        if parsed['CLANG_FORMAT_WHEEL_VERSION'] == \"0\":\n            return f\"{parsed['CLANG_FORMAT_VERSION']}\"\n        else:\n            return f\"{parsed['CLANG_FORMAT_VERSION']}.{parsed['CLANG_FORMAT_WHEEL_VERSION']}\"\n\ndef get_cmake_args_from_env():\n    cmake_args = []\n    for cmake_arg in [\"CMAKE_OSX_ARCHITECTURES\"]:\n        cmake_arg_value = os.environ.get(cmake_arg)\n        if cmake_arg_value:\n            cmake_args.append(f\"-D{cmake_arg}={cmake_arg_value}\")\n    return cmake_args\n\n# Parse the given README file\nwith open(\"README.md\", \"r\") as readme_file:\n    readme = readme_file.read()\n\ncmdclass = {\"bdist_wheel\": genericpy_bdist_wheel}\nsetup(\n    name=\"clang-format\",\n    version=get_version(),\n    cmdclass=cmdclass,\n    author=\"Dominic Kempf\",\n    author_email=\"ssc@iwr.uni-heidelberg.de\",\n    packages=[\"clang_format\"],\n    zip_safe=False,\n    entry_points={\n        \"console_scripts\": [\n            \"clang-format=clang_format:clang_format\",\n            \"git-clang-format=clang_format:git_clang_format\",\n            \"clang-format-diff.py=clang_format:clang_format_diff\"\n        ]\n    },\n    description=\"Clang-Format is an LLVM-based code formatting tool\",\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n    url=\"http://clang.llvm.org/\",\n    project_urls={\n        \"Documentation\": \"https://clang.llvm.org/docs/ClangFormat.html\",\n        \"Source\": \"https://github.com/ssciwr/clang-format-wheel\"\n    },\n    download_url=\"https://github.com/llvm/llvm-project/releases\",\n    classifiers=[\n        \"Programming Language :: C\",\n        \"Programming Language :: C++\",\n        \"Operating System :: OS Independent\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: Software Development :: Quality Assurance\",\n    ],\n    license=\"Apache 2.0\",\n    cmake_args=get_cmake_args_from_env(),\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.16\", \"ninja; platform_system!='Windows'\"]\n\n[tool.cibuildwheel]\n# Super-verbose output for debugging purpose\nbuild-verbosity = 3\n\n# We restrict ourselves to CPython 3.8 and then repair the wheels to be\n# independent of the Python version - I have not found a different solution\n# within cibuildwheel to achieve this.\nbuild = \"cp38-*\"\n\n# Testing commands for our wheels\nbefore-test = [\n    \"git config --global user.name Name\",\n    \"git config --global user.email foo@bar.com\"\n]\ntest-requires = [\"pytest\", \"pytest-git\"]\ntest-command = \"pytest {package}/test\""
  },
  "WildMeOrg/wildbook-ia": {
    "setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport sys\nfrom collections import OrderedDict\nfrom os.path import exists\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\ndef native_mb_python_tag(plat_impl=None, version_info=None):\n    \"\"\"\n    Example:\n        >>> print(native_mb_python_tag())\n        >>> print(native_mb_python_tag('PyPy', (2, 7)))\n        >>> print(native_mb_python_tag('CPython', (3, 8)))\n    \"\"\"\n    if plat_impl is None:\n        import platform\n\n        plat_impl = platform.python_implementation()\n\n    if version_info is None:\n        import sys\n\n        version_info = sys.version_info\n\n    major, minor = version_info[0:2]\n    ver = '{}{}'.format(major, minor)\n\n    if plat_impl == 'CPython':\n        # TODO: get if cp27m or cp27mu\n        impl = 'cp'\n        if ver == '27':\n            IS_27_BUILT_WITH_UNICODE = True  # how to determine this?\n            if IS_27_BUILT_WITH_UNICODE:\n                abi = 'mu'\n            else:\n                abi = 'm'\n        else:\n            if ver == '38':\n                # no abi in 38?\n                abi = ''\n            else:\n                abi = 'm'\n        mb_tag = '{impl}{ver}-{impl}{ver}{abi}'.format(**locals())\n    elif plat_impl == 'PyPy':\n        abi = ''\n        impl = 'pypy'\n        ver = '{}{}'.format(major, minor)\n        mb_tag = '{impl}-{ver}'.format(**locals())\n    else:\n        raise NotImplementedError(plat_impl)\n    return mb_tag\n\n\ndef parse_version(fpath='wbia/__init__.py'):\n    \"\"\"\n    Statically parse the version number from a python file\n\n\n    \"\"\"\n    import ast\n\n    if not exists(fpath):\n        raise ValueError('fpath={!r} does not exist'.format(fpath))\n    with open(fpath, 'r') as file_:\n        sourcecode = file_.read()\n    pt = ast.parse(sourcecode)\n\n    class VersionVisitor(ast.NodeVisitor):\n        def visit_Assign(self, node):\n            for target in node.targets:\n                if getattr(target, 'id', None) == '__version__':\n                    self.version = node.value.s\n\n    visitor = VersionVisitor()\n    visitor.visit(pt)\n    return visitor.version\n\n\ndef parse_long_description(fpath='README.rst'):\n    \"\"\"\n    Reads README text, but doesn't break if README does not exist.\n    \"\"\"\n    if exists(fpath):\n        with open(fpath, 'r') as file:\n            return file.read()\n    return ''\n\n\ndef parse_requirements(fname='requirements.txt', with_version=True):\n    \"\"\"\n    Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        with_version (bool, default=True): if true include version specs\n\n    Returns:\n        List[str]: list of requirements items\n\n    CommandLine:\n        python -c \"import setup; print(setup.parse_requirements())\"\n        python -c \"import setup; print(chr(10).join(setup.parse_requirements(with_version=True)))\"\n    \"\"\"\n    import re\n    from os.path import exists\n\n    require_fpath = fname\n\n    def parse_line(line):\n        \"\"\"\n        Parse information from a line in a requirements text file\n        \"\"\"\n        if line.startswith('-r '):\n            # Allow specifying requirements in other files\n            target = line.split(' ')[1]\n            for info in parse_require_file(target):\n                yield info\n        else:\n            info = {'line': line}\n            if line.startswith('-e '):\n                info['package'] = line.split('#egg=')[1]\n            else:\n                # Remove versioning from the package\n                pat = '(' + '|'.join(['>=', '==', '>']) + ')'\n                parts = re.split(pat, line, maxsplit=1)\n                parts = [p.strip() for p in parts]\n\n                info['package'] = parts[0]\n                if len(parts) > 1:\n                    op, rest = parts[1:]\n                    if ';' in rest:\n                        # Handle platform specific dependencies\n                        # http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies\n                        version, platform_deps = map(str.strip, rest.split(';'))\n                        info['platform_deps'] = platform_deps\n                    else:\n                        version = rest  # NOQA\n                    info['version'] = (op, version)\n            yield info\n\n    def parse_require_file(fpath):\n        with open(fpath, 'r') as f:\n            for line in f.readlines():\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    for info in parse_line(line):\n                        yield info\n\n    def gen_packages_items():\n        if exists(require_fpath):\n            for info in parse_require_file(require_fpath):\n                parts = [info['package']]\n                if with_version and 'version' in info:\n                    parts.extend(info['version'])\n                if not sys.version.startswith('3.4'):\n                    # apparently package_deps are broken in 3.4\n                    platform_deps = info.get('platform_deps')\n                    if platform_deps is not None:\n                        parts.append(';' + platform_deps)\n                item = ''.join(parts)\n                yield item\n\n    packages = list(gen_packages_items())\n    return packages\n\n\nNAME = 'wildbook-ia'\n\n\nMB_PYTHON_TAG = native_mb_python_tag()  # NOQA\n\nAUTHORS = [\n    'Jason Parham',\n    'Dr. Jon Crall',\n    'Dr. Charles Stewart',\n    'Drew Blount',\n    'Ben Scheiner',\n    'Wild Me Developers',\n    'Karen Chan',\n    'Michael Mulich',\n    'Hendrik Weideman',\n    'A. Batbouta',\n    'A. Beard',\n    'Z. Jablons',\n    'D. Lowe',\n    'Z. Rutfield',\n    'K. Southerland',\n    'A. Weinstock',\n    'J. Wrona',\n]\nAUTHOR_EMAIL = 'dev@wildme.org'\nURL = 'https://github.com/WildMeOrg/wildbook-ia'\nLICENSE = 'Apache License 2.0'\nDESCRIPTION = 'Wildbook IA (WBIA) - Machine learning service for the WildBook project'\nKEYWORDS = [\n    'wildbook',\n    'wildme',\n    'ibeis',\n    'ecological',\n    'wildlife',\n    'conservation',\n    'machine learning',\n    'ai',\n    'hotspotter',\n    'detection',\n    'classification',\n    'animal ID',\n    're-id',\n    're-identification',\n    'flukebook',\n]\n\n\nKWARGS = OrderedDict(\n    name=NAME,\n    author=', '.join(AUTHORS),\n    author_email=AUTHOR_EMAIL,\n    description=DESCRIPTION,\n    long_description=parse_long_description('README.rst'),\n    long_description_content_type='text/x-rst',\n    keywords=', '.join(KEYWORDS),\n    url=URL,\n    license=LICENSE,\n    install_requires=parse_requirements('requirements/runtime.txt')\n    + parse_requirements('requirements/pinned.txt'),\n    extras_require={\n        'all': parse_requirements('requirements.txt'),\n        'tests': parse_requirements('requirements/tests.txt'),\n        'build': parse_requirements('requirements/build.txt'),\n        'runtime': parse_requirements('requirements/runtime.txt'),\n        'pinned': parse_requirements('requirements/pinned.txt'),\n        'problematic': parse_requirements('requirements/problematic.txt'),\n        'postgres': parse_requirements('requirements/postgres.txt'),\n    },\n    # --- VERSION ---\n    # The following settings retreive the version from git.\n    # See https://github.com/pypa/setuptools_scm/ for more information\n    setup_requires=['setuptools_scm'],\n    use_scm_version={\n        'write_to': 'wbia/_version.py',\n        'write_to_template': '__version__ = \"{version}\"',\n        'tag_regex': '^(?P<prefix>v)?(?P<version>[^\\\\+]+)(?P<suffix>.*)?$',\n        'local_scheme': 'dirty-tag',\n    },\n    packages=find_packages(),\n    package_dir={'wbia': 'wbia'},\n    python_requires='>=3.7, <4',\n    include_package_data=True,\n    # List of classifiers available at:\n    # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Console',\n        'Environment :: Web Environment',\n        'Environment :: GPU',\n        'Environment :: GPU :: NVIDIA CUDA :: 11.0',\n        'Natural Language :: English',\n        'License :: OSI Approved :: Apache Software License',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'Operating System :: MacOS :: MacOS X',\n        'Operating System :: Unix',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n        'Topic :: Utilities',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3 :: Only',\n    ],\n    project_urls={  # Optional\n        'Bug Reports': 'https://github.com/WildMeOrg/wildbook-ia/issues',\n        'Funding': 'https://www.wildme.org/donate/',\n        'Say Thanks!': 'https://community.wildbook.org',\n        'Source': URL,\n    },\n    entry_points=\"\"\"\\\n    [console_scripts]\n    wbia-init-testdbs = wbia.cli.testdbs:main\n    wbia-convert-hsdb = wbia.cli.convert_hsdb:main\n    wbia-migrate-sqlite-to-postgres = wbia.cli.migrate_sqlite_to_postgres:main\n    wbia-compare-databases = wbia.cli.compare_databases:main\n    \"\"\",\n)\n\nif __name__ == '__main__':\n    \"\"\"\n    python -c \"import wbia; print(wbia.__file__)\"\n    \"\"\"\n    setup(**KWARGS)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools==59.5.0\", \"wheel\", \"setuptools_scm[toml]==6.3.2\", \"scikit-build\", \"cmake\", \"ninja\"]\n",
    "setup.cfg": "[flake8]\nexclude = .git,.env,wbia/scripts/chuck_examples\n# This section configures `flake8`, the python linting utility.\n# See also https://flake8.pycqa.org/en/latest/user/configuration.html\nignore = D100,D101,D102,D103,D105,D200,D205,D210,D400,D401,D403,E203,E501,N802,N803,N804,N805,N806,W503\n\n# D100 - Missing docstring in public module\n# D101 - Missing docstring in public class\n# D102 - Missing docstring in public method\n# D103 - Missing docstring in public function\n# D105 - Missing docstring in public package\n# D200 - One-line docstring should fit on one line with quotes\n# D205 - 1 blank line required between summary line and description\n# D210 - No whitespaces allowed surrounding docstring text\n# D400 - First line should end with a period\n# D401 - First line should be in imperative mood\n# D403 - First word of the first line should be properly capitalized\n# D* codes come from pydocstyle which is integrated into flake8 via flake8-docstring.\n# See also http://www.pydocstyle.org/en/5.0.1/error_codes.html\n\n# E203 - whitespace before ':'\n# E501 - line too long (82 > 79 characters)\n# E* codes come from pycodestyle which is integrated with flake8\n# See also https://pycodestyle.pycqa.org/en/latest/intro.html#error-codes\n\n# N802 - function name should be lowercase\n# N803 - argument name should be lowercase\n# N804 - first argument of a classmethod should be named \u2018cls\u2019\n# N805 - first argument of a method should be named \u2018self\u2019\n# N806 - variable in function should be lowercase\n# N* codes come from pep8-naming, which integrates with flake8\n# See also https://github.com/PyCQA/pep8-naming#error-codes\n\n# W503 - line break before binary operator\n# W* codes come from pycodestyle which is integrated with flake8\n# See also https://pycodestyle.pycqa.org/en/latest/intro.html#error-codes\n\n[tool:brunette]\nline-length = 90\nverbose = false\nskip-string-normalization = true\nsingle-quotes = true\n\n[tool:isort]\nprofile = black\nline_length = 90\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nensure_newline_before_comments = true\n\n[tool:pytest]\nminversion = 5.4\naddopts = -v -p no:doctest --xdoctest --xdoctest-style=google  --random-order --random-order-bucket=global -r fEs\ntestpaths =\n    wbia\nnorecursedirs =\n    /virtualenv\n    ../../virtualenv\npython_classes = !TestResult\nfilterwarnings =\n    default\n    ignore:.*No cfgstr given in Cacher constructor or call.*:Warning\n    ignore:.*Define the __nice__ method for.*:Warning\n    ignore:.*distutils Version classes are deprecated. Use packaging.version instead.*:DeprecationWarning\n    ignore:.*setapi\\(\\) is deprecated.*:DeprecationWarning\n\n[metadata]\n# This includes the license file(s) in the wheel.\nlicense_files = LICENSE.txt\n"
  },
  "wjakob/nanobind_example": {
    "setup.py": "import sys\n\ntry:\n    from skbuild import setup\n    import nanobind\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nsetup(\n    name=\"nanobind_example\",\n    version=\"0.0.1\",\n    author=\"Wenzel Jakob\",\n    author_email=\"wenzel.jakob@epfl.ch\",\n    description=\"An example minimal project that compiles bindings using nanobind and scikit-build\",\n    url=\"https://github.com/wjakob/nanobind_example\",\n    license=\"BSD\",\n    packages=['nanobind_example'],\n    package_dir={'': 'src'},\n    cmake_install_dir=\"src/nanobind_example\",\n    include_package_data=True,\n    python_requires=\">=3.8\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build>=0.16.7\",\n    \"cmake>=3.18\",\n    \"nanobind>=1.1.0\",\n    \"ninja; platform_system!='Windows'\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "rapidsai/kvikio": {
    "python/setup.py": "# Copyright (c) 2021-2023, NVIDIA CORPORATION. All rights reserved.\n# See file LICENSE for terms.\n\nimport versioneer\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nsetup(\n    name=\"kvikio\",\n    version=versioneer.get_version(),\n    description=\"KvikIO - GPUDirect Storage\",\n    url=\"https://github.com/rapidsai/kvikio\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n    ],\n    # Include the separately-compiled shared library\n    extras_require={\"test\": [\"pytest\", \"pytest-xdist\"]},\n    packages=find_packages(exclude=[\"tests*\"]),\n    package_data={\n        # Note: A dict comprehension with an explicit copy is necessary (rather\n        # than something simpler like a dict.fromkeys) because otherwise every\n        # package will refer to the same list and skbuild modifies it in place.\n        key: [\"*.pyi\", \"*.pxd\"]\n        for key in find_packages(include=[\"kvikio._lib\"])\n    },\n    cmdclass=versioneer.get_cmdclass(),\n    zip_safe=False,\n)\n",
    "python/pyproject.toml": "# Copyright (c) 2021-2022, NVIDIA CORPORATION. All rights reserved.\n# See file LICENSE for terms.\n\n[build-system]\nrequires = [\n    \"wheel\",\n    \"setuptools\",\n    \"Cython>=0.29,<0.30\",\n    \"scikit-build>=0.13.1\",\n    \"cmake>=3.23.1,!=3.25.0\",\n    \"ninja\",\n]\n\n[tool.black]\nline-length = 88\ntarget-version = [\"py39\"]\ninclude = '\\.py?$'\nexclude = '''\n/(\n    thirdparty |\n    \\.eggs |\n    \\.git |\n    \\.hg |\n    \\.mypy_cache |\n    \\.tox |\n    \\.venv |\n    _build |\n    buck-out |\n    build |\n    dist |\n    _skbuild\n)/\n'''\n",
    "python/setup.cfg": "# Copyright (c) 2022-2023, NVIDIA CORPORATION.\n\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = kvikio/_version.py\nversionfile_build = kvikio/_version.py\ntag_prefix = v\nparentdir_prefix = kvikio-\n\n[flake8]\nfilename = *.py, *.pyx, *.pxd, *.pxi\nforce-check = True\nmax-line-length = 88\nexclude =\n    .eggs,\n    *.egg,\n    build,\n    docs,\n    .git,\n    versioneer.py,\n    _version.py,\n    _skbuild,\nignore =\n    # line break before binary operator\n    W503,\n    # whitespace before :\n    E203\nper-file-ignores =\n    # Ignore black/flake8-pyi conflicts\n    *.pyi:E301 E302 E704\n    # Rules ignored only in Cython:\n    # E211: whitespace before '(' (used in multi-line imports)\n    # E225: Missing whitespace around operators (breaks cython casting syntax like <int>)\n    # E226: Missing whitespace around arithmetic operators (breaks cython pointer syntax like int*)\n    # E227: Missing whitespace around bitwise or shift operator (Can also break casting syntax)\n    # E275: Missing whitespace after keyword (Doesn't work with Cython except?)\n    # E402: invalid syntax (works for Python, not Cython)\n    # E999: invalid syntax (works for Python, not Cython)\n    # W503: line break before binary operator (breaks lines that start with a pointer)\n    # W504: line break after binary operator (breaks lines that end with a pointer)\n    *.pyx: E211, E225, E226, E227, E275, E402, E999, W503, W504\n    *.pxd: E211, E225, E226, E227, E275, E402, E999, W503, W504\n    *.pxi: E211, E225, E226, E227, E275, E402, E999, W503, W504\n\n[isort]\nline_length=88\nmulti_line_output=3\ninclude_trailing_comma=True\nforce_grid_wrap=0\ncombine_as_imports=True\norder_by_type=True\nknown_rapids=\n    nvtext\n    cudf\n    cuml\n    cugraph\n    dask_cudf\nknown_first_party=\n    cufile\n    kvikio\n    legate_kvikio\ndefault_section=THIRDPARTY\nsections=FUTURE,STDLIB,THIRDPARTY,RAPIDS,FIRSTPARTY,LOCALFOLDER\nskip=\n    thirdparty\n    .eggs\n    .git\n    .hg\n    .mypy_cache\n    .tox\n    .venv\n    _build\n    buck-out\n    build\n    dist\n    __init__.py\n\n[options]\npackages = find:\npython_requires = >=3.9\n\n[options.extras_require]\nnvcomp =\n    numpy >=1.20\n    cupy >=9.5.0\n\n[mypy]\nignore_missing_imports = True\n",
    "legate/setup.py": "# Copyright (c) 2021-2023, NVIDIA CORPORATION. All rights reserved.\n# See file LICENSE for terms.\n\n\nimport os\nfrom pathlib import Path\n\nimport versioneer\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport legate.install_info as lg_install_info\n\nlegate_dir = Path(lg_install_info.libpath).parent.as_posix()\n\ncmake_flags = [\n    f\"-Dlegate_core_ROOT:STRING={legate_dir}\",\n]\n\nos.environ[\"SKBUILD_CONFIGURE_OPTIONS\"] = \" \".join(cmake_flags)\n\n\nsetup(\n    name=\"legate_kvikio\",\n    version=versioneer.get_version(),\n    description=\"KvikIO - GPUDirect Storage\",\n    url=\"https://github.com/rapidsai/kvikio\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n    ],\n    packages=find_packages(exclude=[\"tests*\"]),\n    include_package_data=True,\n    cmdclass=versioneer.get_cmdclass(),\n    zip_safe=False,\n)\n",
    "legate/setup.cfg": "# Copyright (c) 2023, NVIDIA CORPORATION.\n\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = legate_kvikio/_version.py\nversionfile_build = legate_kvikio/_version.py\ntag_prefix = v\nparentdir_prefix = legate_kvikio-\n\n[flake8]\nfilename = *.py, *.pyx, *.pxd, *.pxi\nforce-check = True\nmax-line-length = 88\nexclude =\n    .eggs,\n    *.egg,\n    build,\n    docs,\n    .git,\n    versioneer.py,\n    _version.py,\n    _skbuild,\nignore =\n    # line break before binary operator\n    W503,\n    # whitespace before :\n    E203\nper-file-ignores =\n    # Ignore black/flake8-pyi conflicts\n    *.pyi:E301 E302 E704\n    # Rules ignored only in Cython:\n    # E211: whitespace before '(' (used in multi-line imports)\n    # E225: Missing whitespace around operators (breaks cython casting syntax like <int>)\n    # E226: Missing whitespace around arithmetic operators (breaks cython pointer syntax like int*)\n    # E227: Missing whitespace around bitwise or shift operator (Can also break casting syntax)\n    # E275: Missing whitespace after keyword (Doesn't work with Cython except?)\n    # E402: invalid syntax (works for Python, not Cython)\n    # E999: invalid syntax (works for Python, not Cython)\n    # W503: line break before binary operator (breaks lines that start with a pointer)\n    # W504: line break after binary operator (breaks lines that end with a pointer)\n    *.pyx: E211, E225, E226, E227, E275, E402, E999, W503, W504\n    *.pxd: E211, E225, E226, E227, E275, E402, E999, W503, W504\n    *.pxi: E211, E225, E226, E227, E275, E402, E999, W503, W504\n\n[isort]\nline_length=88\nmulti_line_output=3\ninclude_trailing_comma=True\nforce_grid_wrap=0\ncombine_as_imports=True\norder_by_type=True\nknown_rapids=\n    nvtext\n    cudf\n    cuml\n    cugraph\n    dask_cudf\nknown_first_party=\n    cufile\n    kvikio\n    legate_kvikio\ndefault_section=THIRDPARTY\nsections=FUTURE,STDLIB,THIRDPARTY,RAPIDS,FIRSTPARTY,LOCALFOLDER\nskip=\n    thirdparty\n    .eggs\n    .git\n    .hg\n    .mypy_cache\n    .tox\n    .venv\n    _build\n    buck-out\n    build\n    dist\n    __init__.py\n\n[options]\npackages = find:\npython_requires = >=3.9\n\n[options.extras_require]\nnvcomp =\n    numpy >=1.20\n    cupy >=9.5.0\n\n[mypy]\nignore_missing_imports = True\n"
  },
  "kassonlab/gmxapi": {
    "python_packaging/src/setup.py": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2019,2020, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\n# Python setuptools script to build and install the gmxapi Python interface\n# from a GROMACS installation directory.\n\n# Usage note: things go smoothly when we stick to the setup.py convention of\n# having a package source directory with the same name as the package at the\n# same level as the setup.py script and only expect `pip install .` in the\n# setup.py directory. If we play with the layout more, it is hard to keep all\n# of the `pip` and `setup.py` cases working as expected. This is annoying\n# because running the Python interpreter immediately from the same directory\n# can find the uninstalled source instead of the installed package. We can\n# ease this pain by building an sdist in the enclosing CMake build scope\n# and encouraging users to `pip install the_sdist.archive`. Otherwise, we\n# just have to document that we only support full build-install of the Python\n# package from the directory containing setup.py, which may clutter that\n# directory with some artifacts.\n\nimport os\n\n# Allow setup.py to be run when scikit-build is not installed, such as to\n# produce source distribution archives with `python setup.py sdist`\ntry:\n    from skbuild import setup\nexcept ImportError:\n    from distutils.core import setup\n\nusage = \"\"\"\nThe `gmxapi` package requires an existing GROMACS installation, version 2020 or higher.\nTo specify the GROMACS installation to use, provide a GMXTOOLCHAINDIR\nenvironment variable when running setup.py or `pip`.\n\nExample:\n    GMXTOOLCHAINDIR=/path/to/gromacs/share/cmake/gromacs pip install gmxapi\n\nIf you have multiple builds of GROMACS, distinguished by a suffix `$SUFFIX`, the\ntool chain directory will use that suffix.\n\nExample:\n    GMXTOOLCHAINDIR=/path/to/gromacs/share/cmake/gromacs$SUFFIX pip install gmxapi\n\nIn the example, `gmxapi` is downloaded automatically from pypi.org. You can\nreplace `gmxapi` with a local directory or archive file to build from a source\ndistribution.\n\nsetup.py will use the location of GMXTOOLCHAINDIR to locate the\ngmxapi library configured during GROMACS installation. Alternatively, if\ngmxapi_DIR is provided, or if GMXRC has been \"sourced\", the toolchain file\nlocation may be deduced. Note, though, that if multiple GROMACS installations\nexist in the same location (with different suffixes) only the first one will be\nused when guessing a toolchain, because setup.py does not know which corresponds\nto the gmxapi support library.\n\nIf specifying GMXTOOLCHAINDIR and gmxapi_DIR, the tool chain directory must be \nlocated within a subdirectory of gmxapi_DIR.\n\nRefer to project web site for complete documentation.\n\n\"\"\"\n\n\nclass GmxapiInstallError(Exception):\n    \"\"\"Error processing setup.py for gmxapi Python package.\"\"\"\n\n\ngmx_toolchain_dir = os.getenv('GMXTOOLCHAINDIR')\ngmxapi_DIR = os.getenv('gmxapi_DIR')\nif gmxapi_DIR is None:\n    # Infer from GMXRC exports, if available.\n    gmxapi_DIR = os.getenv('GROMACS_DIR')\n\ndef _find_first_gromacs_suffix(directory):\n    dir_contents = os.listdir(directory)\n    for entry in dir_contents:\n        if entry.startswith('gromacs'):\n            return entry.strip('gromacs')\n\nif gmx_toolchain_dir is None:\n    # Try to guess from standard GMXRC environment variables.\n    if gmxapi_DIR is not None:\n        if os.path.exists(gmxapi_DIR) and os.path.isdir(gmxapi_DIR):\n            share_cmake = os.path.join(gmxapi_DIR, 'share', 'cmake')\n            suffix = _find_first_gromacs_suffix(share_cmake)\n            if suffix is not None:\n                gmx_toolchain_dir = os.path.join(share_cmake, 'gromacs' + suffix)\n\nif gmx_toolchain_dir is None:\n    print(usage)\n    raise GmxapiInstallError('Could not configure for GROMACS installation. Provide GMXTOOLCHAINDIR.')\n\nsuffix = os.path.basename(gmx_toolchain_dir).strip('gromacs')\ngmx_toolchain = os.path.abspath(os.path.join(gmx_toolchain_dir, 'gromacs-toolchain' + suffix + '.cmake'))\n\nif gmxapi_DIR is None:\n    # Example: given /usr/local/gromacs/share/cmake/gromacs/gromacs-toolchain.cmake,\n    # we would want /usr/local/gromacs.\n    # Note that we could point more directly to the gmxapi-config.cmake but,\n    # so far, we have relied on CMake automatically looking into\n    # <package>_DIR/share/cmake/<package>/ for such a file.\n    # We would need a slightly different behavior for packages that link against\n    # libgromacs directly, as sample_restraint currently does.\n    gmxapi_DIR = os.path.join(os.path.dirname(gmx_toolchain), '..', '..', '..')\n\ngmxapi_DIR = os.path.abspath(gmxapi_DIR)\n\nif not os.path.exists(gmxapi_DIR) or not os.path.isdir(gmxapi_DIR):\n    print(usage)\n    raise GmxapiInstallError('Please set a valid gmxapi_DIR.')\n\nif gmxapi_DIR != os.path.commonpath([gmxapi_DIR, gmx_toolchain]):\n    raise GmxapiInstallError('GROMACS toolchain file {} is not in gmxapi_DIR {}'.format(\n        gmx_toolchain,\n        gmxapi_DIR\n    ))\n\ncmake_platform_hints = '-DCMAKE_TOOLCHAIN_FILE={}'.format(gmx_toolchain)\ncmake_gmxapi_hint = '-Dgmxapi_ROOT={}'.format(gmxapi_DIR)\ncmake_args = [cmake_platform_hints, cmake_gmxapi_hint]\n\n# Requirements for using the installed package.\n# (Setup requirements are in pyproject.toml)\ninstall_requires = [\n    'networkx>=2.0',\n    'numpy>=1']\n# TODO: `importlib_resources` is not required when our minimum Python is 3.7+\ntry:\n    import importlib.resources\nexcept ImportError:\n    install_requires.append('importlib_resources')\n\nsetup(\n    name='gmxapi',\n\n    # TODO: single-source version information (currently repeated in gmxapi/version.py)\n    version='0.2.0a3',\n    python_requires='>=3.6',\n    install_requires=install_requires,\n\n    packages=['gmxapi', 'gmxapi.simulation'],\n    package_data={'gmxapi': ['gmxconfig.json']},\n\n    cmake_args=cmake_args,\n\n    author='M. Eric Irrgang',\n    author_email='info@gmxapi.org',\n    description='gmxapi Python interface for GROMACS',\n    license='LGPL',\n    url='http://gmxapi.org/',\n\n    # The installed package will contain compiled C++ extensions that cannot be loaded\n    # directly from a zip file.\n    zip_safe=False\n)\n",
    "python_packaging/src/pyproject.toml": "[build-system]\nrequires = ['cmake>=3.13',\n            'scikit-build>=0.10',\n            'setuptools>=42',\n            'wheel']\nbuild-backend = 'setuptools.build_meta:__legacy__'\n"
  },
  "chopralab/lemon": {
    "setup.py": "from skbuild import setup\n\nLONG_DESCRIPTION = \"\"\"Lemon is a framework and API for mining information from\nthe PDB and other sources. This module provides the Python bindings to the Lemon\nframework to allow users to create Lemon workflows completely in Python without\nbuilding any C++ executable. See the documentation at\nhttp://chopralab.github.io/lemon\"\"\"\n\nsetup(\n    name= \"candiy_lemon\",\n    version=\"0.3.0\",\n    long_description=LONG_DESCRIPTION,\n    description=\"Mine data from the PDB in minutes\",\n    keywords=\"chemistry computational cheminformatics proteins structural biology\",\n    author=\"Jonathan Fine\",\n    author_email=\"choprait@purdue.edu\",\n    license=\"BSD\",\n    url=\"http://github.com/chopralab/lemon\",\n    setup_requires=[\"scikit-build\"],\n    cmake_args=[\n        '-DLEMON_BUILD_PYTHON:BOOL=OFF',\n        '-DBUILD_SHARED_LIBS:BOOL=OFF',\n        '-DLEMON_BUILD_PROGS:BOOL=OFF',\n    ],\n    packages=['candiy_lemon'],\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Environment :: Console\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: Unix\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Topic :: Scientific/Engineering :: Chemistry\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n    ],\n)\n"
  },
  "pywinrt/python-winsdk": {
    "setup.py": "from setuptools import find_namespace_packages\n\nfrom skbuild import setup\n\nwith open(\"README.md\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"winsdk\",\n    version = \"1.0.0b9\",\n    description=\"Python bindings for the Windows SDK\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT\",\n    author='Microsoft Corporation',\n    url=\"https://github.com/pywinrt/python-winsdk\",\n    classifiers=[\n            'Development Status :: 4 - Beta',\n            'Environment :: Win32 (MS Windows)',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: Microsoft :: Windows :: Windows 10',\n            'Programming Language :: Python :: 3.7',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: Implementation :: CPython',\n            'Topic :: System :: Operating System',\n        ],\n    python_requires=\">=3.7\",\n    packages=find_namespace_packages(where=(\"pywinrt\")),\n    package_dir={\"\": \"pywinrt\"}, \n    # recursive glob (**) doesn't seem to work here\n    package_data={\"winsdk\": [\"py.typed\", \"*.pyi\", \"*/*.pyi\", \"*/*/*.pyi\", \"*/*/*/*.pyi\", \"*/*/*/*/*.pyi\"]},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build>=0.17.0\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nskip = \"pp*\"\narchs = \"all\"\nbuild-verbosity = 1\n"
  },
  "Socrats/EGTTools": {
    "setup.py": "# Copyright (c) 2019-2021  Elias Fernandez\n#\n# This file is part of EGTtools.\n#\n# EGTtools is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# EGTtools is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with EGTtools.  If not, see <http://www.gnu.org/licenses/>\n\n\"\"\"\nThe code used in here has been adapted from https://github.com/YannickJadoul/Parselmouth/blob/master/setup.py\n\"\"\"\n\nimport io\nimport os\nimport re\nimport shlex\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"Please update pip to pip 10 or greater, or a manually install the PEP 518 requirements in pyproject.toml\",\n          file=sys.stderr)\n    raise\n\nfrom setuptools import find_packages\n\n\ndef find_version():\n    with io.open(os.path.join(os.path.dirname(__file__), \"cpp/src\", \"version.h\"), encoding='utf8') as f:\n        version_file = f.read()\n    version_match = re.search(r\"^#define EGTTOOLS_VERSION ([\\da-z.]+)$\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\n\nsetup(\n    version=find_version(),\n    # packages=find_packages(exclude=['contrib', 'docs', 'tests']),\n    packages=['egttools', 'egttools.numerical', 'egttools.numerical.structure', 'egttools.analytical',\n              'egttools.plotting', 'egttools.games',\n              'egttools.behaviors',\n              'egttools.behaviors.CRD', 'egttools.behaviors.NormalForm', 'egttools.behaviors.NormalForm.TwoActions',\n              'egttools.behaviors.CPR',\n              'egttools.helpers',\n              'egttools.distributions',\n              'egttools.datastructures'\n              ],\n    package_dir={'egttools': \"src/egttools\",\n                 'egttools.numerical': \"src/egttools/numerical\",\n                 'egttools.numerical.structure': 'src/egttools/numerical/structure',\n                 'egttools.analytical': \"src/egttools/analytical\",\n                 'egttools.plotting': \"src/egttools/plotting\", 'egttools.games': \"src/egttools/games\",\n                 'egttools.behaviors': \"src/egttools/behaviors\", 'egttools.behaviors.CRD': \"src/egttools/behaviors/CRD\",\n                 'egttools.behaviors.NormalForm': \"src/egttools/behaviors/NormalForm\",\n                 'egttools.behaviors.NormalForm.TwoActions': \"src/egttools/behaviors/NormalForm/TwoActions\",\n                 'egttools.behaviors.CPR': \"src/egttools/behaviors/CPR\",\n                 'egttools.helpers': \"src/egttools/helpers\",\n                 'egttools.distributions': \"src/egttools/distributions\",\n                 'egttools.datastructures': \"src/egttools/datastructures\"\n                 },\n    cmake_args=shlex.split(os.environ.get('EGTTOOLS_EXTRA_CMAKE_ARGS', '')),\n    cmake_install_dir=\"src/egttools/numerical\",\n    cmake_with_sdist=True,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=44\",\n    \"wheel\",\n    \"scikit-build>=0.13.1\",\n    \"cmake>=3.18\",\n    \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"",
    "setup.cfg": "[metadata]\nname = egttools\nversion = <see setup.py>\ndescription = Efficient Python library for EGT\nlong_description = file: README.md\nlong_description_content_type = text/markdown\ndescription_file = README.md\nurl = https://github.com/Socrats/EGTTools\nauthor = Elias F. Domingos\nauthor_email = elias.fernandez.domingos@vub.be\nproject_urls =\n    Bug Tracker = https://github.com/Socrats/EGTTools/issues\n    Documentation = https://egttools.readthedocs.io/en/latest/\n    Source Code = https://github.com/Socrats/EGTTools\nkeywords = evolutionary game theory, social dynamics, evolutionary dynamics\nlicense = GPLv3\nlicense_files = LICENSE\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Developers\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\n    Operating System :: MacOS :: MacOS X\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Operating System :: Unix\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Topic :: Scientific/Engineering\n    Topic :: Software Development :: Libraries :: Python Modules\n\n[options]\npython_requires = >=3.7\ninstall_requires =\n    numpy>=1.7.0\n    scipy>=1.5.0\n    matplotlib>=3.3.0\n    networkx\n    seaborn>=0.11.2\nzip_safe = False\n\n[aliases]\ntest = pytest\n\n[tool:pytest]\n# disable-pytest-warnings should be removed once we rewrite tests\n# using yield with parametrize\ndoctest_optionflags = NORMALIZE_WHITESPACE ELLIPSIS\naddopts =\n    --ignore build_tools\n    --ignore docs\n    --ignore pybind11\n    --disable-pytest-warnings\n    -rxXs\n\n[check-manifest]\nignore = .appveyor.yml\n         .readthedocs.yml\n         .travis.yml\n         binder\n         binder/*"
  },
  "Blosc/python-blosc2": {
    "setup.py": "#######################################################################\n# Copyright (c) 2019-present, Blosc Development Team <blosc@blosc.org>\n# All rights reserved.\n#\n# This source code is licensed under a BSD-style license (found in the\n# LICENSE.txt file in the root directory of this source tree)\n#######################################################################\n\nfrom skbuild import setup\n\n\ndef cmake_bool(cond):\n    return \"ON\" if cond else \"OFF\"\n\n\n# Blosc version\nVERSION = open(\"VERSION\").read().strip()\n# Create the version.py file\nopen(\"blosc2/version.py\", \"w\").write('__version__ = \"%s\"\\n' % VERSION)\n\ndef exclude_pkgconfig(cmake_manifest):\n    \"\"\"remove pkgconfig file from installation: gh-110.\"\"\"\n    return list(filter(lambda name: not (name.endswith('.pc')), cmake_manifest))\n\n# These keywords need to be in setup()\n# https://scikit-build.readthedocs.io/en/latest/usage.html#setuptools-options\nsetup(\n    version=VERSION,\n    packages=[\"blosc2\"],\n    package_dir={\"blosc2\": \"blosc2\"},\n    include_package_data=True,\n    cmake_process_manifest_hook=exclude_pkgconfig,\n    install_requires=open(\"requirements-runtime.txt\").read().split(),\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"scikit-build\", \"cython\", \"cmake\", \"ninja\", \"oldest-supported-numpy\"]\n\n[project]\nname = \"blosc2\"\ndescription = \"Python wrapper for the C-Blosc2 library\"\nreadme = \"README.rst\"\nauthors = [{name = \"Blosc Development Team\", email = \"blosc@blosc.org\"}]\nmaintainers = [{ name = \"Blosc Development Team\", email = \"blosc@blosc.org\"}]\nlicense = {text = \"BSD-3-Clause\"}\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Developers\",\n    \"Intended Audience :: Information Technology\",\n    \"Intended Audience :: Science/Research\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Programming Language :: Python\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n    \"Operating System :: Microsoft :: Windows\",\n    \"Operating System :: Unix\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n]\nrequires-python = \">=3.8, <4\"\ndynamic = [\"version\", \"dependencies\"]\n\n[project.urls]\nhomepage = \"https://github.com/Blosc/python-blosc2\"\ndocumentation = \"https://www.blosc.org/python-blosc2/python-blosc2.html\"\n\n[tool.cibuildwheel]\nskip = \"cp36-* cp37-* pp37-* *-manylinux_i686 *_ppc64le *_s390x *-musllinux*\"\n\n[tool.black]\nline-length = 109\n\n[tool.ruff]\nline-length = 109\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\n"
  },
  "rgl-epfl/fastsweep": {
    "setup.py": "import sys, os\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nfastsweep_cmake_toolchain_file = os.environ.get(\"FASTSWEEP_CMAKE_TOOLCHAIN_FILE\", \"\")\nfastsweep_drjit_cmake_dir = os.environ.get(\"FASTSWEEP_DRJIT_CMAKE_DIR\", \"\")\n\nVERSION = \"0.1.2\"\n\nsetup(\n    name=\"fastsweep\",\n    version=VERSION,\n    description=\"Eikonal solver using parallel fast sweeping\",\n    author=\"Delio Vicini\",\n    author_email=\"delio.vicini@gmail.com\",\n    license=\"BSD\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    packages=find_packages(where=\"src\"),\n    install_requires=[\"drjit\"],\n    package_dir={\"\": \"src\"},\n    cmake_args=[\n        f'-DCMAKE_TOOLCHAIN_FILE={fastsweep_cmake_toolchain_file}',\n        f'-DDRJIT_CMAKE_DIR:STRING={fastsweep_drjit_cmake_dir}',\n        f'-DPROJECT_VERSION_INFO={VERSION}'\n    ],\n    url=\"https://github.com/rgl-epfl/fastsweep\",\n    cmake_install_dir=\"src/fastsweep\",\n    include_package_data=True,\n    python_requires=\">=3.8\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"pybind11\", \"drjit>=0.4.2\"]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\"\n\n[tool.pytest.ini_options]\nnorecursedirs = [ \"ext\" ]\n\n[tool.cibuildwheel]\ntest-command = \"python -c \\\"import fastsweep\\\"\"\ntest-requires =  \"pytest numpy drjit\"\nskip = \"*-musllinux* pp* cp36-* cp37-* cp311-* *-win32 *_i686 cp38-macosx_arm64\"\n\n[tool.cibuildwheel.linux]\nrepair-wheel-command = \"python3 .github/workflows/tag_wheel_manylinux.py {wheel} {dest_dir}\"\narchs = \"auto64\"\n\n[tool.cibuildwheel.windows]\narchs = \"auto64\"\n\n"
  },
  "freebsd/freebsd-ports-kde": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "robertjoosten/maya-dem-bones": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    packages=[\"dem_bones\"],\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/dem_bones\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n",
    "setup.cfg": "[metadata]\nname = dem_bones\nversion = 1.0.0\nurl = https://github.com/robertjoosten/maya-dem-bones\nauthor = Robert Joosten\nauthor_email = rwm.joosten@gmail.com\ndescription = DemBones python bindings for use in Maya.\nlong_description = file: README.md\nlicense = MIT\n"
  },
  "BlueBrain/nmodl": {
    "setup.py": "# ***********************************************************************\n# Copyright (C) 2018-2022 Blue Brain Project\n#\n# This file is part of NMODL distributed under the terms of the GNU\n# Lesser General Public License. See top-level LICENSE file for details.\n# ***********************************************************************\n\nimport inspect\nimport os\nimport subprocess\nimport sys\n\nfrom setuptools import Command\nfrom skbuild import setup\n\n\"\"\"\nA generic wrapper to access nmodl binaries from a python installation\nPlease create a softlink with the binary name to be called.\n\"\"\"\nimport stat\nfrom pkg_resources import working_set\nfrom find_libpython import find_libpython\n\n\n# Main source of the version. Dont rename, used by Cmake\ntry:\n    v = (\n        subprocess.run([\"git\", \"describe\", \"--tags\"], stdout=subprocess.PIPE)\n        .stdout.strip()\n        .decode()\n    )\n    __version__ = v[: v.rfind(\"-\")].replace(\"-\", \".\") if \"-\" in v else v\n    # allow to override version during development/testing\n    if \"NMODL_WHEEL_VERSION\" in os.environ:\n        __version__ = os.environ['NMODL_WHEEL_VERSION']\nexcept Exception as e:\n    raise RuntimeError(\"Could not get version from Git repo\") from e\n\n\nclass lazy_dict(dict):\n    \"\"\"When the value associated to a key is a function, then returns\n    the function call instead of the function.\n    \"\"\"\n\n    def __getitem__(self, item):\n        value = dict.__getitem__(self, item)\n        if inspect.isfunction(value):\n            return value()\n        return value\n\n\ndef get_sphinx_command():\n    \"\"\"Lazy load of Sphinx distutils command class\n    \"\"\"\n    # If nbconvert is installed to .eggs on the fly when running setup.py then\n    # templates from it will not be found. This is a workaround.\n    if 'JUPYTER_PATH' not in os.environ:\n        import nbconvert\n        os.environ['JUPYTER_PATH'] = os.path.realpath(os.path.join(os.path.dirname(nbconvert.__file__), '..', 'share', 'jupyter'))\n        print(\"Setting JUPYTER_PATH={}\".format(os.environ['JUPYTER_PATH']))\n\n    from sphinx.setup_command import BuildDoc\n\n    return BuildDoc\n\n\nclass Docs(Command):\n    description = \"Generate & optionally upload documentation to docs server\"\n    user_options = []\n    finalize_options = lambda self: None\n    initialize_options = lambda self: None\n\n    def run(self, *args, **kwargs):\n        self.run_command(\"doctest\")\n        self.run_command(\"buildhtml\")\n\n\ninstall_requirements = [\n    \"PyYAML>=3.13\",\n    \"sympy>=1.3\",\n    \"find_libpython\"\n]\n\n\ncmake_args = [\"-DPYTHON_EXECUTABLE=\" + sys.executable]\nif \"bdist_wheel\" in sys.argv:\n    cmake_args.append(\"-DLINK_AGAINST_PYTHON=FALSE\")\n\n# For CI, we want to build separate wheel\npackage_name = \"NMODL\"\nif \"NMODL_NIGHTLY_TAG\" in os.environ:\n    package_name += os.environ[\"NMODL_NIGHTLY_TAG\"]\n\n# Parse long description from README.md\nwith open('README.md', 'r', encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup(\n    name=package_name,\n    version=__version__,\n    author=\"Blue Brain Project\",\n    author_email=\"bbp-ou-hpc@groupes.epfl.ch\",\n    description=\"NEURON Modeling Language Source-to-Source Compiler Framework\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    packages=[\"nmodl\"],\n    scripts=[\"pywheel/shim/nmodl\"],\n    include_package_data=True,\n    cmake_minimum_required_version=\"3.15.0\",\n    cmake_args=cmake_args,\n    cmdclass=lazy_dict(\n        docs=Docs, doctest=get_sphinx_command, buildhtml=get_sphinx_command,\n    ),\n    zip_safe=False,\n    setup_requires=[\n        \"jinja2>=2.9.3\",\n        \"jupyter-client\",\n        \"jupyter\",\n        \"myst_parser\",\n        \"mistune<3\",  # prevents a version conflict with nbconvert\n        \"nbconvert\",\n        \"nbsphinx>=0.3.2\",\n        \"pytest>=3.7.2\",\n        \"sphinxcontrib-applehelp<1.0.3\",\n        \"sphinxcontrib-htmlhelp<=2.0.0\",\n        \"sphinx<6\",\n        \"sphinx-rtd-theme\",\n    ]\n    + install_requirements,\n    install_requires=install_requirements,\n)\n",
    "setup.cfg": "[tool:pytest]\ntestpaths = test/unit/pybind\n\n[doctest]\nbuilder = doctest\n\n[flake8]\nmax-line-length = 100\n"
  },
  "KitwareMedical/ITKUltrasound": {
    "setup.py": "from __future__ import print_function\nfrom os import sys\n\nfrom skbuild import setup\n\nsetup(\n    name='itk-ultrasound',\n    version='0.6.1',\n    author='Matthew McCormick',\n    author_email='matt.mccormick@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/KitwareMedical/ITKUltrasound',\n    description=(r'Filters for use with the Insight Toolkit (ITK)'\n        ' that may be particularly useful for the reconstruction and'\n        ' analysis of ultrasound images.'),\n    long_description=(r'This package contains filters for use with the Insight Toolkit'\n        ' (ITK) for the reconstruction and analysis of ultrasound images. This includes'\n        ' B-mode image generation, scan conversion, strain imaging, and '\n        ' ultrasound spectroscopy.'),\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit ultrasound imaging',\n    url=r'https://www.insight-journal.org/browse/publication/722',\n    install_requires=[\n        r'itk>=5.3.0',\n        r'itk-meshtopolydata>=0.10.0',\n        r'itk-bsplinegradient>=0.2.10',\n        r'itk-higherorderaccurategradient>=1.2.0',\n        r'itk-splitcomponents>=2.1.0',\n        r'itk-strain>=0.4.0',\n    ]\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\"]\n"
  },
  "INET-Complexity/ESL": {
    "setup.py": "import os\nimport pathlib\nimport sys\nimport subprocess\nimport typing\n\n# The relative path of the source code to the setup file\nsource_directory = 'esl'\n\ntry:\n    # Attempt to load skbuild, which is necessary to build this python package\n    from skbuild import setup\nexcept ImportError:\n    error_message = 'Please update pip, you need pip 10 or greater, or install the skbuild package, or install the ' \\\n                    'PEP 518 requirements in pyproject.toml '\n    print(error_message, file=sys.stderr)\n    raise ImportError(error_message)\n\n\ndef read_version():\n    \"\"\"\n    Reads the library version number from the unified version files, esl/version\n    :return:    Version tuple, in (major, minor, patch) format.\n    \"\"\"\n    try:\n        with open(f\"{source_directory}/version\", \"r\") as source_version:\n            lines = source_version.readlines()\n            version = []\n            for line in lines:\n                if \"ESL_VERSION_\" in line:\n                    number = int(line.split(\";\")[0].split('=')[1].strip())\n                    version.append(number)\n\n            return tuple(version)\n    except:\n        raise ValueError(f\"Can not read {source_directory}/version file.\")\n\n\ndef read_commit() -> typing.Optional[str]:\n    \"\"\"\n        Gets a commit identifier, so that it can be added to the library version\n    :return:\n    \"\"\"\n    try:\n        return subprocess.check_output([\"git\", \"rev-parse\", \"--short\", \"HEAD\"]).strip().decode()\n    except subprocess.CalledProcessError:\n        # likely git not installed, or not authorized to use\n        return None\n\n\ndef get_packages():\n    \"\"\"\n    Walks the source directory to find python modules. A module has an __init__.py file in the directory.\n    :return:    A dictionary mapping package names to subdirectories, e.g. {'esl.simulation': 'esl/simulation'}\n    \"\"\"\n    packages = dict()\n    for subdirectory, dirs, files in os.walk(source_directory):\n        for file in files:\n            entry = subdirectory + os.sep + file\n            if entry.endswith(\"__init__.py\"):\n                packages[subdirectory.replace('/', '.')] = subdirectory\n    return packages\n\n\npackages = get_packages()\n\n# disabled for now\ncommit = None # read_commit()\n\n# Set up the package, together with metadata that will be visible on package repositories such as Pypi\nsetup(\n    name                = 'eslpy',\n\n    version             = '.'.join(map(str, read_version())) + ('' if commit is None else '-' + commit),\n    description         = 'Python package for the Economic Simulation Library (https://github.com/INET-Complexity/ESL/)',\n\n    # This loads the README file in a way that allows repositories such as Pypi to render the readme using markdown\n    long_description    = (pathlib.Path(__file__).parent / \"README.md\").read_text(),\n    long_description_content_type=\"text/markdown\",\n\n    author              = 'Maarten P. Scholl et al.',\n    author_email        = 'maarten.scholl@cs.ox.ac.uk',\n\n    url                 = \"https://www.inet.ox.ac.uk/\",\n\n    classifiers         = [ 'Development Status :: 3 - Alpha',\n                            'License :: OSI Approved :: Apache Software License',\n                            'Programming Language :: Python',\n                            'Programming Language :: C++',\n                            'Topic :: Scientific/Engineering',\n                            'Intended Audience :: Science/Research',\n                          ],\n\n    license             = 'Apache License 2.0',\n\n    packages            = list(packages.keys()),\n    package_dir         = packages,\n\n    package_data        = { ''   : []\n                          , source_directory: ['version']\n                          },\n\n    cmake_install_dir   = 'esl'\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "duckstax/ottergon": {
    "integration/python/ottergon/setup.py": "from skbuild import setup\n\n\nsetup(\n    name=\"ottergon\",\n    version=\"0.4.0\",\n    description=\" \",\n    author=\" \",\n    license=\" \",\n    packages=['ottergon'],\n    # package_dir={'': 'integration/python'},\n    # package_data={\"\": [\"libiwasm.so\"]},\n    # cmake_install_dir='integration/python',\n    python_requires='>=3.6',\n    # cmake_source_dir=\".\",\n    include_package_data=True,\n    extras_require={\"test\": [\"pytest\"]}\n)\n",
    "integration/python/ottergon/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13\",\n    \"pybind11>=2.10.0\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\naddopts = [\n    \"--import-mode=importlib\",\n]\n"
  },
  "FEniCS/basix": {
    "setup.py": "from skbuild import setup\n\nfrom pathlib import Path\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\nsetup(name=\"fenics-basix\",\n      python_requires='>=3.7.0',\n      version=\"0.7.0.dev0\",\n      description='Basix Python interface',\n      long_description=long_description,\n      long_description_content_type=\"text/markdown\",\n      url=\"https://github.com/FEniCS/basix\",\n      author='FEniCS Project',\n      author_email=\"fenics-dev@googlegroups.com\",\n      maintainer_email=\"fenics-dev@googlegroups.com\",\n      license=\"MIT\",\n      packages=[\"basix\"],\n      package_data={\"basix\": [\"py.typed\"]},\n      install_requires=[\"numpy>=1.21\"],\n      extras_require={\n          \"docs\": [\"markdown\", \"pylit3\", \"pyyaml\", \"sphinx==5.0.2\", \"sphinx_rtd_theme\"],\n          \"lint\": [\"flake8\", \"pydocstyle\"],\n          \"optional\": [\"numba\", \"fenics-ufl@git+https://github.com/fenics/ufl\"],\n          \"test\": [\"pytest\", \"sympy\", \"scipy\", \"matplotlib\", \"fenics-basix[optional]\"],\n          \"ci\": [\"mypy\", \"pytest-xdist\", \"fenics-basix[docs]\", \"fenics-basix[lint]\", \"fenics-basix[optional]\",\n                 \"fenics-basix[test]\"]\n      },\n      package_dir={\"\": \"python\"},\n      cmake_install_dir=\"python/basix/\")\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"pybind11>=2.9.1\", \"cmake>=3.16\", \"scikit-build>=0.12\"]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild = [\"cp{37,38,39}-manylinux_x86_64\", \"cp{37,38,39}-manylinux_aarch64\", \"cp{37,38,39}-macosx_x86_64\", \"cp{38,39}-macosx_arm64\"]\n\ntest-command = [\n    \"cmake -G Ninja -DPython3_EXECUTABLE=$(which python) -B build-dir -S {project}/test/test_cmake\",\n    \"cmake --build build-dir/\",\n    \"build-dir/a.out\",\n    \"python -m pytest -v -n auto --durations 20 {project}/test/\"\n]\ntest-requires = [\"pytest-xdist\"]\ntest-extras = [\"test\"]\ntest-skip = \"*-macosx_arm64 *-*linux_aarch64\"\n\nmanylinux-x86_64-image = \"manylinux2014\"\n\n[tool.cibuildwheel.linux]\narchs = [\"x86_64\", \"aarch64\"] # Forces arm64 build on x86_64 runner using emulation.\nbefore-build = \"yum -y update && yum install -y epel-release && yum install -y openblas-devel ninja-build\"\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"arm64\"] # Forces arm64 build on x86_64 runner using cross-compilation.\nbefore-build = \"export HOMEBREW_AUTO_UPDATING=0 && brew update && brew install ninja\"\n",
    "setup.cfg": "[flake8]\nmax-line-length = 120\nignore = W503, E226, E241\nper-file-ignores =\n    */__init__.py: F401\n\n[pydocstyle]\nconvention = google\n\n[mypy]\nignore_missing_imports = True\n"
  },
  "PearCoding/Ignis": {
    "src/frontend/python/setup.py.in": "# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sys, re, os, pathlib, shutil\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nroot_directory = \"${Ignis_SOURCE_DIR}\"\n\nwith open(os.path.join(root_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nlong_description = long_description[long_description.find('## Frontends'):]\nshutil.copytree(os.path.join(root_directory, 'src', 'frontend', 'python', 'ignis'), 'ignis', dirs_exist_ok=True)\n\nsetup(\n    name=\"ignis\",\n    version=\"${Ignis_VERSION}\",\n    author=\"${Ignis_VENDOR}\",\n    description=\"${Ignis_DESCRIPTION}\",\n    url=\" ${Ignis_URL}\",\n    license=\"MIT\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    cmake_source_dir=root_directory,\n    cmake_args=[\n        '-DIG_WITH_CLI:BOOL=OFF',\n        '-DIG_WITH_VIEWER:BOOL=OFF',\n        '-DIG_WITH_TRACER:BOOL=OFF',\n        '-DIG_WITH_TOOLS:BOOL=OFF',\n        '-DIG_WITH_PYTHON_API:BOOL=ON',\n        '-DIG_WITH_DOCUMENTATION:BOOL=OFF',\n        '-DAnyDSL_runtime_DIR=${AnyDSL_runtime_DIR}'\n    ],\n    packages=['ignis'],\n    package_data={'ignis': ['*ig_lib_runtime*', '*pyignis*']},\n    python_requires=\">=3.8\"\n)\n",
    "src/frontend/python/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja; platform_system!='Windows'\", \"nanobind\"]\nbuild-backend = \"setuptools.build_meta\""
  },
  "ScQ-Cloud/pyquafu": {
    "setup.py": "import sys\r\n\r\ntry:\r\n    from skbuild import setup\r\nexcept ImportError:\r\n    print(\r\n        \"Please update pip, you need pip 10 or greater,\\n\"\r\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\r\n        file=sys.stderr,\r\n    )\r\n    raise\r\n\r\nfrom setuptools import find_packages\r\nfrom os import path\r\n\r\nhere = path.abspath(path.dirname(__file__))\r\nwith open(path.join(here, 'README.md'), encoding='utf-8') as f:\r\n    long_description = f.read()\r\n\r\nrequirements = [\r\n    \"matplotlib>=3.5.2\",\r\n    \"networkx>=2.6.3\",\r\n    \"numpy>=1.20.3\",\r\n    \"requests>=2.26.0\",\r\n    \"scipy>=1.8.1\",\r\n    \"sparse>=0.13.0\"\r\n]\r\n\r\nsetup(\r\n    name=\"pyquafu\",\r\n    version=\"0.2.11\",\r\n    author=\"ssli\",\r\n    author_email=\"ssli@iphy.ac.cn\",\r\n    url=\"https://github.com/ScQ-Cloud/pyquafu\",\r\n    description=\"Python toolkit for Quafu-Cloud\",\r\n    install_requires=requirements,\r\n    packages=find_packages(where=\"src\"),\r\n    package_dir={\"\": \"src\"},\r\n    cmake_install_dir=\"src/quafu/simulators/\",\r\n    include_package_data=True,\r\n    long_description=long_description,\r\n    long_description_content_type='text/markdown',\r\n    extras_require={\"test\": [\"pytest\"]},\r\n    python_requires=\">=3.8\",\r\n    zip_safe=False,\r\n    setup_cfg=True,\r\n    license=\"Apache-2.0 License\"\r\n)",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"pybind11~=2.9.2\",\n    \"cmake>=3.22\",\n    \"scikit-build>=0.15.0\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel.windows]\narchs = [\"AMD64\"]\n\n\n[tool.cibuildwheel.linux]\nrepair-wheel-command = \"auditwheel repair -w {dest_dir} {wheel} --plat manylinux2014_x86_64\"\narchs = [\"x86_64\"]\n\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"arm64\"]\n\nrepair-wheel-command = [\n  \"delocate-listdeps {wheel}\",\n  \"delocate-wheel --require-archs {delocate_archs} -w {dest_dir} {wheel}\",\n]\n"
  },
  "yushulx/python-barcode-qrcode-sdk": {
    "setup.py": "from skbuild import setup\nimport io\n\nlong_description = io.open(\"README.md\", encoding=\"utf-8\").read()\npackages = ['barcodeQrSDK']\n\nsetup (name = 'barcode-qr-code-sdk',\n            version = '9.5.0',\n            description = 'Barcode and QR code scanning SDK for Python',\n            long_description=long_description,\n            long_description_content_type=\"text/markdown\",\n            author='yushulx',\n            url='https://github.com/yushulx/python-barcode-qrcode-sdk',\n            license='MIT',\n            packages=packages,\n            include_package_data=False,\n            classifiers=[\n                \"Development Status :: 5 - Production/Stable\",\n                \"Environment :: Console\",\n                \"Intended Audience :: Developers\",\n                \"Intended Audience :: Education\",\n                \"Intended Audience :: Information Technology\",\n                \"Intended Audience :: Science/Research\",\n                \"License :: OSI Approved :: MIT License\",\n                \"Operating System :: Microsoft :: Windows\",\n                \"Operating System :: MacOS\",\n                \"Operating System :: POSIX :: Linux\",\n                \"Programming Language :: Python\",\n                \"Programming Language :: Python :: 3\",\n                \"Programming Language :: Python :: 3 :: Only\",\n                \"Programming Language :: Python :: 3.6\",\n                \"Programming Language :: Python :: 3.7\",\n                \"Programming Language :: Python :: 3.8\",\n                \"Programming Language :: Python :: 3.9\",\n                \"Programming Language :: Python :: 3.10\",\n                \"Programming Language :: C++\",\n                \"Programming Language :: Python :: Implementation :: CPython\",\n                \"Topic :: Scientific/Engineering\",\n                \"Topic :: Software Development\",\n            ],\n            install_requires=['opencv-python'],\n            entry_points={\n                'console_scripts': ['scanbarcode=barcodeQrSDK.scripts:scanbarcode']\n            },\n          )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13\",\n    \"cmake>=3.18\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nmanylinux-x86_64-image = \"manylinux_2_24\"\nmanylinux-aarch64-image = \"manylinux_2_24\"\n\nskip = [\"pp*\", \"*-win32\", \"*-manylinux_i686\", \"*-musllinux_*\"]\n\n[tool.cibuildwheel.windows]\narchs = [\"AMD64\"]\n\n\n[tool.cibuildwheel.linux]\nrepair-wheel-command = \"auditwheel repair -w {dest_dir} {wheel} --plat manylinux_2_24_$(uname -m)\"\narchs = [\"x86_64\", \"aarch64\"]\n\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"universal2\"]\n\nrepair-wheel-command = [\n  \"delocate-listdeps {wheel}\",\n  \"delocate-wheel --require-archs {delocate_archs} -w {dest_dir} {wheel}\",\n]\n"
  },
  "Erotemic/netharn": {
    "setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# NOTE: pip install -U --pre h5py\nfrom __future__ import absolute_import, division, print_function\nimport sys\nfrom os.path import dirname\nfrom setuptools import find_packages\nfrom os.path import exists\nfrom os.path import join\nimport glob\nimport os\nfrom setuptools import setup\n# from skbuild import setup\n\n\ndef parse_version(fpath):\n    \"\"\"\n    Statically parse the version number from a python file\n    \"\"\"\n    import ast\n    if not exists(fpath):\n        raise ValueError('fpath={!r} does not exist'.format(fpath))\n    with open(fpath, 'r') as file_:\n        sourcecode = file_.read()\n    pt = ast.parse(sourcecode)\n    class VersionVisitor(ast.NodeVisitor):\n        def visit_Assign(self, node):\n            for target in node.targets:\n                if getattr(target, 'id', None) == '__version__':\n                    self.version = node.value.s\n    visitor = VersionVisitor()\n    visitor.visit(pt)\n    return visitor.version\n\n\ndef parse_description():\n    \"\"\"\n    Parse the description in the README file\n\n    CommandLine:\n        pandoc --from=markdown --to=rst --output=README.rst README.md\n        python -c \"import setup; print(setup.parse_description())\"\n    \"\"\"\n    from os.path import dirname, join, exists\n    readme_fpath = join(dirname(__file__), 'README.rst')\n    # This breaks on pip install, so check that it exists.\n    if exists(readme_fpath):\n        try:\n            with open(readme_fpath, 'r') as f:\n                text = f.read()\n            return text\n        except Exception as ex:\n            import warnings\n            warnings.warn('unable to parse existing readme: {!r}'.format(ex))\n    return ''\n\n\ndef parse_requirements(fname='requirements.txt', with_version=False):\n    \"\"\"\n    Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        with_version (bool, default=False): if true include version specs\n\n    Returns:\n        List[str]: list of requirements items\n\n    References:\n        https://pip.readthedocs.io/en/1.1/requirements.html\n\n    CommandLine:\n        python -c \"import setup; print(setup.parse_requirements())\"\n        python -c \"import setup; print(chr(10).join(setup.parse_requirements(with_version=True)))\"\n    \"\"\"\n    from os.path import exists\n    import re\n    require_fpath = fname\n\n    def parse_line(line, base='.'):\n        \"\"\"\n        Parse information from a line in a requirements text file\n        \"\"\"\n        if line.startswith(('-f ', '--find-links ', '--index-url ')):\n            import warnings\n            warnings.warn(\n                'requirements file specified alternative index urls, but '\n                'there is currently no way to support this in setuptools')\n        elif line.startswith('-r '):\n            # Allow specifying requirements in other files\n            new_fname = line.split(' ')[1]\n            new_fpath = join(base, new_fname)\n            for info in parse_require_file(new_fpath):\n                yield info\n        else:\n            info = {'line': line}\n            if line.startswith('-e '):\n                info['package'] = line.split('#egg=')[1]\n            else:\n                # Remove versioning from the package\n                pat = '(' + '|'.join(['>=', '==', '>']) + ')'\n                parts = re.split(pat, line, maxsplit=1)\n                parts = [p.strip() for p in parts]\n\n                info['package'] = parts[0]\n                if len(parts) > 1:\n                    op, rest = parts[1:]\n                    if ';' in rest:\n                        # Handle platform specific dependencies\n                        # http://setuptools.readthedocs.io/en/latest/setuptools.html#declaring-platform-specific-dependencies\n                        version, platform_deps = map(str.strip, rest.split(';'))\n                        info['platform_deps'] = platform_deps\n                    else:\n                        version = rest  # NOQA\n                    info['version'] = (op, version)\n            yield info\n\n    def parse_require_file(fpath):\n        base = dirname(fpath)\n        with open(fpath, 'r') as f:\n            for line in f.readlines():\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    for info in parse_line(line, base):\n                        yield info\n\n    def gen_packages_items():\n        if exists(require_fpath):\n            for info in parse_require_file(require_fpath):\n                parts = [info['package']]\n                if with_version and 'version' in info:\n                    parts.extend(info['version'])\n                if not sys.version.startswith('3.4'):\n                    # apparently package_deps are broken in 3.4\n                    platform_deps = info.get('platform_deps')\n                    if platform_deps is not None:\n                        parts.append(';' + platform_deps)\n                item = ''.join(parts)\n                yield item\n\n    packages = list(gen_packages_items())\n    return packages\n\n\ndef clean_repo(repodir, modname, rel_paths=[]):\n    \"\"\"\n    repodir = ub.expandpath('~/code/netharn/')\n    modname = 'netharn'\n    rel_paths = [\n        'netharn/util/nms/cpu_nms.c',\n        'netharn/util/nms/cpu_nms.c',\n        'netharn/util/nms/cpu_nms.cpp',\n        'netharn/util/nms/cython_boxes.c',\n        'netharn/util/nms/cython_boxes.html',\n    ]\n    \"\"\"\n    print('cleaning repo: {}/{}'.format(repodir, modname))\n    toremove = []\n    for root, dnames, fnames in os.walk(repodir):\n\n        if os.path.basename(root) == modname + '.egg-info':\n            toremove.append(root)\n            del dnames[:]\n\n        if os.path.basename(root) == '__pycache__':\n            toremove.append(root)\n            del dnames[:]\n\n        if os.path.basename(root) == '_ext':\n            # Remove torch extensions\n            toremove.append(root)\n            del dnames[:]\n\n        if os.path.basename(root) == 'build':\n            # Remove python c extensions\n            if len(dnames) == 1 and dnames[0].startswith('temp.'):\n                toremove.append(root)\n                del dnames[:]\n\n        # Remove simple pyx inplace extensions\n        for fname in fnames:\n            if fname.endswith('.pyc'):\n                toremove.append(join(root, fname))\n            if fname.endswith(('.so', '.c', '.o')):\n                if fname.split('.')[0] + '.pyx' in fnames:\n                    toremove.append(join(root, fname))\n\n    def enqueue(d):\n        if exists(d) and d not in toremove:\n            toremove.append(d)\n\n    import six\n    if six.PY2:\n        abs_paths = [join(repodir, p) for pat in rel_paths\n                     for p in glob.glob(pat)]\n    else:\n        abs_paths = [join(repodir, p) for pat in rel_paths\n                     for p in glob.glob(pat, recursive=True)]\n    for abs_path in abs_paths:\n        enqueue(abs_path)\n\n    import ubelt as ub\n    for dpath in toremove:\n        # print('Removing dpath = {!r}'.format(dpath))\n        ub.delete(dpath, verbose=1)\n\n\ndef clean():\n    \"\"\"\n    __file__ = ub.expandpath('~/code/netharn/setup.py')\n    \"\"\"\n    modname = 'netharn'\n    repodir = dirname(__file__)\n    rel_paths = [\n        'htmlcov',\n        '_skbuild',\n        '_build_wheel',\n        'netharn.egg-info',\n        'dist',\n        'build',\n        '**/*.pyc',\n        'profile*'\n        'pip-wheel-metadata',\n    ]\n    clean_repo(repodir, modname, rel_paths)\n\n\nVERSION = version = parse_version('netharn/__init__.py')  # needs to be a global var for git tags\nNAME = 'netharn'\n\nif __name__ == '__main__':\n    if 'clean' in sys.argv:\n        clean()\n        # sys.exit(0)\n\n    setup(\n        name=NAME,\n        version=VERSION,\n        author='Jon Crall',\n        author_email='jon.crall@kitware.com',\n        url='https://gitlab.kitware.com/computer-vision/netharn',\n        description='Train and deploy pytorch models',\n        long_description=parse_description(),\n        long_description_content_type='text/x-rst',\n        install_requires=parse_requirements('requirements/runtime.txt'),\n        extras_require={\n            'all': parse_requirements('requirements.txt'),\n            'optional': parse_requirements('requirements/optional.txt'),\n            'tests': parse_requirements('requirements/tests.txt'),\n        },\n        packages=find_packages(include='netharn.*'),\n        license='Apache 2',\n        classifiers=[\n            # List of classifiers available at:\n            # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n            'Development Status :: 4 - Beta',\n            'Intended Audience :: Developers',\n            'Intended Audience :: Science/Research',\n            'Topic :: Scientific/Engineering',\n            'Topic :: Scientific/Engineering :: Artificial Intelligence',\n            'Topic :: Software Development',\n            'Topic :: Software Development :: Libraries :: Python Modules',\n            'Topic :: Utilities',\n            # This should be interpreted as Apache License v2.0\n            'License :: OSI Approved :: Apache Software License',\n            # Supported Python versions\n            'Programming Language :: Python :: 3',\n        ],\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"cython\", \"ninja\", \"ubelt\", \"cffi\"]\n"
  },
  "aestream/aestream": {
    "setup.py": "import os\nfrom skbuild import setup\n\npwd = os.path.abspath(os.path.dirname(__file__))\nwith open(os.path.join(pwd, \"README.md\"), encoding=\"utf-8\") as fp:\n    readme_text = fp.read()\n\n# C++ config\ncmake_args = [\"-DUSE_PYTHON=1\"]\n\n# Activate CUDA, if found\ntry:\n    import torch\n    from torch.utils import cpp_extension\n\n    cuda_home = cpp_extension._find_cuda_home()\n    if cuda_home is not None:\n        flags = \" \".join(cpp_extension._get_cuda_arch_flags())\n        cmake_args += [\n            f\"-DUSE_CUDA=1\",\n            f\"-DCMAKE_CUDA_FLAGS={flags}\",\n            f\"-DCMAKE_CUDA_COMPILER={cuda_home}/bin/nvcc\",\n            f\"-DCUDA_INCLUDE_DIRS={cuda_home}/include\",\n        ]\nexcept:\n    pass\n\n# Setuptools entrypoint\nsetup(\n    name=\"aestream\",\n    version=\"0.5.1\",\n    author=\"Jens E. Pedersen, Christian Pehle\",\n    author_email=\"jens@jepedersen.dk, christian.pehle@gmail.com\",\n    url=\"https://github.com/aestream/aestream\",\n    description=\"Streaming library for Address-Event Representation (AER) data\",\n    license=\"MIT\",\n    long_description=readme_text,\n    long_description_content_type=\"text/markdown\",\n    python_requires=\">=3.7\",\n    packages=[\"aestream\"],\n    install_requires=[\"numpy\"],\n    extras_require={\"torch\": [\"torch\"]},\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: C++\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Topic :: System :: Hardware :: Universal Serial Bus (USB)\",\n    ],\n    cmake_args=cmake_args,\n    package_data={\"aestream\": [\"*.pyi\", \"*.typed\"]},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n        \"setuptools>=42\",\n        \"scikit-build\",\n        \"cmake>=3.23\",\n        \"wheel\",\n        \"nanobind>=1.2\",\n        \"ninja; platform_system!='Windows'\"]\nbuild-backend = \"setuptools.build_meta\""
  },
  "tizian/differential-mc-estimators": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sys, re, os, pathlib\n\ntry:\n    from skbuild import setup\n    import pybind11\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nthis_directory = os.path.abspath(os.path.dirname(__file__))\n\nwith open(os.path.join(\"include/mitsuba/mitsuba.h\")) as f:\n    mi_version_regex = re.compile(\n        r\"^\\s*#\\s*define\\s+MI_VERSION_([A-Z]+)\\s+(.*)$\", re.MULTILINE)\n    matches = dict(mi_version_regex.findall(f.read()))\n    mitsuba_version = \"{MAJOR}.{MINOR}.{PATCH}\".format(**matches)\n\nwith open(os.path.join(\"ext/drjit/include/drjit/fwd.h\")) as f:\n    drjit_version_regex = re.compile(\n        r\"^\\s*#\\s*define\\s+DRJIT_VERSION_([A-Z]+)\\s+(.*)$\", re.MULTILINE)\n    matches = dict(drjit_version_regex.findall(f.read()))\n    drjit_version = \"{MAJOR}.{MINOR}.{PATCH}\".format(**matches)\n\nwith open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nlong_description = long_description[long_description.find('## Introduction'):]\nmi_cmake_toolchain_file = os.environ.get(\"MI_CMAKE_TOOLCHAIN_FILE\", \"\")\nmi_drjit_cmake_dir = os.environ.get(\"MI_DRJIT_CMAKE_DIR\", \"\")\nmi_srgb_coeff_file = os.environ.get(\"MI_SRGB_COEFF_FILE\", \"\")\nmi_python_stubs_dir = os.environ.get(\"MI_PYTHON_STUBS_DIR\", \"\")\npathlib.Path(\"./mitsuba\").mkdir(exist_ok=True)\n\nsetup(\n    name=\"mitsuba\",\n    version=mitsuba_version,\n    author=\"Realistic Graphics Lab (RGL), EPFL\",\n    author_email=\"wenzel.jakob@epfl.ch\",\n    description=\"3: A Retargetable Forward and Inverse Renderer\",\n    url=\"https://github.com/mitsuba-renderer/mitsuba3\",\n    license=\"BSD\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    cmake_args=[\n        '-DCMAKE_INSTALL_LIBDIR=mitsuba',\n        '-DCMAKE_INSTALL_BINDIR=mitsuba',\n        '-DCMAKE_INSTALL_INCLUDEDIR=mitsuba/include',\n        '-DCMAKE_INSTALL_DATAROOTDIR=mitsuba/data',\n        f'-DCMAKE_TOOLCHAIN_FILE={mi_cmake_toolchain_file}',\n        f'-DMI_DRJIT_CMAKE_DIR:STRING={mi_drjit_cmake_dir}',\n        f'-DMI_SRGB_COEFF_FILE:STRING={mi_srgb_coeff_file}',\n        f'-DMI_PYTHON_STUBS_DIR:STRING={mi_python_stubs_dir}'\n    ],\n    install_requires=[f\"drjit=={drjit_version}\"],\n    packages=['mitsuba'],\n    entry_points={\n        'console_scripts': [\n            'mitsuba = mitsuba.cli:_main',\n        ]\n    },\n    python_requires=\">=3.8\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"pybind11\", \"drjit==0.2.1\"]\n\n[tool.pytest.ini_options]\nnorecursedirs = [ \"ext\" ]\n"
  },
  "wang-ps/O-CNN": {
    "virtual_scanner/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"ocnn.virtualscanner\",\n    version=\"18.09.05\",\n    description=\"Virtual scanner utilities\",\n    author='Microsoft',\n    author_email=\"dapisani@microsoft.com\",\n    packages=['ocnn', 'ocnn.virtualscanner'],\n    zip_safe=False,\n    install_requires=['Cython', 'pyyaml'],\n    package_dir={'': 'python'},\n    package_data={'ocnn.virtualscanner': ['*.pxd']}\n)\n"
  },
  "pylada/pylada-light": {
    "setup.py": "\"\"\"Setup PyLada.\"\"\"\nfrom os.path import dirname, join\nfrom sys import platform, version_info\n\nimport setuptools\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nold_setup = setuptools.setup\n\n\ndef wrapped_setup(*args, **kwargs):\n    pckd = kwargs.pop(\"package_dir\", {})\n    pckd[\"\"] = \"src\"\n    kwargs[\"package_dir\"] = pckd\n    return old_setup(*args, **kwargs)\n\n\nsetuptools.setup = wrapped_setup\n\n\ntests_require = [\"pytest>=6.1.0\", \"pytest-bdd>=4.0.1\"]\ninstall_requires = [\n    \"py\",\n    \"numpy\",\n    \"scipy\",\n    \"quantities\",\n    \"cython\",\n    \"six\",\n    \"traitlets\",\n    \"f90nml>=1.0\",\n    \"nbconvert\",\n    \"nbformat\",\n    \"ipykernel\",\n    \"IPython\",\n    \"black\",\n]\nif version_info[0] == 2:\n    tests_require.append(\"mock\")\n\ncmake_args = []\nif platform.lower() == \"darwin\":\n    cmake_args.append(\"-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9\")\n\nsetup(\n    name=\"pylada\",\n    version=\"1.0.1\",\n    install_requires=install_requires,\n    platforms=[\"GNU/Linux\", \"Unix\", \"Mac OS-X\"],\n    author=[\"Peter Graf\", \"Mayeul d'Avezac\"],\n    author_email=[\"peter.graf@nrel.gov\", \"mayeul.davezac@ic.ac.uk\"],\n    description=\"Productivity environment for Density Functional Theory\",\n    license=\"GPL-2\",\n    url=\"https://github.com/pylada/pylada\",\n    packages=find_packages(\"src\", exclude=\"tests\"),\n    package_dir={\"\": \"src\"},\n    keywords=\"Physics\",\n    classifiers=[\n        \"Development Status :: 0 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: GNU Public License v2 (GPLv2)\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3.3\",\n        \"Programming Language :: Python :: 2.7\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Software Development :: Libraries :: Application Frameworks\",\n    ],\n    long_description=open(join(dirname(__file__), \"README.rst\"), \"r\").read(),\n    extras_require={\"dev\": tests_require},\n    cmake_args=cmake_args,\n    cmake_languages=(\"CXX\", \"Fortran\"),\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\",\n            \"cmake!=3.16.3\", \"ninja\", \"cython\", \"numpy\"]\n"
  },
  "gostevehoward/confseq": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\n\n__version__ = '0.0.11'\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name='confseq',\n    version=__version__,\n    author='Steve Howard',\n    author_email='dev@gostevehoward.com',\n    url='https://github.com/gostevehoward/confseq',\n    description='Confidence sequences and uniform boundaries',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=find_packages('src'),\n    package_dir={'': 'src'},\n    cmake_install_dir=\"src/confseq\",\n    include_package_data = True,\n    install_requires=['pybind11>=2.3', 'numpy', 'matplotlib', 'multiprocess',\n                      'scipy', 'pytest', 'pandas'],\n    zip_safe=False,\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: C++\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n        \"Topic :: Scientific/Engineering :: Mathematics\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"pybind11~=2.6.0\",\n    \"cmake\",\n    \"scikit-build\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nmarkers = [\n    \"random: marks tests as random (deselect with '-m \\\"not random\\\"')\"\n]\n",
    "setup.cfg": "[metadata]\ndescription-file = README.md\n"
  },
  "3dgeo-heidelberg/py4dgeo": {
    "setup.py": "from skbuild import setup\n\n\nsetup(\n    packages=[\"py4dgeo\"],\n    package_dir={\"\": \"src\"},\n    zip_safe=False,\n    cmake_args=[\n        \"-DBUILD_DOCS=OFF\",\n        \"-DBUILD_TESTING=OFF\",\n    ],\n    cmake_install_dir=\"src/py4dgeo\",\n)\n",
    "pyproject.toml": "# This section describes the requirements of the build/installation\n# process itself. Being able to do this was the original reason to\n# introduce pyproject.toml\n[build-system]\nrequires = [\"setuptools>=61,<64\", \"wheel\", \"scikit-build\", \"cmake>=3.17\"]\nbuild-backend = \"setuptools.build_meta\"\n\n# This section provides general project metadata that is used across\n# a variety of build tools. Notably, the version specified here is the\n# single source of truth for py4dgeo's version\n[project]\nname = \"py4dgeo\"\nversion = \"0.5.0\"\ndescription = \"Library for change detection in 4D point cloud data\"\nreadme = \"README.md\"\nmaintainers = [\n    { name = \"Dominic Kempf\", email = \"ssc@iwr.uni-heidelberg.de\" },\n]\nrequires-python = \">=3.8\"\nlicense = { file = \"LICENSE.md\" }\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: C++\",\n    \"Operating System :: OS Independent\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Topic :: Scientific/Engineering :: GIS\",\n    \"Intended Audience :: Science/Research\",\n]\ndependencies = [\n    \"dateparser\",\n    \"laspy[lazrs]>=2.0,<3.0\",\n    \"matplotlib\",\n    \"numpy\",\n    \"requests\",\n    \"seaborn\",\n    \"xdg\",\n]\n\n# Command line scripts installed as part of the installation\n[project.scripts]\ncopy_py4dgeo_test_data = \"py4dgeo.util:copy_test_data_entrypoint\"\n\n# NB: Setuptools-specific build options are currently still stored\n#     in setup.py, as scikit-build is not (yet) supporting PEP621.\n#     Later on, these will be stored in [tool.setuptools]\n\n# The next section configures building wheels in Continuous Integration\n# The cibuildwheel documentation covers the available options in detail:\n# https://cibuildwheel.readthedocs.io/en/stable/options/\n[tool.cibuildwheel]\n# Super-verbose output for debugging purpose\nbuild-verbosity = 3\n\n# We restrict ourselves to recent Python versions.\n# We temporarily skip win32 builds, because lazrs\n# does not provide Win32 wheels.\nskip = \"pp* *p27-* cp35-* cp36-* cp37-* *musllinux* *-win32\"\n\n# Testing commands for our wheels\ntest-command = \"pytest {package}/tests/python\"\ntest-requires = [\"pytest\", \"ruptures\"]\n\n[tool.cibuildwheel.macos]\nbefore-all = \"brew install libomp\"\nenvironment = { OpenMP_ROOT=\"$(brew --prefix libomp)\" }\n\n# The following is the configuration for the pytest test suite\n[tool.pytest.ini_options]\ntestpaths = [\n    \"tests/python\",\n    \"jupyter\",\n]\nfilterwarnings = [\n    \"ignore:The localize method is no longer necessary, as this time zone supports the fold attribute\",\n    \"ignore:distutils Version classes are deprecated. Use packaging.version instead.\",\n]\n"
  },
  "ssciwr/cookiecutter-cpp-project": {
    "{{cookiecutter.project_slug}}/setup.py": "from skbuild import setup\n{%- if cookiecutter.use_submodules == \"No\" %}\nimport os\nimport pybind11\n{%- endif %}\n\n\nsetup(\n    packages=[\"{{ cookiecutter|modname }}\"],\n    package_dir={\"\": \"python\"},\n    zip_safe=False,\n    cmake_args=[\n        \"-DBUILD_TESTING=OFF\",\n        \"-DBUILD_DOCS=OFF\",\n{%- if cookiecutter.use_submodules == \"No\" %}\n        f\"-DCMAKE_PREFIX_PATH={os.path.dirname(pybind11.__file__)}\",\n{%- endif %}\n    ],\n    cmake_install_dir=\"python/{{ cookiecutter|modname }}\",\n)\n",
    "{{cookiecutter.project_slug}}/pyproject.toml": "# This section describes the requirements of the build/installation\n# process itself. Being able to do this was the original reason to\n# introduce pyproject.toml\n[build-system]\nrequires = [\n    \"setuptools>=61\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake>=3.9\",\n{%- if cookiecutter.use_submodules == \"No\" %}\n    \"pybind11[global]=={{ cookiecutter._pybind_version }}\",\n{%- endif %}\n]\nbuild-backend = \"setuptools.build_meta\"\n\n# This section provides general project metadata that is used across\n# a variety of build tools. Notably, the version specified here is the\n# single source of truth for {{ cookiecutter|modname }}'s version\n[project]\nname = \"{{ cookiecutter|modname }}\"\nversion = \"0.0.1\"\ndescription = \"Add short description here\"\nreadme = \"README.md\"\nmaintainers = [\n    { name = \"{{ cookiecutter.full_name}}\", email = \"your@email.com\" },\n]\nrequires-python = \">=3.8\"\n{%- if cookiecutter.license != \"None\" %}\nlicense = { text = \"{{ cookiecutter.license }}\" }\n{%- endif %}\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"Operating System :: OS Independent\",\n{%- if cookiecutter.license == \"MIT\" %}\n    \"License :: OSI Approved :: MIT License\",\n{%- elif cookiecutter.license == \"BSD-2\" %}\n    \"License :: OSI Approved :: BSD License\",\n{%- elif cookiecutter.license == \"GPL-3.0\" %}\n    \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n{%- elif cookiecutter.license == \"LGPL-3.0\" %}\n    \"License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)\",\n{%- endif %}\n]\ndependencies = []\n\n# NB: Setuptools-specific build options are currently still stored\n#     in setup.py, as scikit-build is not (yet) supporting PEP621.\n#     Later on, these will be stored in [tool.setuptools]\n\n# The following is the configuration for the pytest test suite\n[tool.pytest.ini_options]\ntestpaths = [\"tests/python\"]\n\n{% if cookiecutter.pypi_release == \"Yes\" -%}\n# The next section configures building wheels in Continuous Integration\n# The cibuildwheel documentation covers the available options in detail:\n# https://cibuildwheel.readthedocs.io/en/stable/options/\n[tool.cibuildwheel]\n# The variables in this section allow you to customize the process how the wheels\n# for the Python packages are built. For a list of options, see this\n# page: https://cibuildwheel.readthedocs.io/en/stable/options/\n\n# Verbose output is helpful for understanding CI failures\nbuild-verbosity = 3\n\n# We restrict ourselves to recent Python versions\nskip = \"pp* *p27-* cp35-* cp36-* cp37-* *musllinux*\"\n\n# Testing commands for our wheels\ntest-command = \"pytest {package}/tests/python\"\ntest-requires = [\"pytest\"]\n{%- endif %}"
  },
  "DLR-SC/memilio": {
    "pycode/memilio-simulation/setup.py": "import os\nimport subprocess\nimport sys\n\nfrom setuptools import find_packages, setup\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.')\n    print('Installation:  python -m pip install scikit-build')\n    subprocess.check_call(\n        [sys.executable, \"-m\", \"pip\", \"install\", \"scikit-build\"])\n    from skbuild import setup\n\n__version__ = '0.7.0'\n\nsetup(\n    name='memilio-simulation', version=__version__, author='DLR-SC',\n    author_email='daniel.abele@dlr.de', maintainer_email='Martin.Kuehn@DLR.de',\n    url='https://github.com/DLR-SC/memilio',\n    description='Part of MEmilio project, python bindings to the C++ libraries that contain the models and simulations.',\n    packages=find_packages(\n        where=os.path.dirname(os.path.abspath(__file__))),\n    setup_requires=['cmake'],\n    install_requires=[],\n    extras_require={'dev': ['numpy >= 1.22'], },\n    long_description='', test_suite='memilio.simulation_test',)\n",
    "pycode/memilio-generation/setup.py": "import os\nimport subprocess\nimport sys\n\nfrom setuptools import find_packages, setup\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.')\n    print('Installation:  python -m pip install scikit-build')\n    subprocess.check_call(\n        [sys.executable, \"-m\", \"pip\", \"install\", \"scikit-build\"])\n    from skbuild import setup\n\n__version__ = '0.1.0'\n\nsetup(\n    name='memilio-generation',\n    version=__version__,\n    author='DLR-SC',\n    author_email='maximilian.betz@dlr.de',\n    maintainer_email='martin.kuehn@dlr.de',\n    url='https://github.com/DLR-SC/memilio',\n    description='Part of MEmilio project, automatic generation of model specific python bindings.',\n    packages=find_packages(\n        where=os.path.dirname(os.path.abspath(__file__))),\n    setup_requires=['cmake'],\n    install_requires=['libclang==14.0.6',\n                      'dataclasses', 'dataclasses_json', 'importlib-resources>=1.1.0; python_version < \\'3.9\\''],\n    extras_require={'dev': []},\n    long_description='',\n    test_suite='memilio.generation_test',\n    package_data={'memilio.generation': [\n        '../../_skbuild/*/cmake-build/compile_commands.json', '../tools/config.json']},\n)\n"
  },
  "alibaba/code-data-share-for-python": {
    "setup.py": "from pathlib import Path\n\nfrom skbuild import setup\n\nreadme = Path('README.rst').read_text()\n\n# scikit-build/scikit-build#521 to workaround `pip install .`\nfor i in (Path(__file__).resolve().parent / \"_skbuild\").rglob(\"CMakeCache.txt\"):\n    i.unlink()\n\nsetup(\n    name='code-data-share',\n    version='0.1.0',\n    packages=['cds'],\n    package_dir={'': 'src'},\n    python_requires='>=3.8.0',\n    tests_require=['pytest'],\n    long_description_content_type='text/x-rst; charset=UTF-8',\n    long_description=readme,\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'Operating System :: MacOS :: MacOS X',\n        # 'Operating System :: Microsoft :: Windows',\n        'Operating System :: POSIX :: Linux',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: Implementation :: CPython',\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\n\n[tool.cibuildwheel]\nbuild = \"cp312-*\"\n\n[tool.cibuildwheel.linux]\narchs = [\"x86_64\", \"aarch64\"]\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"universal2\", \"arm64\"]\n"
  },
  "zivid/zivid-python": {
    "setup.py": "import tempfile\nimport platform\nimport subprocess\nfrom sys import version_info\nfrom pathlib import Path\nfrom pkgutil import iter_modules\nfrom skbuild import setup\n\n\n# To be replaced by: from setuptools_scm import get_version\ndef get_version():\n    return \"2.9.0\"\n\n\ndef _zivid_sdk_version():\n    return \"2.9.0\"\n\n\ndef _zivid_python_version():\n    scm_version = get_version()\n\n    if \"+\" in scm_version:\n        base_version, scm_metadata = scm_version.split(\"+\", 1)\n    else:\n        base_version = scm_version\n        scm_metadata = None\n\n    base_version = \"{}.{}\".format(base_version, _zivid_sdk_version())\n\n    if scm_metadata:\n        version = \"{}+{}\".format(base_version, scm_metadata)\n    else:\n        version = base_version\n\n    return version\n\n\ndef _python_version():\n    return \"{}.{}.{}\".format(*version_info)\n\n\ndef _make_message_box(*message):\n    width = max(len(e) for e in message)\n\n    box_bar = \"+-\" + \"-\" * width + \"-+\"\n    empty_line = \"\\n| \" + \" \" * width + \" |\\n\"\n    message_lines = [\"| \" + line + \" \" * (width - len(line)) + \" |\" for line in message]\n\n    return (\n        \"\\n\\n\" + box_bar + \"\\n\" + empty_line.join(message_lines) + \"\\n\" + box_bar + \"\\n\"\n    )\n\n\ndef _check_dependency(module_name, package_hint=None):\n    if package_hint is None:\n        package_hint = module_name\n    if module_name not in [module[1] for module in iter_modules()]:\n        raise ImportError(\n            _make_message_box(\n                \"!! Missing module '{}' !!\".format(module_name),\n                \"Please install '{}' manually or use PIP>=19 to handle build dependencies automatically (PEP 517)\".format(\n                    package_hint\n                ),\n            )\n        )\n\n\ndef _check_cpp17_compiler():\n    def run_process(args, **kwargs):\n        try:\n            with subprocess.Popen(args, **kwargs) as process:\n                exit_code = process.wait()\n                if exit_code != 0:\n                    raise RuntimeError(\n                        \"Wait failed with exit code {}\".format(exit_code)\n                    )\n        except Exception as ex:\n            raise type(ex)(\"Process failed: '{}'.\".format(\" \".join(args))) from ex\n\n    try:\n        run_process((\"cmake\", \"--version\"))\n    except Exception as ex:\n        raise RuntimeError(_make_message_box(\"!! CMake not found !!\")) from ex\n    with tempfile.TemporaryDirectory(prefix=\"zivid-python-build-\") as temp_dir:\n        with (Path(temp_dir) / \"lib.cpp\").open(\"w\") as lib_cpp:\n            # MSVC does not report itself as C++17, on Windoes we have to rely on the CMAKE_CXX_STANDARD test below\n            if platform.system() == \"Linux\":\n                lib_cpp.write(\"static_assert(__cplusplus >= 201703L);\")\n        with (Path(temp_dir) / \"CMakeLists.txt\").open(\"w\") as cmake_lists_txt:\n            cmake_lists_txt.write(\n                \"project(zivid-python-compiler-detection LANGUAGES CXX)\\n\"\n                \"set(CMAKE_CXX_STANDARD 17)\\n\"\n                \"add_library(lib lib.cpp)\\n\"\n            )\n        try:\n            if platform.system() == \"Linux\":\n                run_process((\"cmake\", \"-GNinja\", \".\"), cwd=temp_dir)\n            else:\n                run_process((\"cmake\", \".\"), cwd=temp_dir)\n            run_process((\"cmake\", \"--build\", \".\"), cwd=temp_dir)\n        except Exception as ex:\n            raise RuntimeError(\n                _make_message_box(\n                    \"!! Module setup failed !!\",\n                    \"Make sure you have a working C++17 compiler installed\",\n                    \"Refer to Readme.md for detailed installation instructions\",\n                )\n            ) from ex\n\n\ndef _main():\n    # This list is a duplicate of the build-system requirements in pyproject.toml.\n    # The purpose of these checks is to help users with PIP<19 lacking support for\n    # pyproject.toml\n    # Keep the two lists in sync\n    _check_dependency(\"cmake\")\n    _check_dependency(\"conans\", \"conan\")\n    _check_dependency(\"ninja\")\n    _check_dependency(\"skbuild\", \"scikit-build\")\n\n    _check_cpp17_compiler()\n\n    setup(\n        name=\"zivid\",\n        version=_zivid_python_version(),\n        description=\"Defining the Future of 3D Machine Vision\",\n        long_description=Path(\"README.md\").read_text(encoding=\"utf-8\"),\n        long_description_content_type=\"text/markdown\",\n        url=\"https://www.zivid.com\",\n        author=\"Zivid AS\",\n        author_email=\"customersuccess@zivid.com\",\n        license=\"BSD 3-Clause\",\n        packages=[\"zivid\", \"zivid._calibration\", \"zivid.experimental\", \"_zivid\"],\n        package_dir={\"\": \"modules\"},\n        install_requires=[\"numpy\"],\n        cmake_args=[\n            \"-DZIVID_PYTHON_VERSION=\" + _zivid_python_version(),\n            \"-DZIVID_SDK_VERSION=\" + _zivid_sdk_version(),\n            \"-DPYTHON_INTERPRETER_VERSION=\" + _python_version(),\n        ],\n        classifiers=[\n            \"License :: OSI Approved :: BSD License\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: Implementation :: CPython\",\n            \"Topic :: Scientific/Engineering\",\n        ],\n    )\n\n\nif __name__ == \"__main__\":\n    _main()\n",
    "pyproject.toml": "[build-system]\n# This list is duplicated in setup.py\n# Keep the two lists in sync\nrequires = [\n    \"cmake\",\n    \"conan>=1,<2\",\n    \"ninja\",\n    \"scikit-build\",\n    ]\n"
  },
  "datasig-ac-uk/esig": {
    "setup.py": "import os\nimport platform\n#from tools import install_helpers as helpers\n#from setuptools import setup, find_packages, Extension\n#from setuptools.command.build_ext import build_ext\n#from tools.switch_generator import SwitchGenerator\n\nfrom skbuild import setup\nfrom pathlib import Path\nfrom setuptools import find_packages\n\n#configuration = helpers.InstallationConfiguration(os.path.dirname(os.path.realpath(__file__)))\n\n\n# SWITCH_GEN = SwitchGenerator()\n\n#SWITCH_GEN = SwitchGenerator({\n#    2: 5,\n#    3: 5,\n#    4: 2,\n#    5: 2\n#})\n\n\n# class BuildExtensionCommand(build_ext):\n#     \"\"\"\n#     Extends the build_ext class, allowing for the injection of additional code into the build_ext process.\n#     \"\"\"\n#     def run(self):\n#         \"\"\"\n#         Attempts to import numpy and append the result of numpy.get_include() to the self.include_dirs list.\n#         This is to avoid the circular issue of importing numpy at the top of the module.\n#         See https://stackoverflow.com/a/42163080.\n#\n#         Args:\n#             self (NumpyExtensionCommand): Instance of self.\n#\n#         Returns:\n#             None\n#         \"\"\"\n#         print(\"Running extra esig pre-build commands...\")\n#         print(\"Building switch.h\")\n#         SWITCH_GEN.write_file()\n#         print(\"Done\")\n#\n#         import numpy\n#         self.include_dirs.append(numpy.get_include())\n#         build_ext.run(self)\n#\n#\n#\n# # https://stackoverflow.com/questions/2584595/building-a-python-module-and-linking-it-against-a-macosx-framework\n# if not configuration.no_recombine and configuration.platform == helpers.PLATFORM.MACOS:\n#     home = os.environ[\"HOME\"]\n#     os.environ['LDFLAGS'] = \\\n#         '-F ' + home + '/lyonstech/ ' + \\\n#         '-framework recombine ' + \\\n#         '-Wl,-rpath,' + home + '/lyonstech/'\n#\n# esig_sources = [\n#     'src/tosig_module.cpp',\n#     'src/Cpp_ToSig.cpp',\n#     'src/ToSig.cpp',\n# ]\n#\n# esig_depends = [\n#     'src/ToSig.h',\n#     'src/ToSig.cpp',\n#     'src/switch.h',\n# ]\n#\n# if not configuration.no_recombine:\n#     esig_sources.extend([\n#         'recombine/_recombine.cpp',\n#         'recombine/TestVec/RdToPowers2.cpp'\n#     ])\n#     esig_depends.extend([\n#         'recombine/TestVec/OstreamContainerOverloads.h',\n#         'recombine/_recombine.h'\n#     ])\n#\n# esig_extension = Extension(\n#     'esig.tosig',\n#     sources=esig_sources,\n#     language=\"c++\",\n#     # relationship between depends and include_dirs is unclear\n#     depends=esig_depends,\n#     include_dirs=configuration.include_dirs,\n#     library_dirs=configuration.library_dirs,\n#     define_macros=configuration.define_macros,\n#     libraries=configuration.used_libraries,\n#     extra_compile_args=configuration.extra_compile_args,\n# )\n#     extra_link_args=configuration.linker_args,\n#\n# package_data = {\n# \t\"esig\": [\"VERSION\", \"ERROR_MESSAGE\"]\n# }\n#\nextras_require = {\n     \"iisignature\": [\"iisignature\"],\n}\n\n# eager_resources = []\n#\n# if not configuration.no_recombine and configuration.platform == helpers.PLATFORM.WINDOWS:\n#     package_data[\"esig\"] += [\n#         os.path.join(\"libiomp5md.dll\"),\n#         os.path.join(\"recombine.dll\")\n#     ]\n#     # not sure why this is needed, and if it is, why package_data also needs to mention them\n#     eager_resources += [\"libiomp5md.dll\", \"recombine.dll\"]\n\n\nimport io\n\n\nPATH = os.path.dirname(os.path.abspath(__file__))\n\nwith io.open(os.path.join(PATH, \"src\", \"esig\", \"VERSION\"), \"rt\") as fp:\n    VERSION = fp.read()\n\nwith io.open(os.path.join(PATH, \"README.md\"), \"rt\") as fp:\n    DESCRIPTION = fp.read()\n\n\nwith io.open(os.path.join(PATH, \"CHANGELOG\"), \"rt\") as fp:\n    DESCRIPTION += \"\\n\\n\\n##Changelog\\n\" + fp.read()\n\n\n\nCMAKE_SETTINGS = [\n    \"-DLIBALGEBRA_NO_SERIALIZATION:BOOL=ON\",\n]\nif platform.system() == \"Windows\":\n    vcpkg = Path(\"build\", \"vcpkg\")\n    if vcpkg.exists():\n        CMAKE_SETTINGS.append(\"-DCMAKE_TOOLCHAIN_FILE=%s\" % (vcpkg.resolve() / \"scripts\" / \"buildsystems\" / \"vcpkg.cmake\"))\n    elif \"VCPKG_INSTALLATION_ROOT\" in os.environ:\n        vcpkg = Path(os.environ[\"VCPKG_INSTALLATION_ROOT\"])\n        if vcpkg.exists():\n            CMAKE_SETTINGS.append(\"-DCMAKE_TOOLCHAIN_FILE=%s\" % (vcpkg.resolve() / \"scripts\" / \"buildsystems\" / \"vcpkg.cmake\"))\n\n    if platform.system() == 'Windows':\n        CMAKE_SETTINGS.append(\"-DRECOMBINE_INSTALL_DEPENDENTS:BOOL=ON\")\n\n\ndef filter_cmake_manifests(cmake_manifest):\n\n    def _filter(item):\n        item = str(item)\n        if item.endswith(\".pc\"):\n            return False\n        elif item.endswith(\".cmake\"):\n            return False\n        elif item.endswith(\".cpp\"):\n            return False\n        elif item.endswith(\".h\"):\n            return False\n        return True\n\n    return list(filter(_filter, cmake_manifest))\n\n\n\nsetup(\n    name='esig',\n    version=VERSION,\n\n    author='Terry Lyons',\n    author_email='software@lyonstech.net',\n    url='http://esig.readthedocs.io/en/latest/',\n    license='GPLv3',\n\n    keywords='data streams rough paths signatures',\n\n    description=\"This package provides \\\"rough path\\\" tools for analysing vector time series.\",\n    long_description=DESCRIPTION,\n    long_description_content_type=\"text/markdown\",\n\n    include_package_data=True,\n    package_dir={\"\": \"src\"},\n    packages=find_packages(where=\"src\"),\n    test_suite='esig.tests.get_suite',\n\n    # package_data=package_data,\n    # eager_resources=eager_resources,\n    # distclass=helpers.BinaryDistribution,\n    # ext_modules=[esig_extension],\n    cmake_process_manifest_hook=filter_cmake_manifests,\n\n    cmake_args=CMAKE_SETTINGS,\n    install_requires=['numpy>=1.7'],\n    extras_require=extras_require,\n\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Developers',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Topic :: Scientific/Engineering :: Mathematics',\n        ],\n\n    # cmdclass={\n    #     'build_ext': BuildExtensionCommand,\n    # }\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\",\n    \"oldest-supported-numpy\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n\n[tool.cibuildwheel]\nskip = [\"*-musl*\", \"pp*\", \"cp3{8,9,10}-*linux_i686\"]\nbuild-verbosity = 1\n\ntest-requires = [\"pytest\", \"numpy\"]\ntest-command = [\n    \"pytest {project}/tests\"\n    ]\n\n[tool.cibuildwheel.windows]\nbefore-build = \"pip install delvewheel \"\nrepair-wheel-command = \"delvewheel show {wheel} --ignore-in-wheel && delvewheel repair -w {dest_dir} --ignore-in-wheel {wheel}\"\n\n[tool.cibuildwheel.macos]\nbefore-all = \"source $ONEAPI_SCRIPT\"\n#repair-wheel-command = \"\"\n\n[tool.cibuildwheel.linux]\nbefore-all = \"bash build/install-deps-linux.sh\"\n",
    "setup.cfg": "[metadata]\ndescription_file = README.md\n\n[egg_info]\ntag_build =\ntag_date = 0\n"
  },
  "ethz-asl/3dsnet": {
    "auxiliary/sampling_and_meshing/O-CNN/virtual_scanner/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"ocnn.virtualscanner\",\n    version=\"18.09.05\",\n    description=\"Virtual scanner utilities\",\n    author='Microsoft',\n    author_email=\"dapisani@microsoft.com\",\n    packages=['ocnn', 'ocnn.virtualscanner'],\n    zip_safe=False,\n    install_requires=['Cython', 'pyyaml'],\n    package_dir={'': 'python'},\n    package_data={'ocnn.virtualscanner': ['*.pxd']}\n)\n"
  },
  "RockRobotic/copc-lib": {
    "setup.py": "from skbuild import setup\n\n# Get the version from the pdal module\nwith open(\"version\", \"r\") as file:\n    lines = file.readlines()\n    version = lines[0]\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fp:\n    readme = fp.read()\n\nfrom setuptools import find_packages\n\nsetup(\n    name=\"copclib\",\n    version=version,\n    description=\" copc-lib provides an easy-to-use interface for reading and creating Cloud Optimized Point Clouds\",\n    license=\"BSD\",\n    keywords=\"point cloud spatial copc\",\n    author=\"Rock Robotic Inc.\",\n    author_email=\"support@rockrobotic.com\",\n    maintainer=\"Rock Robotic Inc.\",\n    maintainer_email=\"support@rockrobotic.com\",\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/RockRobotic/copc-lib\",\n    extras_require={\"test\": [\"pytest\", \"numpy\"]},\n    cmake_args=[\"-DWITH_PYTHON:BOOL=ON\", \"-DWITH_TESTS=OFF\", \"-DEMSCRIPTEN=OFF\"],\n    cmake_install_dir=\"python/copclib\",\n    packages=find_packages(where=\"python\"),\n    package_dir={\"\": \"python\"},\n    exclude_package_data={\"\": [\"libs/laz-perf\"]},\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Topic :: Scientific/Engineering :: GIS\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"pybind11>=2.8.0\",\n    \"cmake>=3.21\",\n    \"scikit-build>=0.12\",\n    \"mypy\",\n    \"ninja\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\"\n"
  },
  "tmontaigu/CloudCompare-PythonPlugin": {
    "wrapper/cccorelib/setup.py": "from skbuild import setup\n\n# The information here can also be placed in setup.cfg - better separation of\n# logic and declaration, and simpler if you include description/version in a file.\nsetup(\n    name=\"cccorelib\",\n    version=\"0.0.1\",\n    author=\"Thomas Montaigu\",\n    author_email=\"thomas.montaigu@laposte.net\",\n    description=\"Python bindings for CCCoreLib\",\n    packages=[\"cccorelib\"],\n    package_data={\n      'cccorelib': ['*.pyi'],\n    },\n    include_package_data=True,\n    cmake_args=['-GNinja'],\n    install_requires=[\"numpy\"],\n    zip_safe=False,\n)\n",
    "wrapper/cccorelib/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"ninja\",\n    \"cmake>=3.12\",\n    \"pybind11>=2.6.0\",\n    \"scikit-build\"\n]\nbuild-backend = \"setuptools.build_meta\"\n",
    "wrapper/pycc/setup.py": "from skbuild import setup\n\n# The information here can also be placed in setup.cfg - better separation of\n# logic and declaration, and simpler if you include description/version in a file.\nsetup(\n    name=\"pycc\",\n    version=\"0.0.1\",\n    author=\"Thomas Montaigu\",\n    author_email=\"thomas.montaigu@laposte.net\",\n    description=\"Python bindings for CloudCompare libs\",\n    long_description=\"\",\n    packages=[\"pycc\"],\n    cmake_args=['-GNinja', '-DOPTION_BUILD_CCVIEWER=OFF'],\n    zip_safe=False,\n)\n",
    "wrapper/pycc/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"ninja\",\n    \"cmake>=3.12\",\n    \"pybind11>=2.6.0\",\n    \"scikit-build\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "dfm/jax-finufft": {
    "setup.py": "#!/usr/bin/env python\n\nimport codecs\nimport os\nimport shutil\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nHERE = os.path.dirname(os.path.realpath(__file__))\n\n\ndef read(*parts):\n    with codecs.open(os.path.join(HERE, *parts), \"rb\", \"utf-8\") as f:\n        return f.read()\n\n\n# Otherwise build seems to fail with wrong venv path\nif os.path.exists(\"_skbuild\"):\n    shutil.rmtree(\"_skbuild\")\n\n\nsetup(\n    name=\"jax-finufft\",\n    author=\"Dan Foreman-Mackey\",\n    author_email=\"foreman.mackey@gmail.com\",\n    url=\"https://github.com/dfm/jax-finufft\",\n    license=\"MIT\",\n    description=\"Unofficial JAX bindings for finufft\",\n    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    packages=find_packages(\"src\"),\n    package_dir={\"\": \"src\"},\n    include_package_data=True,\n    python_requires=\">=3.7\",\n    install_requires=[\"jax\", \"jaxlib\"],\n    extras_require={\"test\": [\"pytest\"]},\n    cmake_install_dir=\"src/jax_finufft\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"setuptools_scm[toml]>=3.4\",\n    \"pybind11>=2.6\",\n    \"scikit-build>=0.12\",\n    \"cmake\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"src/jax_finufft/jax_finufft_version.py\"\n\n[tool.isort]\nprofile = \"black\"\n"
  },
  "InsightSoftwareConsortium/ITKTubeTK": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nfrom pathlib import Path\nthis_directory = Path(__file__).parent\nsetup_readme_text = (this_directory / \"setup-readme.md\").read_text()\n\n    #include_dirs=[np.get_include()],\nsetup(\n    name='itk-tubetk',\n    version='1.3.5',\n    author='Stephen R. Aylward',\n    author_email='stephen.aylward@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKTubeTK',\n    description=r'An open-source toolkit, led by Kitware, Inc., for the segmentation, registration, and analysis of tubes (e.g., blood vessels) in images.',\n    long_description=setup_readme_text,\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit Tubes Vessels Nerves Ultrasound MRI CT Medical',\n    url=r'https://github.com/InsightSoftwareConsortium/ITKTubeTK/',\n    project_urls={\n        'Github': 'https://github.com/InsightSoftwareConsortium/ITKTubeTK/',\n        'Issue Tracker': 'https://github.com/InsightSoftwareConsortium/ITKTubeTK/issues',\n        'Testing Data': 'https://data.kitware.com/#collection/5888b7d38d777f4f3f3085a8/folder/58a3abf08d777f0721a65b16',\n        'ITK': 'https://itk.org',\n        },\n    install_requires=[\n        r'numpy',\n        r'itk>=5.3.0',\n        r'itk-minimalpathextraction>=1.2.6'\n    ]\n    )\n"
  },
  "daanzu/wenet_stt_python": {
    "setup.py": "#\n# This file is part of wenet_stt_python.\n# (c) Copyright 2021 by David Zurow\n# Licensed under the AGPL-3.0; see LICENSE file.\n#\n\nfrom setuptools import find_packages\nimport datetime, os, re, subprocess\n\nfrom skbuild import setup\n\n\n# Force wheel to be platform specific\n# https://stackoverflow.com/questions/45150304/how-to-force-a-python-wheel-to-be-platform-specific-when-building-it\n# https://github.com/Yelp/dumb-init/blob/48db0c0d0ecb4598d1a6400710445b85d67616bf/setup.py#L11-L27\n# https://github.com/google/or-tools/issues/616#issuecomment-371480314\ntry:\n    from wheel.bdist_wheel import bdist_wheel as bdist_wheel\n    class bdist_wheel_impure(bdist_wheel):\n\n        def finalize_options(self):\n            bdist_wheel.finalize_options(self)\n            # Mark us as not a pure python package\n            self.root_is_pure = False\n\n        def get_tag(self):\n            python, abi, plat = bdist_wheel.get_tag(self)\n            # We don't contain any python source\n            python, abi = 'py2.py3', 'none'\n            return python, abi, plat\n\n    from setuptools.command.install import install\n    class install_platlib(install):\n        def finalize_options(self):\n            install.finalize_options(self)\n            self.install_lib = self.install_platlib\n\nexcept ImportError:\n    bdist_wheel_impure = None\n    install_platlib = None\n\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n# https://packaging.python.org/guides/single-sourcing-package-version/\ndef read(*parts):\n    with open(os.path.join(here, *parts), 'r') as fp:\n        return fp.read()\n\ndef find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\nversion = find_version('src', 'wenet_stt', '__init__.py')\nif version.endswith('dev0'):\n    version = version[:-1] + datetime.datetime.now().strftime('%Y%m%d%H%M%S')\n\nwith open(os.path.join(here, 'README.md')) as f:\n    long_description = f.read()\n\nif not os.path.exists('native/wenet/runtime/server/x86/CMakeLists.txt'):\n    subprocess.check_call(['git', 'submodule', 'update', '--init', 'native/wenet'])\n\n\nsetup(\n    cmdclass={\n        'bdist_wheel': bdist_wheel_impure,\n        'install': install_platlib,\n    },\n    # cmake_args=['-DCMAKE_PREFIX_PATH=' + torch_cmake_prefix_path],\n\n    name='wenet_stt',\n    version=version,\n    description='Simple Python library, distributed via binary wheels with few direct dependencies, for easily using wav2vec 2.0 models for speech recognition.',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://github.com/daanzu/wenet_stt_python',\n    author='David Zurow',\n    author_email='daanzu@gmail.com',\n    license='AGPL-3.0',\n    # For a list of valid classifiers, see https://pypi.org/classifiers/\n    classifiers=[\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: GNU Affero General Public License v3',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n    ],\n    # keywords='speech recognition',\n    packages=find_packages('src'),\n    package_dir={'': 'src'},\n    # py_modules=[splitext(basename(path))[0] for path in glob('src/*.py')],\n    package_data={\n        # 'package_name': ['glob_patterns_to_install'],\n        'wenet_stt': ['libwenet_stt_lib.so', 'libwenet_stt_lib.dylib', '*.dll'],\n        '': ['LICENSE'],\n    },\n    zip_safe=False,\n    cmake_process_manifest_hook=(lambda cmake_manifest: []),  # We manually copy out the files we care about from the cmake build, so ignore everything else that is installed in/by cmake.\n    python_requires='>=3.6, <4',\n    install_requires=[\n        'cffi ~= 1.12',\n        'numpy ~= 1.16, != 1.19.4',\n    ],\n    extras_require={\n        # 'dev': ['check-manifest'],\n        'test': ['pytest'],\n    },\n    project_urls={\n        'Bug Reports': 'https://github.com/daanzu/wenet_stt/issues',\n        'Funding': 'https://github.com/sponsors/daanzu',\n        # 'Say Thanks!': 'http://saythanks.io/to/example',\n        'Source': 'https://github.com/daanzu/wenet_stt/',\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build~=0.10.0\", \"cmake>=3.15\", \"ninja\", \"torch~=1.9.0\"]\n",
    "setup.cfg": "[metadata]\n# This includes the license file(s) in the wheel.\n# https://wheel.readthedocs.io/en/stable/user_guide.html#including-license-files-in-the-generated-wheel-file\nlicense_files = LICENSE\n\n[bdist_wheel]\n# This flag says to generate wheels that support both Python 2 and Python\n# 3. If your code will not run unchanged on both Python 2 and 3, you will\n# need to generate separate wheels for each Python version that you\n# support. Removing this line (or setting universal to 0) will prevent\n# bdist_wheel from trying to make a universal wheel. For more see:\n# https://packaging.python.org/guides/distributing-packages-using-setuptools/#wheels\n# universal=1\n"
  },
  "KitwareMedical/VTKPythonPackage": {
    "setup.py": "from __future__ import print_function\n\nimport os\nimport shlex\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\nfrom vtkVersion import get_versions\n\nsetup(\n    name='vtk',\n    version=get_versions()['package-version'],\n    author='VTK Community',\n    author_email='vtk-developers@vtk.org',\n    packages=['vtk'],\n    package_dir={'vtk': 'vtk'},\n    cmake_args=shlex.split(os.environ.get('VTK_CMAKE_ARGS', '')),\n    py_modules=[\n        'vtkVersion',\n    ],\n    download_url='http://www.vtk.org/download/',\n    description='VTK is an open-source toolkit for 3D computer graphics, image processing, and visualization',\n    long_description='VTK is an open-source, cross-platform library that provides developers with '\n                     'an extensive suite of software tools for 3D computer graphics, image processing,'\n                     'and visualization. It consists of a C++ class library and several interpreted interface '\n                     'layers including Tcl/Tk, Java, and Python. VTK supports a wide variety of visualization '\n                     'algorithms including scalar, vector, tensor, texture, and volumetric methods, as well as '\n                     'advanced modeling techniques such as implicit modeling, polygon reduction, mesh '\n                     'smoothing, cutting, contouring, and Delaunay triangulation. VTK has an extensive '\n                     'information visualization framework and a suite of 3D interaction widgets. The toolkit '\n                     'supports parallel processing and integrates with various databases on GUI toolkits such '\n                     'as Qt and Tk.',\n    classifiers=[\n        \"License :: OSI Approved :: BSD License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='BSD',\n    keywords='VTK visualization imaging',\n    url=r'https://vtk.org/',\n    install_requires=[\n    ]\n    )\n"
  },
  "dmpelt/msdnet": {
    "setup.py": "#-----------------------------------------------------------------------\n#Copyright 2019 Centrum Wiskunde & Informatica, Amsterdam\n#\n#Author: Daniel M. Pelt\n#Contact: D.M.Pelt@cwi.nl\n#Website: http://dmpelt.github.io/msdnet/\n#License: MIT\n#\n#This file is part of MSDNet, a Python implementation of the\n#Mixed-Scale Dense Convolutional Neural Network.\n#-----------------------------------------------------------------------\n\nfrom skbuild import setup\nfrom setuptools import find_packages\nsetup(\n    name='msdnet',\n    packages=find_packages(),\n    version=open('VERSION').read().strip(),\n    include_package_data=True,\n    cmake_languages=['C',],\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n    ],\n)"
  },
  "InsightSoftwareConsortium/ITKThickness3D": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-thickness3d',\n    version='5.3.0',\n    author='Insight Software Consortium',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKThickness3D',\n    description=r'An ITK module to compute 3D thickness',\n    long_description='ITK currently comes without a hands on solution for 3D thickness evaluation. This contribution implements several filters to adress such issues.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "MichaelHillier/surfe": {
    "setup.py": "# import os\n# import re\n# import sys\n# import sysconfig\n# import platform\n# import subprocess\n\n# from distutils.version import LooseVersion\n# from setuptools import setup, find_packages, Extension\n# from setuptools.command.build_ext import build_ext\n\n# # this setup.py has been coppied extensively from https://www.benjack.io/2018/02/02/python-cpp-revisited.html\n\n# class CMakeExtension(Extension):\n#     def __init__(self, name, sourcedir=''):\n#         Extension.__init__(self, name, sources=[])\n#         self.sourcedir = os.path.abspath(sourcedir)\n\n\n# class CMakeBuild(build_ext):\n#     def run(self):\n#         try:\n#             out = subprocess.check_output(['cmake', '--version'])\n#         except OSError:\n#             raise RuntimeError(\n#                 \"CMake must be installed to build the following extensions: \" +\n#                 \", \".join(e.name for e in self.extensions))\n\n#         if platform.system() == \"Windows\":\n#             cmake_version = LooseVersion(re.search(r'version\\s*([\\d.]+)',\n#                                          out.decode()).group(1))\n#             if cmake_version < '3.1.0':\n#                 raise RuntimeError(\"CMake >= 3.1.0 is required on Windows\")\n\n#         for ext in self.extensions:\n#             self.build_extension(ext)\n\n#     def build_extension(self, ext):\n#         extdir = os.path.abspath(\n#             os.path.dirname(self.get_ext_fullpath(ext.name)))\n#         cmake_args = ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=' + extdir,\n#                       '-DPYTHON_EXECUTABLE=' + sys.executable]\n\n#         cfg = 'Debug' if self.debug else 'Release'\n#         build_args = ['--config', cfg]\n\n#         if platform.system() == \"Windows\":\n#             cmake_args += ['-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}'.format(\n#                 cfg.upper(),\n#                 extdir)]\n#             if sys.maxsize > 2**32:\n#                 cmake_args += ['-A', 'x64']\n#             build_args += ['--', '/m']\n#         else:\n#             cmake_args += ['-DCMAKE_BUILD_TYPE=' + cfg]\n#             build_args += ['--', '-j2']\n\n#         env = os.environ.copy()\n#         env['CXXFLAGS'] = '{} -DVERSION_INFO=\\\\\"{}\\\\\"'.format(\n#             env.get('CXXFLAGS', ''),\n#             self.distribution.get_version())\n#         if not os.path.exists(self.build_temp):\n#             os.makedirs(self.build_temp)\n#         try:\n#             rslt = subprocess.run(['cmake', ext.sourcedir] + cmake_args,\n#                               cwd=self.build_temp, env=env,check=True)\n#         except:\n#             return\n#         try:\n#             rslt = subprocess.run(['cmake', '--build', '.'] + build_args,\n#                               cwd=self.build_temp,check=True)\n#         except:\n#             return               \n#         print()  # Add an empty line for cleaner output\n\n# setup(\n#     name='surfepy',\n#     version='0.1',\n#     author='Michael Hillier',\n#     ext_modules=[CMakeExtension('surfepy')],\n#     # add custom build_ext command\n#     cmdclass=dict(build_ext=CMakeBuild),\n#     zip_safe=False,\n# )\n\n\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"scikit-build is required to build from source!\", file=sys.stderr)\n    print(\"Install it running: python -m pip install scikit-build\")\n    sys.exit(1)\n\nimport os\nfrom pathlib import Path\nimport platform\n\nsetup(\n    name=\"surfepy\",\n    version=0.1,\n    author=\"Michael Hillier\",\n    description=\"python bindings for surfe - geological interpolator using rbf\",\n    long_description=\"\",\n    license=\"MIT\",\n    cmake_args=['-DEIGEN3_INCLUDE_DIR=eigen-git-mirror','-DCMAKE_INSTALL_RPATH=$ORIGIN'],\n)\n"
  },
  "Erotemic/shitspotter": {
    "setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport sys\nfrom os.path import exists\n\nfrom setuptools import find_packages\n\nif exists('CMakeLists.txt'):\n    try:\n        import os\n        # Hack to disable all compiled extensions\n        val = os.environ.get('DISABLE_C_EXTENSIONS', '').lower()\n        use_setuptools = val in {'true', 'on', 'yes', '1'}\n\n        if '--universal' in sys.argv:\n            use_setuptools = True\n\n        if '--disable-c-extensions' in sys.argv:\n            sys.argv.remove('--disable-c-extensions')\n            use_setuptools = True\n\n    except ImportError:\n        use_setuptools = True\nelse:\n    use_setuptools = True\n\nif use_setuptools:\n    from setuptools import setup\nelse:\n    from skbuild import setup\n\n\ndef parse_version(fpath):\n    \"\"\"\n    Statically parse the version number from a python file\n    \"\"\"\n    import ast\n    if not exists(fpath):\n        raise ValueError('fpath={!r} does not exist'.format(fpath))\n    with open(fpath, 'r') as file_:\n        sourcecode = file_.read()\n    pt = ast.parse(sourcecode)\n    class VersionVisitor(ast.NodeVisitor):\n        def visit_Assign(self, node):\n            for target in node.targets:\n                if getattr(target, 'id', None) == '__version__':\n                    self.version = node.value.s\n    visitor = VersionVisitor()\n    visitor.visit(pt)\n    return visitor.version\n\n\ndef parse_description():\n    \"\"\"\n    Parse the description in the README file\n\n    CommandLine:\n        pandoc --from=markdown --to=rst --output=README.rst README.md\n        python -c \"import setup; print(setup.parse_description())\"\n    \"\"\"\n    from os.path import dirname, join, exists\n    readme_fpath = join(dirname(__file__), 'README.rst')\n    # This breaks on pip install, so check that it exists.\n    if exists(readme_fpath):\n        with open(readme_fpath, 'r') as f:\n            text = f.read()\n        return text\n    return ''\n\n\ndef parse_requirements(fname='requirements.txt', with_version=False):\n    \"\"\"\n    Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        with_version (bool, default=False): if true include version specs\n\n    Returns:\n        List[str]: list of requirements items\n    \"\"\"\n    from os.path import exists, dirname, join\n    import re\n    require_fpath = fname\n\n    def parse_line(line, dpath=''):\n        \"\"\"\n        Parse information from a line in a requirements text file\n\n        line = 'git+https://a.com/somedep@sometag#egg=SomeDep'\n        line = '-e git+https://a.com/somedep@sometag#egg=SomeDep'\n        \"\"\"\n        # Remove inline comments\n        comment_pos = line.find(' #')\n        if comment_pos > -1:\n            line = line[:comment_pos]\n\n        if line.startswith('-r '):\n            # Allow specifying requirements in other files\n            target = join(dpath, line.split(' ')[1])\n            for info in parse_require_file(target):\n                yield info\n        else:\n            # See: https://www.python.org/dev/peps/pep-0508/\n            info = {'line': line}\n            if line.startswith('-e '):\n                info['package'] = line.split('#egg=')[1]\n            else:\n                if ';' in line:\n                    pkgpart, platpart = line.split(';')\n                    # Handle platform specific dependencies\n                    # setuptools.readthedocs.io/en/latest/setuptools.html\n                    # #declaring-platform-specific-dependencies\n                    plat_deps = platpart.strip()\n                    info['platform_deps'] = plat_deps\n                else:\n                    pkgpart = line\n                    platpart = None\n\n                # Remove versioning from the package\n                pat = '(' + '|'.join(['>=', '==', '>']) + ')'\n                parts = re.split(pat, pkgpart, maxsplit=1)\n                parts = [p.strip() for p in parts]\n\n                info['package'] = parts[0]\n                if len(parts) > 1:\n                    op, rest = parts[1:]\n                    version = rest  # NOQA\n                    info['version'] = (op, version)\n            yield info\n\n    def parse_require_file(fpath):\n        dpath = dirname(fpath)\n        with open(fpath, 'r') as f:\n            for line in f.readlines():\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    for info in parse_line(line, dpath=dpath):\n                        yield info\n\n    def gen_packages_items():\n        if exists(require_fpath):\n            for info in parse_require_file(require_fpath):\n                parts = [info['package']]\n                if with_version and 'version' in info:\n                    parts.extend(info['version'])\n                if not sys.version.startswith('3.4'):\n                    # apparently package_deps are broken in 3.4\n                    plat_deps = info.get('platform_deps')\n                    if plat_deps is not None:\n                        parts.append(';' + plat_deps)\n                item = ''.join(parts)\n                yield item\n\n    packages = list(gen_packages_items())\n    return packages\n\n\ndef native_mb_python_tag(plat_impl=None, version_info=None):\n    \"\"\"\n    Get the correct manylinux python version tag for this interpreter\n\n    Example:\n        >>> print(native_mb_python_tag())\n        >>> print(native_mb_python_tag('PyPy', (2, 7)))\n        >>> print(native_mb_python_tag('CPython', (3, 8)))\n    \"\"\"\n    if plat_impl is None:\n        import platform\n        plat_impl = platform.python_implementation()\n\n    if version_info is None:\n        import sys\n        version_info = sys.version_info\n\n    major, minor = version_info[0:2]\n    ver = '{}{}'.format(major, minor)\n\n    if plat_impl == 'CPython':\n        # TODO: get if cp27m or cp27mu\n        impl = 'cp'\n        if ver == '27':\n            IS_27_BUILT_WITH_UNICODE = True  # how to determine this?\n            if IS_27_BUILT_WITH_UNICODE:\n                abi = 'mu'\n            else:\n                abi = 'm'\n        else:\n            if sys.version_info[:2] >= (3, 8):\n                # bpo-36707: 3.8 dropped the m flag\n                abi = ''\n            else:\n                abi = 'm'\n        mb_tag = '{impl}{ver}-{impl}{ver}{abi}'.format(**locals())\n    elif plat_impl == 'PyPy':\n        abi = ''\n        impl = 'pypy'\n        ver = '{}{}'.format(major, minor)\n        mb_tag = '{impl}-{ver}'.format(**locals())\n    else:\n        raise NotImplementedError(plat_impl)\n    return mb_tag\n\n\nNAME = 'shitspotter'\nVERSION = parse_version('shitspotter/__init__.py')\n\n\nif __name__ == '__main__':\n    setup(\n        name=NAME,\n        version=VERSION,\n        author='joncrall',\n        author_email='erotemic@gmail.com',\n        description=('The shitspotter Module'),\n        url='<shitspotter url>',\n        long_description=parse_description(),\n        long_description_content_type='text/x-rst',\n        install_requires=parse_requirements('requirements/runtime.txt'),\n        extras_require={\n            'all': parse_requirements('requirements.txt'),\n            'tests': parse_requirements('requirements/tests.txt'),\n            'optional': parse_requirements('requirements/optional.txt'),\n            # 'headless': parse_requirements('requirements/headless.txt'),\n            # 'graphics': parse_requirements('requirements/graphics.txt'),\n        },\n        license='Apache 2',\n        packages=find_packages('.'),\n        # entry_points={\n        #     # the console_scripts entry point creates the package CLI\n        #     'console_scripts': [\n        #         # '{SCRIPT_NAME}={MODPATH}:{CALLNAME}',\n        #         'shitspotter = shitspotter.__main__:main'\n        #     ]\n        # },\n        classifiers=[\n            # List of classifiers available at:\n            # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n            'Development Status :: 3 - Alpha',\n            'Intended Audience :: Developers',\n            'Topic :: Software Development :: Libraries :: Python Modules',\n            'Topic :: Utilities',\n            # This should be interpreted as Apache License v2.0\n            'License :: OSI Approved :: Apache Software License',\n            # Supported Python versions\n            'Programming Language :: Python :: 3.6',\n            'Programming Language :: Python :: 3.7',\n            'Programming Language :: Python :: 3.8',\n        ],\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\"]\n"
  },
  "cmpute/d3d": {
    "setup.py": "import os\nfrom setuptools import find_packages\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    raise ImportError('scikit-build is required for installing')\n\ntry:\n    import torch\n    torch_root = os.path.dirname(torch.__file__)\n    torch_ver = torch.__version__.replace('.', '')\n\n    if \"USE_CUDA\" in os.environ:\n        try:\n            use_cuda = int(os.environ[\"USE_CUDA\"])\n        except ValueError:\n            use_cuda = os.environ[\"USE_CUDA\"].lower() == \"true\"\n    else:\n        use_cuda = torch.cuda.is_available()\nexcept ImportError:\n    torch_root = torch_ver = ''\n    use_cuda = False\n    print(\"Pytorch not found, pytorch related operators will not be built.\")\n\ndef full_version(): # get \n    from subprocess import check_output\n    from setuptools_scm.version import get_local_node_and_date\n\n    if use_cuda:\n        try:\n            cuda_ver = check_output([\"nvcc\", \"-V\"]).decode()\n            ver_aidx = cuda_ver.find(\"release\")\n            ver_bidx = cuda_ver.find(',', ver_aidx)\n            cuda_ver = cuda_ver[ver_aidx+8:ver_bidx].replace('.', '')\n        except FileNotFoundError:\n            cuda_ver = ''\n    else:\n        cuda_ver = ''\n\n    full_ver = 'th' + torch_ver if torch_ver else ''\n    full_ver += '.cu' + cuda_ver if cuda_ver else ''\n\n    def full_scheme(version):\n        ver_str = get_local_node_and_date(version)\n        if full_ver:\n            if ver_str.find(\"+\") < 0:\n                ver_str += \"+\" + full_ver\n            else:\n                ver_str += \".\" + full_ver\n        return ver_str\n\n    return {'local_scheme': full_scheme}\n\nextras = {\n    'doc': ['sphinx', 'recommonmark', 'sphinx_rtd_theme'],\n    'test': ['pytest']\n}\n\nsetup(\n    name=\"d3d\",\n    use_scm_version=full_version,\n    description=\"Customized tools for 3D object detection\",\n    long_description='(see project homepage)',\n    author='Jacob Zhong',\n    author_email='cmpute@gmail.com',\n    url='https://github.com/cmpute/d3d',\n    download_url='https://github.com/cmpute/d3d/archive/master.zip',\n    license='BSD-3-Clause',\n    packages=find_packages(),\n    install_requires=['numpy>=1.17.0', 'scipy>=1.4', 'addict', 'pillow', 'tqdm', 'msgpack', 'filterpy', 'sortedcontainers'],\n    setup_requires=['scikit-build', 'setuptools_scm', 'cython>=0.29.16'],\n    extras_require=extras,\n    classifiers=[\n        'Programming Language :: C++',\n        'Programming Language :: Cython',\n        'Programming Language :: Python :: 3',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: OS Independent',\n        'Development Status :: 2 - Pre-Alpha',\n        'Topic :: Scientific/Engineering'\n    ],\n    keywords=['detection', '3d'],\n    entry_points={\n        'console_scripts': [\n            'd3d_waymo_convert = d3d.dataset.waymo.converter:main',\n            'd3d_nuscenes_convert = d3d.dataset.nuscenes.converter:main',\n            'd3d_kitti_parse_result = d3d.dataset.kitti.object:parse_detection_output',\n        ],\n    },\n    cmake_args=[\n        '-DBUILD_WITH_PYTORCH=ON',\n        '-DCMAKE_PREFIX_PATH=%s' % torch_root,\n        '-DBUILD_WITH_CUDA=%s' % (\"ON\" if use_cuda else \"OFF\"),\n        '-DCYTHON_WITH_NO_DOCSTRINGS_ARG=FALSE',\n    ] if torch_root else [\n        '-DBUILD_WITH_PYTORCH=OFF',\n        '-DBUILD_WITH_CUDA=OFF'\n    ]\n)"
  },
  "ctlee/gamer": {
    "setup.py": "# ##### BEGIN GPL LICENSE BLOCK #####\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; either version 2\n#  of the License, or (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to the Free Software Foundation,\n#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n#\n# ##### END GPL LICENSE BLOCK #####\n\n\"\"\"PyGAMer: Geometry-preserving Adaptive Mesher\n\nPyGAMer is a wrapper around the `GAMer <https://github.com/ctlee/gamer/`__ C++ library.\nIt enables users to perform mesh generation and manipulation tasks via Python scripts.\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport re\n\ndef git_version():\n    \"\"\"Get the version from git describe\n\n    Returns:\n        string: version string or None if invalid\n    \"\"\"\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in [\"SYSTEMROOT\", \"PATH\", \"HOME\"]:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env[\"LANGUAGE\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n        env[\"LC_ALL\"] = \"C\"\n        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, env=env)\n        return out\n\n    try:\n        out = _minimal_ext_cmd([\"git\", \"describe\", \"--tags\", \"--dirty\", \"--always\"])\n        GIT_REVISION = out.strip().decode(\"ascii\")\n    except (subprocess.SubprocessError, OSError):\n        GIT_REVISION = None\n\n    return GIT_REVISION\n\ndef standardize_version(version_string):\n    \"\"\"Standardize the version string\n    \n    Args:\n        version_string (str): input version string \n    Returns:\n        str: standardized version\n    \"\"\"\n    VERSION_PATTERN = r\"\"\"\n        v?\n        (?:\n            (?:(?P<epoch>[0-9]+)!)?                           # epoch\n            (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n            (?P<pre>                                          # pre-release\n                [-_\\.]?\n                (?P<pre_l>(alpha|beta|a|b|c|rc))\n                (?P<pre_n>[0-9]+)?\n            )?\n            (?P<dev>                                          # dev release\n                [-_\\.]?\n                (?P<dev_l>dev)\n                [-_\\.]?\n                (?P<dev_n>[0-9]+)?\n            )?\n            (?P<meta>\n                [-_\\.]?\n                (?P<commits_since>[0-9]+)?\n                [-_\\.]?\n                (?P<sha>[a-z0-9]*)?\n                [-_\\.]? \n                (?P<dirty>dirty)?\n            )?\n        )\n    \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    match = _regex.match(version_string)\n    if match:\n        if match.group(\"release\"):\n            version = match.group(\"release\")\n            if match.group(\"pre_l\"):\n                version += match.group(\"pre_l\")\n                if match.group(\"pre_n\"):\n                    version += match.group(\"pre_n\")\n                else:\n                    version += \"0\"\n            if match.group(\"dev\"):\n                version += \"dev\"\n                if match.group(\"dev_n\"):\n                    version += match.group(\"dev_n\")\n                else:\n                    version += \"0\"\n    else:\n        version = \"0.0.0\"\n    return version\n\nversion = git_version()\nif version is None:\n    # Git describe failed... read version from file\n    with open(\"VERSION\", \"r\") as f:\n        version = f.readline()\n    version = standardize_version(version)\nelse:\n    version = standardize_version(version)\n\ncmake_args = [\"-DBUILD_PYGAMER=ON\"]\n\nDOCLINES = __doc__.split(\"\\n\")\n\nCLASSIFIERS = \"\"\"\\\nDevelopment Status :: 4 - Beta\nEnvironment :: Console\nIntended Audience :: Science/Research\nLicense :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)\nNatural Language :: English\nOperating System :: OS Independent\nProgramming Language :: C++\nProgramming Language :: Python :: 3 :: Only\nProgramming Language :: Python :: Implementation :: CPython\nTopic :: Scientific/Engineering :: Bio-Informatics\nTopic :: Scientific/Engineering :: Chemistry\nTopic :: Scientific/Engineering :: Mathematics\nTopic :: Scientific/Engineering :: Physics\nTopic :: Scientific/Engineering :: Visualization\n\"\"\"\n\n# If building on readthedocs.io build with unix makefiles\n_on_rtd = os.environ.get(\"READTHEDOCS\", None) == \"True\"\nif _on_rtd:\n    sys.argv.extend([\"-G\", \"Unix Makefiles\"])\n    cmake_args.append(\"-DGAMER_DOCS=ON\")\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"\\nERROR: scikit-build is required to build from source.\", file=sys.stderr)\n    print(\"Please run:\", file=sys.stderr)\n    print(\"\", file=sys.stderr)\n    print(\"  python -m pip install scikit-build\\n\", file=sys.stderr)\n    print(\"  -- or --\\n\", file=sys.stderr)\n    print(\"  conda install scikit-build\", file=sys.stderr)\n    sys.exit(1)\n\ndocs_require = [\n    \"sphinx\",\n    \"breathe\",\n    \"exhale\",\n    \"sphinx-issues\",\n    \"nbsphinx\",\n    \"jupyter_sphinx\",\n    \"threevis\",\n]\ntests_require = [\"pytest\"]\n\nsetup(\n    name=\"pygamer\",\n    version=version,\n    maintainer=\"Christopher T. Lee\",\n    maintainer_email=\"ctlee@ucsd.edu\",\n    author=\"The GAMer Team\",\n    author_email=\"ctlee@ucsd.edu\",\n    url=\"https://github.com/ctlee/gamer\",\n    license=\"LGPLv2+\",\n    packages=[\"pygamer\"],\n    description=DOCLINES[0],\n    long_description=open(\"README.md\", encoding=\"utf8\").read(),\n    long_description_content_type=\"text/markdown\",\n    platforms=[\"Windows\", \"Linux\", \"Mac OS-X\", \"Unix\"],\n    classifiers=[c for c in CLASSIFIERS.split(\"\\n\") if c],\n    keywords=\"meshing \",\n    cmake_args=cmake_args,\n    setup_requires=[\n        \"setuptools\",\n        \"wheel\",\n        \"scikit-build >= 0.10.0\",\n        \"pytest-runner\",\n        \"cmake >= 3.11\",\n    ],\n    install_requires=[\"numpy>=1.8.0\"],\n    extras_require={\n        \"docs\": docs_require,\n        \"test\": tests_require,\n    },\n    zip_safe=False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build>=0.10.0\", \"cmake\", \"ninja\"]",
    "setup.cfg": "[aliases]\ntest=pytest\n\n[tool:pytest]\naddopts = --verbose\npython_files = tests/*\nnorecursedirs = build cmake docs examples include libraries src python .git\n"
  },
  "Jaybro/pico_tree": {
    "setup.py": "#!/usr/bin/env python3\n\nfrom skbuild import setup\n\n\nsetup(name='pico_tree',\n      # The same as the CMake project version.\n      version='0.7.5',\n      description='PicoTree Python Bindings',\n      author='Jonathan Broere',\n      url='https://github.com/Jaybro/pico_tree',\n      license='MIT',\n      packages=['pico_tree'],\n      package_dir={'': 'src/pyco_tree'},\n      cmake_install_dir='src/pyco_tree/pico_tree',\n      python_requires='>=3.7.3',\n      install_requires=['numpy'],\n      )\n"
  },
  "BonexGoo/Boss2D": {
    "Boss2D/addon/pocketsphinx-5.0.0rc4_for_boss/setup.py": "from skbuild import setup\nfrom setuptools import find_packages\n\nsetup(\n    packages=find_packages('cython', exclude=[\"test\"]),\n    package_dir={\"\": \"cython\"},\n    cmake_languages=[\"C\"],\n    install_requires=[\"sounddevice\"],\n)\n",
    "Boss2D/addon/pocketsphinx-5.0.0rc4_for_boss/pyproject.toml": "[build-system]\nrequires = [\n         \"wheel\",\n         \"setuptools>=45\",\n     \t \"scikit-build~=0.15\",\n\t \"Cython\",\n         \"cmake\",\n\t \"ninja\"\n]\nbuild-backend = \"setuptools.build_meta\"\n[tool.cibuildwheel]\n# Build the versions found in Ubuntu LTS, the stable PyPy, and 3.10\n# everywhere else\nbuild = [\n      \"pp38*\",\n      \"cp36-manylinux_*\",\n      \"cp38-manylinux_*\",\n      \"cp310-*\"\n]\n# PyPy 3.8 will choke on CPython 3.8 build leftovers...\nbefore-build = \"rm -rf _skbuild\"\n# PyPy builds are broken on Windows, and skip 32-bit and musl\nskip = [\"*musl*\", \"*_i686\", \"*-win32\", \"pp*win*\"]\n",
    "Boss2D/addon/pocketsphinx-5.0.0rc4_for_boss/setup.cfg": "[metadata]\nname = pocketsphinx\nversion = 5.0.0rc4\ndescription = Official Python bindings for PocketSphinx\nlong_description = file: cython/README.md\nlong_description_content_type = text/markdown\nauthor = David Huggins-Daines\nauthor_email = dhdaines@gmail.com\nlicense = MIT\nplatforms = any\nurl = https://github.com/cmusphinx/pocketsphinx\nproject_urls =\n    Source  = https://github.com/cmusphinx/pocketsphinx\n    Tracker = https://github.com/cmusphinx/pocketsphinx/issues\nkeywords = asr, speech\nclassifiers =\n    Development Status :: 3 - Alpha\n    Programming Language :: C\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.7\n    License :: OSI Approved :: MIT License\n    Operating System :: OS Independent\n[isort]\nprofile=black\n[flake8]\nextend-ignore = E203\nmax-line-length = 88\n"
  },
  "rpm-software-management/libcomps": {
    "setup.py": "import json\n\nfrom skbuild import setup\n\n\nwith open('version.json', 'r+') as version_file:\n    version_dict = json.loads(version_file.read())\n    # build version string\n    version = '{major}.{minor}.{patch}-{release}'.format(\n        major=version_dict['libcomps_VERSION_MAJOR'],\n        minor=version_dict['libcomps_VERSION_MINOR'],\n        patch=version_dict['libcomps_VERSION_PATCH'],\n        release=version_dict['libcomps_RELEASE']\n    )\n\nwith open('README.md') as readme:\n    README = readme.read()\n\nsetup(\n    name='libcomps',\n    description='Comps XML file manipulation library',\n    long_description_content_type='text/markdown',\n    long_description=README,\n    version=version,\n    license='GPLv2+',\n    author='RPM Software Management',\n    author_email='rpm-ecosystem@lists.rpm.org',\n    url='https://github.com/rpm-software-management',\n    classifiers=[\n        'License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)',\n        'Operating System :: POSIX :: Linux',\n        'Programming Language :: C',\n        'Topic :: System :: Software Distribution',\n        'Topic :: System :: Systems Administration',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n    ],\n    packages=['libcomps'],\n    package_dir={\n        'libcomps': 'libcomps/src/python/src/libcomps/'\n    },\n    cmake_args=[\n        '-DBIN_INSTALL_DIR:PATH=libcomps/src/python/src/libcomps/data/bin',\n        '-DBUILD_LIBCOMPS_SHARED:BOOL=OFF',\n        '-DENABLE_DEVELOPMENT:BOOL=OFF',\n        '-DENABLE_DOCS:BOOL=OFF',\n        '-DENABLE_TESTS:BOOL=OFF'\n    ],\n    cmake_languages=['C'],\n    cmake_source_dir=\"libcomps\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "pyswmm/swmm-python": {
    "swmm-toolkit/setup.py": "#\n# setup.py - Setup script for swmm-toolkit python package\n#\n# Created:    Jul 2, 2018\n# Updated:    Jun 7, 2021\n#\n#  Author:    See AUTHORS\n#\n# Suggested Usage:\n#   python setup.py build\n#   python setup.py bdist_wheel\n#   python setup.py sdist\n#   python setup.py clean\n#\n\nimport platform\nimport subprocess\nimport pathlib\n\nfrom skbuild import setup\nfrom setuptools import Command\n\n\n# Determine platform\nplatform_system = platform.system()\n\n\nclass CleanCommand(Command):\n    ''' Cleans project tree '''\n    user_options = []\n\n    def initialize_options(self):\n        pass\n\n    def finalize_options(self):\n        pass\n\n    def run(self):\n        if platform_system == \"Windows\":\n            cmd = ['del' '/Q', 'tests\\\\data\\\\temp_*.*' '&&' \\\n            'rd' '/s/q', '_cmake_test_compile', '_skbuild', 'dist', '.pytest_cache', \\\n            'src\\\\swmm\\\\toolkit\\\\swmm_toolkit.egg-info', 'tests\\\\__pycache__']\n            exe = \"C:\\\\Windows\\\\System32\\\\cmd.exe\"\n\n        elif platform_system == \"Linux\":\n            cmd = [\"rm -vrf _skbuild/ dist/ **/build .pytest_cache/ **/__pycache__  \\\n            **/*.egg-info **/data/temp_*.* **/data/en* **/.DS_Store MANIFEST\"]\n            exe = \"/bin/bash\"\n\n        elif platform_system == \"Darwin\":\n            cmd = ['setopt extended_glob nullglob; rm -vrf _skbuild dist **/build .pytest_cache \\\n            **/__pycache__ **/*.egg-info **/data/(^test_*).* **/data/en* **/.DS_Store MANIFEST']\n            exe = '/bin/zsh'\n\n        p = subprocess.Popen(cmd, shell=True, executable=exe)\n        p.wait()\n\n\n# Set up location of wheel libraries depending on build platform\nif platform_system == \"Windows\":\n    package_dir = {\"swmm_toolkit\":\"bin\", \"swmm.toolkit\": \"src/swmm/toolkit\"}\nelse:\n    package_dir = {\"swmm_toolkit\":\"lib\", \"swmm.toolkit\": \"src/swmm/toolkit\"}\n\n\n# Set Platform specific cmake args here\nif platform_system == \"Windows\":\n    cmake_args = [\"-GVisual Studio 17 2022\",\"-Ax64\"]\n\nelif platform_system == \"Darwin\":\n    cmake_args = [\"-GNinja\",\"-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9\"]\n\nelse:\n    cmake_args = [\"-GUnix Makefiles\"]\n\n\n# Filters cmake manifest for wheel build\ndef exclude_files(cmake_manifest):\n    print(\"INFO: processing cmake manifest\")\n    exclude_pats = ('runswmm', '.exe', '.cmake', '.h', '.lib')\n    return list(filter(lambda name: not (name.endswith(exclude_pats)), cmake_manifest))\n\n\n# Get the long description from the README file\nhere = pathlib.Path(__file__).parent.resolve()\nlong_description = (here / 'README.md').read_text(encoding='utf-8')\n\n\nsetup(\n    name = \"swmm-toolkit\",\n    version = \"0.14.0\",\n\n    packages = [\"swmm_toolkit\", \"swmm.toolkit\"],\n    package_dir = package_dir,\n\n    zip_safe = False,\n    install_requires = [\"aenum==3.1.11\"],\n\n    cmdclass = {\"clean\": CleanCommand},\n    cmake_args = cmake_args,\n    cmake_process_manifest_hook = exclude_files,\n\n    description='OWA SWMM Python Toolkit',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://github.com/OpenWaterAnalytics/swmm-python',\n\n    author='See AUTHORS',\n    maintainer_email='bemcdonnell@gmail.com',\n    license='CC0',\n\n    keywords=\"swmm5, swmm, stormwater, hydraulics, hydrology\",\n    classifiers=[\n        \"Topic :: Scientific/Engineering\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: MacOS\",\n        \"License :: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: C\",\n        \"Development Status :: 5 - Production/Stable\",\n    ]\n)\n"
  },
  "Xilinx/inference-server": {
    "src/amdinfer/bindings/python/setup.py": "# Copyright 2021 Xilinx, Inc.\n# Copyright 2022 Advanced Micro Devices, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nThe setup.py is used for local installation during development. It just installs\nthe *.py files in src/ when invoked by CMake and not skbuild. It relies on CMake\nto copy over the pybind11 library to the site-packages.\n\nTo build a distributable PyPi package, invoke skbuild from the top-level\ndirectory instead e.g.:\n    python3 -m pip wheel /some/dir --wheel-dir /another/dir --no-deps\n\"\"\"\n\nimport os\n\nimport setuptools\n\nversion_path = os.getenv(\"AMDINFER_ROOT\")\nif version_path:\n    version_path += \"/VERSION\"\n    with open(version_path, \"r\") as f:\n        version = f.read()\nelse:\n    version = \"0.0.0\"\n\nsetuptools.setup(\n    name=\"amdinfer\",\n    version=version,\n    license=\"Apache 2.0\",\n    packages=setuptools.find_packages(\"src\"),\n    install_requires=[\n        \"numpy\",\n        \"opencv-python-headless\",\n    ],\n    python_requires=\">=3.6\",\n    package_dir={\"\": \"src\"},\n    package_data={\n        \"\": [\n            \"*.pyi\",\n        ]\n    },\n    zip_safe=False,  # required for mypy\n)\n",
    "setup.py": "# Copyright 2021 Xilinx, Inc.\n# Copyright 2022 Advanced Micro Devices, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nfrom pathlib import Path\n\nimport setuptools\nimport skbuild\n\nversion = Path(\"VERSION\").read_text(\"utf-8\")\nreadme = Path(\"README.rst\").read_text(\"utf-8\")\npackage = Path(\"src/amdinfer/bindings/python/src\")\n\n# add the following to the README for the description page on PyPI\npypi_description = \"\"\"\\\n\nIMPORTANT NOTICE CONCERNING OPEN-SOURCE SOFTWARE\n\nMaterials in this release may be licensed by Xilinx or third parties and may\nbe subject to the GNU General Public License, the GNU Lesser General License,\nor other licenses.\n\nLicenses and source files may be downloaded from:\n\n* `libamdinfer <https://github.com/Xilinx/inference-server>`__\n* `libbrotlicommon <https://rhel.pkgs.org/7/epel-x86_64/libbrotli-1.0.9-10.el7.x86_64.rpm.html>`__\n* `libbrotlidec <https://rhel.pkgs.org/7/epel-x86_64/libbrotli-1.0.9-10.el7.x86_64.rpm.html>`__\n* `libbrotlienc <https://rhel.pkgs.org/7/epel-x86_64/libbrotli-1.0.9-10.el7.x86_64.rpm.html>`__\n* `libcares <https://github.com/c-ares/c-ares/archive/refs/tags/cares-1_14_0.tar.gz>`__\n* `libcom_err <https://centos.pkgs.org/7/centos-x86_64/libcom_err-1.42.9-19.el7.x86_64.rpm.html>`__\n* `libcrypto <https://centos.pkgs.org/7/centos-x86_64/openssl-devel-1.0.2k-19.el7.x86_64.rpm.html>`__\n* `libdrogon <https://github.com/drogonframework/drogon/tree/v1.8.1>`__\n* `libefsw <https://github.com/SpartanJ/efsw/tree/6b51944994b5c77dbd7edce66846e378a3bf4d8e>`__\n* `libgssapi_krb5 <https://centos.pkgs.org/7/centos-x86_64/krb5-libs-1.15.1-50.el7.x86_64.rpm.html>`__\n* `libjsoncpp <https://github.com/open-source-parsers/jsoncpp/tree/1.7.4>`__\n* `libk5crypto <https://centos.pkgs.org/7/centos-x86_64/krb5-libs-1.15.1-50.el7.x86_64.rpm.html>`__\n* `libkeyutils <https://centos.pkgs.org/7/centos-x86_64/keyutils-1.5.8-3.el7.x86_64.rpm.html>`__\n* `libkrb5 <https://centos.pkgs.org/7/centos-x86_64/krb5-devel-1.15.1-50.el7.x86_64.rpm.html>`__\n* `libkrb5support <https://centos.pkgs.org/7/centos-x86_64/krb5-devel-1.15.1-50.el7.x86_64.rpm.html>`__\n* `libopencv_core <https://github.com/opencv/opencv/tree/3.4.3>`__\n* `libopencv_imgcodecs <https://github.com/opencv/opencv/tree/3.4.3>`__\n* `libopencv_imgproc <https://github.com/opencv/opencv/tree/3.4.3>`__\n* `libossp-uuid <https://centos.pkgs.org/7/centos-x86_64/uuid-devel-1.6.2-26.el7.x86_64.rpm.html>`__\n* `libpcre <https://centos.pkgs.org/7/centos-x86_64/pcre-8.32-17.el7.x86_64.rpm.html>`__\n* `libprometheus-cpp-core <https://github.com/jupp0r/prometheus-cpp/archive/refs/tags/v0.12.2.tar.gz>`__\n* `libprotobuf <https://github.com/protocolbuffers/protobuf/releases/download/v3.19.4/protobuf-cpp-3.19.4.tar.gz>`__\n* `libselinux <https://centos.pkgs.org/7/centos-x86_64/libselinux-2.5-15.el7.x86_64.rpm.html>`__\n* `libssl <https://centos.pkgs.org/7/centos-x86_64/openssl-devel-1.0.2k-19.el7.x86_64.rpm.html>`__\n* `libtrantor <https://github.com/drogonframework/drogon/tree/v1.8.1>`__\n\nNote:  You are solely responsible for checking the header files and other\naccompanying source files (i) provided within, in support of, or that otherwise\naccompanies these materials or (ii) created from the use of third party\nsoftware and tools (and associated libraries and utilities) that are supplied\nwith these materials, because such header and/or source files may contain\nor describe various copyright notices and license terms and conditions\ngoverning such files, which vary from case to case based on your usage\nand are beyond the control of Xilinx. You are solely responsible for\ncomplying with the terms and conditions imposed by third parties as applicable\nto your software applications created from the use of third\nparty software and tools (and associated libraries and utilities) that are\nsupplied with the materials.\n\"\"\"\n\nlong_description = readme + pypi_description\n\nskbuild.setup(\n    name=\"amdinfer\",\n    version=version,\n    description=\"Python client library for the AMD Inference Server: unified inference across AMD CPUs, GPUs, and FPGAs\",\n    long_description=long_description,\n    long_description_content_type=\"text/x-rst\",\n    license=\"Apache 2.0\",\n    author=\"Varun Sharma\",\n    author_email=\"varun.sharma@amd.com\",\n    url=\"https://github.com/Xilinx/inference-server\",\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/Xilinx/inference-server/issues\",\n        \"Changelog\": \"https://xilinx.github.io/inference-server/main/changelog.html\",\n        \"Documentation\": \"https://xilinx.github.io/inference-server/main/index.html\",\n        \"Source Code\": \"https://github.com/Xilinx/inference-server\",\n    },\n    packages=setuptools.find_packages(str(package)),\n    install_requires=[\n        \"numpy\",\n        \"opencv-python-headless\",\n    ],\n    python_requires=\">=3.6\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        # \"Environment :: Console\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Natural Language :: English\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n        \"Topic :: Scientific/Engineering :: Image Processing\",\n        \"Topic :: Scientific/Engineering :: Image Recognition\",\n        # \"Typing :: Typed\",\n    ],\n    package_dir={\"\": str(package)},\n    include_package_data=True,\n    cmake_install_dir=str(package / \"amdinfer\"),\n    package_data={\n        \"\": [\n            \"*.pyi\",\n        ]\n    },\n    zip_safe=False,  # required for mypy\n)\n",
    "pyproject.toml": "# Copyright 2021 Xilinx, Inc.\n# Copyright 2022 Advanced Micro Devices, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nrequires = [\n    \"ninja; platform_system!='Windows'\",\n    \"scikit-build>=0.15.0\",\n    \"setuptools\",\n    \"wheel\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild = [\"*-manylinux_x86_64\"]\n# there's some issues with Python 11 and numpy\nskip = [\"pp*\", \"cp311-manylinux_x86_64\"]\nenvironment = { AMDINFER_ROOT= \"/project\" }\n\n[tool.cibuildwheel.linux]\nrepair-wheel-command = [\n    \"export LD_LIBRARY_PATH=$(cat /project/tmp.cmake):$LD_LIBRARY_PATH\",\n    \"auditwheel repair -w {dest_dir} {wheel}\"\n]\n\n[tool.isort]\nknown_first_party = [\"amdinfer\"]\nknown_local_folder=[\"helper\", \"utils\", \"fixtures\"]\n"
  },
  "maxbachmann/JaroWinkler": {
    "setup.py": "import os\n\ndef show_message(*lines):\n    print(\"=\" * 74)\n    for line in lines:\n        print(line)\n    print(\"=\" * 74)\n\nwith open('README.md', 'rt', encoding=\"utf8\") as f:\n    readme = f.read()\n\nsetup_args = {\n    \"name\": \"jarowinkler\",\n    \"version\": \"1.2.3\",\n    \"url\": \"https://github.com/maxbachmann/JaroWinkler\",\n    \"author\": \"Max Bachmann\",\n    \"author_email\": \"pypi@maxbachmann.de\",\n    \"description\": \"library for fast approximate string matching using Jaro and Jaro-Winkler similarity\",\n    \"long_description\": readme,\n    \"long_description_content_type\": \"text/markdown\",\n\n    \"license\": \"MIT\",\n    \"classifiers\": [\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"License :: OSI Approved :: MIT License\"\n    ],\n\n    \"packages\": [\"jarowinkler\"],\n    \"package_dir\": {'': 'src'},\n    \"package_data\": {\"jarowinkler\": [\"*.pyi\", \"py.typed\"]},\n    \"python_requires\": \">=3.6\"\n}\n\ndef run_setup(with_binary):\n    if with_binary:\n        from skbuild import setup\n        import rapidfuzz_capi\n\n        setup(\n            **setup_args,\n            cmake_args=[\n                f'-DRF_CAPI_PATH:STRING={rapidfuzz_capi.get_include()}'\n            ]\n        )\n    else:\n        from setuptools import setup\n        setup(**setup_args)\n\n# when packaging only build wheels which include the C extension\npackaging = \"1\" in {\n    os.environ.get(\"CIBUILDWHEEL\", \"0\"),\n    os.environ.get(\"CONDA_BUILD\", \"0\"),\n    os.environ.get(\"JAROWINKLER_BUILD_EXTENSION\", \"0\")\n}\nif packaging:\n    run_setup(True)\nelse:\n    try:\n        run_setup(True)\n    except:\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Failure information, if any, is above.\",\n            \"Retrying the build without the C extension now.\",\n        )\n        run_setup(False)\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Plain-Python build succeeded.\",\n        )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build==0.15.0\",\n    \"Cython==3.0.0a11\",\n    \"rapidfuzz_capi==1.0.5\"\n]\nbuild-backend = \"backend\"\nbackend-path = [\"_custom_build\"]\n"
  },
  "qnzhou/MshIO": {
    "setup.py": "import sys, re, os\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n        \"install .'. If you wish to run the setup script directly, you must \"\n        \"first install the build dependencies listed in pyproject.toml!\",\n        file=sys.stderr,\n    )\n    raise\n\nsetup(\n    name=\"mshio\",\n    version=\"0.0.1\",\n    author=\"Qingnan Zhou\",\n    author_email=\"qnzhou@adobe.com\",\n    description=\"A tiny C++ library to read/write ASCII/binary MSH format files.\",\n    url=\"https://github.com/qnzhou/MshIO\",\n    license=\"Apache-2.0\",\n    packages=[\"mshio\"],\n    package_dir={\"\": \"python\"},\n    cmake_install_dir=\"python/mshio\",\n    include_package_data=True,\n    cmake_args=[\n        \"-DCMAKE_BUILD_TYPE=Release\",\n        \"-DMSHIO_BUILD_TESTS=Off\",\n        \"-DMSHIO_BUILD_EXAMPLES=Off\",\n        \"-DMSHIO_EXT_NANOSPLINE=Off\",\n        \"-DMSHIO_PYTHON=On\",\n    ],\n    python_requires=\">=3.8\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build==0.14.0\",\n    \"cmake>=3.17\",\n    \"ninja; platform_system!='Windows'\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "OPM/opm-common": {
    "python/setup.py.in": "from skbuild import setup\n\nimport os\n\nsetupdir = os.path.dirname(__file__)\nif setupdir != '':\n  os.chdir( setupdir )\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name='opm',\n    version = '@opm-common_VERSION@' + '@opm-common_PYTHON_PACKAGE_VERSION@',\n    url='http://www.opm-project.org',\n    author='The Open Porous Media Project',\n    author_email='opmuser@gmail.com',\n    description='OPM-Common Python bindings',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    packages=[\n                'opm',\n                'opm.io',\n                'opm.io.deck',\n                'opm.io.ecl_state',\n                'opm.io.parser',\n                'opm.io.schedule',\n                'opm.io.ecl',\n                'opm.tools',\n                'opm.util'\n            ],\n    package_data={'opm' : ['$<TARGET_FILE_NAME:opmcommon_python>']},\n    include_package_data=True,\n    license='Open Source',\n    test_suite='tests',\n    setup_requires=[\"pytest-runner\", 'setuptools_scm'],\n    python_requires='>=3.6',\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n    ],\n)\n",
    "python/pyproject.toml": "[build-system]\nrequires= [\n  \"setuptools>=42\",\n  \"scikit-build>=0.13\",\n  \"cmake>=3.15\",\n  \"ninja\"\n]\n"
  },
  "severinstrobl/overlap": {
    "setup.py": "from skbuild import setup, exceptions, cmaker\nfrom packaging.version import LegacyVersion\n\n# Add CMake as a build requirement if no or only an outdated version is\n# available.\nsetup_requires = []\ntry:\n    if LegacyVersion(cmaker.get_cmake_version()) < LegacyVersion('3.10'):\n        setup_requires.append('cmake')\nexcept exceptions.SKBuildError:\n    setup_requires.append('cmake')\n\nwith open('README.md', 'r', encoding='utf-8') as fh:\n    long_description = fh.read()\n\nsetup(\n    name='overlap',\n    version='0.0.5',\n    author='Severin Strobl',\n    author_email='git@severin-strobl.de',\n    description='Exact calculation of the overlap volume and area of spheres '\n                'and mesh elements',\n    url='https://github.com/severinstrobl/overlap',\n    license='GPLv3',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    packages=['overlap'],\n    package_dir={'overlap': 'python'},\n    setup_requires=setup_requires,\n    install_requires=[\n        'numpy'\n    ],\n    cmake_install_dir='python',\n    classifiers=[\n        'Programming Language :: Python :: 3',\n        'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)',\n        'Topic :: Scientific/Engineering'\n    ]\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"scikit-build>=0.8.0\",\n    \"setuptools>=42\",\n    \"wheel\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\ntestpaths = [\n    \"test\",\n]"
  },
  "PySCeS/pysces": {
    "setup.py": "#!/usr/bin/env python\n\n\"\"\"\nPySCeS - Python Simulator for Cellular Systems (http://pysces.sourceforge.net)\n\nCopyright (C) 2004-2023 B.G. Olivier, J.M. Rohwer, J.-H.S Hofmeyr all rights reserved,\n\nBrett G. Olivier (bgoli@users.sourceforge.net)\nTriple-J Group for Molecular Cell Physiology\nStellenbosch University, South Africa\n\nPermission to use, modify, and distribute this software is given under the\nterms of the PySceS (BSD style) license.  See LICENSE.txt that came with\nthis distribution for specifics.\n\nNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.\nBrett G. Olivier\n\"\"\"\nfrom __future__ import division, print_function\nfrom __future__ import absolute_import\n\n__doc__ = \"PySCeS: the Python Simulator for Cellular Systems setup file\"\n\n# get __version__ from version.txt\nwith open('pysces/version.txt') as f:\n    __version__ = f.read().strip()\n\n# avoid duplication\nwith open('requirements.txt') as f:\n    requirements = f.read().splitlines()\n\nimport os, re\n\ntry:\n    import configparser  # Py 3\nexcept ImportError:\n    import ConfigParser as configparser  # Py 2\n\ntry:\n    print('Building an egg? %s.' % FRYING_EGGS)\nexcept:\n    FRYING_EGGS = False\n\ntry:\n    import setuptools\n\n    print('setuptools is available.')\nexcept Exception as ex:\n    print('setuptools not available.')\n\ntry:\n    from skbuild import setup\nexcept Exception as ex:\n    print(ex)\n    print(\"PySCeS requires scikit-build to build.\\n\")\n    os.sys.exit(-1)\n\ntry:\n    import distutils.command.bdist_conda\n    print('bdist_conda is available.')\nexcept Exception as ex:\n    print('bdist_conda not available.')\n\n\n########## User configuration section ##########\n\n# Install extension modules (zero for skip module) - brett 20040310\npitcon = 1\n\n##Special licence libraries see the relevant readme.txt file for details\nnleq2 = 1  # pysces/nleq2/readme.txt\n\nuse = re.split('\\s+', os.getenv('PYSCES_USE', ''))\nfor e in use:\n    if e == 'pitcon':\n        pitcon = 1\n    elif e == 'nopitcon':\n        pitcon = 0\n    elif e == 'nleq2':\n        nleq2 = 1\n    elif e == 'nonleq2':\n        nleq2 = 0\n'''\n# this is now obsolete with nleq2 4.3\n    elif e.startswith('nleq2_byteorder='):\n        nleq2_byteorder_override = int(e[16:])\n# detects and uses IEEE fp big/little endian\n'''\n### End user configuration section\n\n########## From here on it's up to scikit-build ##########\n\n# get the dir of setup.py\nlocal_path = os.path.dirname(os.path.abspath(__file__))\nos.chdir(local_path)\n\nmypackage_data = {}\n\n# add some model files into pscmodels\nmypackage_data['pysces.pscmodels'] = ['*.psc']\n\n# Default configurations for the pyscfg.ini files\nif os.sys.platform == 'win32':\n    if FRYING_EGGS:\n        eggdir = 'pysces-%s-py%s.%s-%s.egg' % (\n            __version__,\n            os.sys.version_info[0],\n            os.sys.version_info[1],\n            os.sys.platform,\n        )\n        installdir = os.path.join(\n            os.sys.prefix, 'lib', 'site-packages', eggdir, 'pysces'\n        )\n    else:\n        installdir = os.path.join(os.sys.prefix, 'lib', 'site-packages', 'pysces')\n    config = {\n        \"install_dir\": installdir,\n        \"model_dir\": os.path.join(os.getenv('USERPROFILE'), 'Pysces', 'psc'),\n        \"output_dir\": os.path.join(os.getenv('USERPROFILE'), 'Pysces'),\n        \"gnuplot_dir\": None,\n        \"silentstart\": False,\n        \"change_dir_on_start\": False,\n    }\nelse:\n    if hasattr(os.sys, 'lib'):\n        lib = os.sys.lib\n    else:\n        lib = 'lib'\n    config = {\n        \"install_dir\": os.path.join(\n            os.sys.prefix,\n            lib,\n            \"python%d.%d\" % tuple(os.sys.version_info[:2]),\n            'site-packages',\n            'pysces',\n        ),\n        \"model_dir\": os.path.join(os.path.expanduser('~'), 'Pysces', 'psc'),\n        \"output_dir\": os.path.join(os.path.expanduser('~'), 'Pysces'),\n        \"gnuplot_dir\": None,\n        \"silentstart\": False,\n        \"change_dir_on_start\": False,\n    }\n\n\ndef writeConfig(local_path, config={}):\n    cfgfile = open(os.path.join(local_path, 'pysces', 'pyscfg.ini'), 'w')\n    cp = configparser.ConfigParser()\n    # PySCeS internal setup\n    cp.add_section('Pysces')\n    for key in config:\n        print(repr(key) + ' :: ' + str(config[key]))\n        cp.set('Pysces', key, str(config[key]))\n    # add configuration data\n    cp.add_section('PyscesConfig')\n    cp.set('PyscesConfig', 'matplotlib', 'True')\n    # OSX patch thanks to AF\n    if os.sys.platform == 'darwin':\n        cp.set('PyscesConfig', 'matplotlib_backend', 'MacOSX')\n    else:\n        cp.set('PyscesConfig', 'matplotlib_backend', 'TkAgg')\n    cp.set('PyscesConfig', 'gnuplot', 'False')\n    # Built in modules\n    cp.add_section('PyscesModules')\n    if pitcon:\n        cp.set('PyscesModules', 'pitcon', 'True')\n    else:\n        cp.set('PyscesModules', 'pitcon', 'False')\n    # PySCeS external module setup\n    cp.add_section('ExternalModules')\n    if nleq2:\n        cp.set('ExternalModules', 'nleq2', 'True')\n    else:\n        cp.set('ExternalModules', 'nleq2', 'False')\n    cp.write(cfgfile)\n    cfgfile.close()\n\nwriteConfig(local_path, config)\nprint('Default configuration file installed')\n\n# my subpackage list\nmypackages = [\n    'pysces',\n    'pysces.tests',\n    'pysces.examples',\n    'pysces.pscmodels',\n    'pysces.docs',\n    'pysces.lib',\n    'pysces.sandbox',\n    'pysces.contrib',\n    'pysces.contrib.demo',\n    'pysces.core2',\n    'pysces.kraken',\n    'pysces.kraken.controllers',\n]\n\nif pitcon:\n    print('\\nBuilding pitcon')\n    mypackages.append('pysces.pitcon')\nelse:\n    print('\\nSkipping pitcon')\n\n\nif nleq2:\n    print('\\nBuilding nleq2')\n    mypackages.append('pysces.nleq2')\nelse:\n    print('\\nSkipping nleq2')\nmypackage_data['pysces.nleq2'] = ['nleq2_readme.txt', 'readme.txt']\n\n# Data files to copy\nmypackage_data['pysces'] = ['pyscfg.ini', 'version.txt']\nmypackage_data['pysces.docs'] = ['userguide.pdf']\nmypackage_data['pysces.examples'] = ['*.ipy']\n\nos.chdir(local_path)\n\nsetup(\n    name=\"pysces\",\n    version=__version__,\n    description=\"The Python Simulator for Cellular Systems - simulation and analysis tools for modelling biological systems\",\n    long_description=\"\"\"\n PySCeS is developed by the Triple-J Group for Molecular Cell Physiology\n in order to try model and understand the complex processes and systems\n which make up the living cell.\n\n    PySCeS features, amongst other things:\n    - A text based model description language.\n    - A structural analysis module.\n    - Integrators for time simulation\n    - Non-linear solvers for steady-state analysis\n    - A module for performing Metabolic Control Analysis\n    - A bifurcation module for systems which exhibit multiple steady states\n    - A variety of extra utilites for parameter scans, data output and plotting.\n    - A dynamic module loading framework.\n    - SBML import and export capability.\n    \"\"\",\n    author=\"Brett G. Olivier and Johann M. Rohwer\",\n    author_email=\"pysces@googlegroups.com\",\n    maintainer=\"Brett G. Olivier and Johann M. Rohwer\",\n    maintainer_email=\"pysces@googlegroups.com\",\n    url=\"http://pysces.sourceforge.net\",\n    download_url=\"https://pypi.org/project/pysces/#files\",\n    license=\"New BSD style\",\n    keywords=\"computational systems biology, modelling, simulation, systems biology\",\n    zip_safe=False,\n    install_requires=requirements,\n    extras_require={\n        'parscan': ['ipyparallel'],\n        'cvode': ['assimulo'],\n        'sbml': ['python_libsbml'],\n        'all': ['ipyparallel', 'assimulo', 'python_libsbml'],\n    },\n    platforms=[\"Windows\", \"POSIX\", \"Max OSX\"],\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Development Status :: 6 - Mature',\n        'Environment :: Console',\n        'Intended Audience :: End Users/Desktop',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: BSD License',\n        'Natural Language :: English',\n        'Operating System :: OS Independent',\n        'Programming Language :: Fortran',\n        'Programming Language :: Python',\n        'Topic :: Scientific/Engineering :: Bio-Informatics',\n        'Topic :: Scientific/Engineering :: Chemistry',\n    ],\n    packages=mypackages,\n    package_data=mypackage_data,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \n\t\"wheel\", \n\t\"scikit-build\", \n\t\"cmake\", \n\t\"ninja; platform_system!='Windows'\",\n\t\"numpy~=1.21.0; python_version<'3.11'\",\n    \"oldest-supported-numpy; python_version>='3.11'\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "kul-optec/alpaqa": {
    "setup.py": "import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\n\nimport os \ndir_path = os.path.dirname(os.path.realpath(__file__))\n\nwith open(os.path.join(dir_path, \"README.md\"), \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nversion = \"0.0.1\"\n\nsetup(\n    name=\"alpaqa\",\n    version=version,\n    description=\"Augmented Lagrangian and PANOC solvers for nonconvex numerical optimization\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Pieter P\",\n    author_email=\"\",\n    url=\"https://github.com/kul-optec/alpaqa\",\n    project_urls={\n        \"Documentation\": \"https://kul-optec.github.io/alpaqa\",\n        \"Source\": \"https://github.com/kul-optec/alpaqa\",\n        \"Bug Tracker\": \"https://github.com/kul-optec/alpaqa/issues\",\n    },\n    keywords=[\"optimization\"],\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_args=[\"-D\", \"VERIFY_VERSION=\" + version],\n    cmake_install_dir=\"src/alpaqa\",\n    include_package_data=False,\n    install_requires=[\n        \"numpy\",\n        \"casadi\",\n        \"ninja\",\n        \"cmake\",\n    ],\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: Microsoft :: Windows\",\n    ],\n    python_requires=\">=3.7\",\n)",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"pybind11~=2.7.1\",\n    \"ninja\",\n    \"cmake\",\n    \"scikit-build\",\n    \"mypy\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "valgur/velodyne_decoder": {
    "setup.py": "import sys\n\ntry:\n    from setuptools import find_packages\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n        \"install .'. If you wish to run the setup script directly, you must \"\n        \"first install the build dependencies listed in pyproject.toml!\",\n        file=sys.stderr,\n    )\n    raise\n\nsetup(\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/velodyne_decoder\",\n)\n",
    "pyproject.toml": "[project]\nname = \"velodyne-decoder\"\nversion = \"3.0.0\"\ndescription = \"Decoder for raw Velodyne packet data\"\nreadme = \"README.md\"\nrequires-python = \">= 3.7\"\nauthors = [{name = \"Martin Valgur\", email = \"martin.valgur@gmail.com\"}]\nurls.\"Homepage\" = \"https://github.com/valgur/velodyne_decoder\"\nurls.\"Bug Reports\" = \"https://github.com/valgur/velodyne_decoder/issues\"\nurls.\"Source\" = \"https://github.com/valgur/velodyne_decoder\"\nkeywords = [\n    \"Velodyne\",\n    \"pointcloud\",\n    \"PCL\",\n]\nlicense = {file = \"LICENSE\"}\nclassifiers = [\n    \"License :: OSI Approved :: BSD License\",\n    \"Programming Language :: Python :: 2\",\n    \"Programming Language :: Python :: 3\",\n    \"Operating System :: OS Independent\",\n]\ndependencies = [\n    \"numpy\",\n    \"importlib_resources\",\n    \"dpkt\",\n]\ndynamic = [\"optional-dependencies\"]\n\n[tool.setuptools.dynamic]\noptional-dependencies.tests = { file = [\"requirements-dev.txt\"] }\n\n[project.scripts]\nextract-hdl64e-calibration = \"velodyne_decoder.hdl64e:cli\"\n\n[tool.setuptools]\nzip-safe = false\ninclude-package-data = true\n\n[build-system]\nrequires = [\n    \"setuptools >= 42\",\n    \"wheel\",\n    \"scikit-build >= 0.16.7\",\n    \"cmake >= 3.24\",\n    \"ninja\",\n    \"conan >= 2\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild = \"*\"\n# Disable building of PyPy wheels on all platforms\nskip = \"pp*\"\nbefore-test = \"pip install -r {project}/requirements-dev.txt --extra-index-url https://rospypi.github.io/simple/\"\ntest-command = \"pytest {project}/test --color=yes -v\"\nbuild-verbosity = 1\narchs = \"auto64\"\n"
  },
  "dune-project/dune-common": {
    "python/setup.py.in": "# SPDX-FileCopyrightInfo: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\nfrom setuptools import setup, find_namespace_packages\n\npkg = '${RequiredPythonModules}'.replace(';',' ').split(' ')\n\n# convert cmake bool to python bool\ndef cmake_to_bool(str):\n  if str in ['1', 'ON', 'YES', 'TRUE', 'Y']:\n    return True\n  else:\n    return False\n\n# if MPI is found dune-common will be linked to MPI\n# in that case we require mpi4py for MPI support from the Python side\n# This will not install mpi4py when installing in build-isolation but\n# will install it into the (internal) venv during a source build.\n# The case of a package installation is taken care of in\n# `python/dune/common/__init__.py'.\nif cmake_to_bool(\"${HAVE_MPI}\") and not cmake_to_bool(\"${SKBUILD}\"):\n  pkg += ['mpi4py']\n\nsetup(name=\"${ProjectName}\",\n    # only add 'dune' here in dune-common other packages shouldn't add file # directly to 'dune'\n    packages=find_namespace_packages(include=['dune','dune.*']),\n    description=\"${ProjectDescription}\",\n    version=\"${ProjectVersionString}\",\n    author=\"${ProjectAuthor}\",\n    author_email=\"${ProjectMaintainerEmail}\",\n    zip_safe = 0,\n    package_data = {'': ['*.so']},\n    install_requires = pkg,\n    include_package_data=True,\n  )\n",
    "setup.py": "# SPDX-FileCopyrightInfo: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\n#\n# DO NOT MODIFY THIS FILE!\n# This file is autogenerated by the `dunepackaging.py` script and\n# only used for the pypi dune packages. This file will not be included in\n# the build directory.\n#\nimport os, sys\nhere = os.path.dirname(os.path.abspath(__file__))\nmods = os.path.join(here, \"python\", \"dune\")\nsys.path.append(mods)\n\ntry:\n    from dune.packagemetadata import metaData\nexcept ImportError:\n    from packagemetadata import metaData\nfrom skbuild import setup\nsetup(**metaData()[1])\n",
    "pyproject.toml": "# SPDX-FileCopyrightInfo: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\n#\n# DO NOT MODIFY THIS FILE!\n# This file is autogenerated by the `dunepackaging.py` script and\n# only used for the pypi dune packages. This file will not be included in\n# the build directory.\n#\n# This is uses the `Python-Requires` field in the `dune.modules` file to\n# populate the `requires` entry. Additional packages needed for the package\n# build should be added in the `dune.modules`. These packages will then also be\n# included in the package install from source.\n#\n[build-system]\nrequires = ['cmake>=3.13', 'jinja2', 'ninja', 'numpy', 'pip>=21.a', 'portalocker', 'requests', 'scikit-build', 'setuptools>=41', 'wheel']\nbuild-backend = 'setuptools.build_meta'\n"
  },
  "mhm-ufz/mHM": {
    "setup.py": "\"\"\"Python bindings for mHM.\"\"\"\nimport os\nimport shutil\nimport tarfile\nimport tempfile\nfrom pathlib import Path\nfrom urllib.request import urlretrieve\n\nimport setuptools\nimport skbuild\n\nFORCES_URL = \"https://git.ufz.de/chs/forces/-/archive/{branch}/forces-{branch}.tar.gz\"\n\n\ndef _download_tar(url, path):\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        tar_file = Path(tmp_dir) / \"temp.tar.gz\"\n        tar_dir = Path(tmp_dir) / \"temp\"\n        urlretrieve(url, tar_file)\n        with tarfile.open(tar_file, \"r:gz\") as tar:\n            tar.extractall(path=tar_dir)\n        # move sub-folder content to desired path\n        first_sub = tar_dir / os.listdir(tar_dir)[0]\n        shutil.copytree(first_sub, path, ignore_dangling_symlinks=True)\n\n\nclass sdist(setuptools.command.sdist.sdist):\n    \"\"\"Custom sdist command to include FORCES in source distribution.\"\"\"\n\n    def run(self):\n        print(\"## mHM Python setup: adding FORCES to sdist\")\n        here = Path(__file__).parent\n        ver_file = here / \"version_forces.txt\"\n        forces_dir = here / \"forces\"\n        forces_ver = ver_file.read_text().strip()\n        forces_url = FORCES_URL.format(branch=forces_ver)\n        # remove potentially existing dir\n        shutil.rmtree(forces_dir, ignore_errors=True)\n        # download forces\n        _download_tar(url=forces_url, path=forces_dir)\n        # run sdist\n        super().run()\n        # remove forces dir again\n        shutil.rmtree(forces_dir)\n\n\n# maybe overwrite the default version\nmhm_build_type = os.getenv(\"MHM_BUILD_TYPE\", \"Release\")\nforces_path = os.getenv(\"MHM_BUILD_FORCES_PATH\", \"\")\n# init cmake args\ncmake_args = [\n    f\"-DCMAKE_BUILD_TYPE={mhm_build_type}\",\n    \"-DBUILD_MHM_PYBIND=ON\",\n]\n\nprint(f\"## mHM Python setup: build-type '{mhm_build_type}'\")\n\n# you can set MHM_BUILD_PARALLEL=0 or MHM_BUILD_PARALLEL=1\nif int(os.getenv(\"MHM_BUILD_PARALLEL\", \"0\")):\n    cmake_args += [\"-DCMAKE_WITH_OpenMP=ON\"]\n    print(\"## mHM Python setup: OpenMP used by env-var.\")\n\nif forces_path:\n    cmake_args += [f\"-DCPM_forces_SOURCE={forces_path}\"]\n    print(f\"## mHM Python setup: using forces path '{forces_path}'\")\n\nentry_points = {\"console_scripts\": [\"mhm-download = mhm.download:cli\"]}\n# env var to control the installation of a console script for mHM\nif int(os.getenv(\"MHM_BUILD_PY_SCRIPT\", \"1\")):\n    entry_points[\"console_scripts\"].append(\"mhm = mhm.cli:mhm\")\n    cmake_args += [\"-DBUILD_MHM_DRIVER=ON\"]\n    print(\"## mHM Python setup: creating console script for mHM driver\")\nelse:\n    cmake_args += [\"-DBUILD_MHM_DRIVER=OFF\"]\n    print(\"## mHM Python setup: no console script for mHM driver\")\n\nskbuild.setup(\n    packages=[\"mhm\"],\n    package_dir={\"\": \"pybind\"},\n    cmake_install_dir=\"pybind/mhm\",\n    cmake_args=cmake_args,\n    zip_safe=False,\n    entry_points=entry_points,\n    cmdclass={\"sdist\": sdist},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=63,<64\",\n    \"setuptools_scm[toml]>=7,<8\",\n    \"scikit-build>=0.16,<0.17\",\n    \"oldest_supported_numpy\",\n    \"cmake\",\n    \"ninja\",\n    \"fypp\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nrequires-python = \">=3.8\"\nname = \"mhm\"\ndescription = \"Python distribution of mHM with bindings.\"\nauthors = [{name = \"mHM Developers\", email = \"mhm-admin@ufz.de\"}]\nreadme = \"pybind/README.md\"\nlicense = {text = \"LGPL-3.0\"}\ndynamic = [\"version\", \"entry-points\"]\nkeywords = [\"mHM\"]\nclassifiers = [\n    \"Development Status :: 3 - Alpha\",\n    \"Intended Audience :: Developers\",\n    \"Intended Audience :: End Users/Desktop\",\n    \"Intended Audience :: Science/Research\",\n    \"Intended Audience :: Education\",\n    \"License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)\",\n    \"Natural Language :: English\",\n    \"Operating System :: Unix\",\n    \"Operating System :: MacOS\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3 :: Only\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Topic :: Scientific/Engineering\",\n    \"Topic :: Scientific/Engineering :: Hydrology\",\n    \"Topic :: Scientific/Engineering :: Mathematics\",\n    \"Topic :: Scientific/Engineering :: Physics\",\n    \"Topic :: Utilities\",\n]\ndependencies = [\"numpy>=1.17.3\"]\n\n[project.urls]\nChangelog = \"https://www.mhm-ufz.org\"\nConda-Forge = \"https://anaconda.org/conda-forge/mhm\"\nDocumentation = \"https://www.mhm-ufz.org\"\nHomepage = \"https://www.mhm-ufz.org\"\nSource = \"https://www.mhm-ufz.org\"\nTracker = \"https://www.mhm-ufz.org\"\n\n# https://github.com/pypa/setuptools/issues/3599\n[tool.setuptools]\nlicense-files = [\"COPYING\", \"COPYING.LESSER\", \"LICENSE.md\", \"AUTHORS\"]\n\n[tool.setuptools_scm]\nwrite_to = \"pybind/mhm/_version.py\"\nwrite_to_template = \"__version__ = '{version}'\"\nlocal_scheme = \"no-local-version\"\nfallback_version = \"0.0.0.dev0\"\nsearch_parent_directories = true\n\n[tool.black]\nexclude = \"_version.py\"\ntarget-version = [\"py38\"]\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\nknown_first_party = [\"mhm\"]\n\n[tool.cibuildwheel]\n# Super-verbose output for debugging purpose\nbuild-verbosity = 3\n# skip py37, pypy and musl\nskip = [\"cp37*\", \"pp*\", \"*-musllinux_*\"]\n# check command\ntest-command = \"mhm -h && mhm {project}\"\n\n[tool.cibuildwheel.linux]\nenvironment = { FC=\"gfortran\", F77=\"gfortran\", CC=\"gcc\", CXX=\"g++\" }\nbefore-all = \"source CI-scripts/install-deps -c -p /usr\"\n\n[tool.cibuildwheel.macos]\nenvironment = { FC=\"gfortran-11\", F77=\"gfortran-11\", CC=\"gcc-11\", CXX=\"g++-11\" }\nbefore-all = \"source CI-scripts/install-deps -s -p /opt/local\"\n"
  },
  "pyre/pyre": {
    "setup.py": "#! /usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# michael a.g. a\u00efv\u00e1zis <michael.aivazis@para-sim.com>\n# (c) 1998-2023 all rights reserved\n\n# external\nimport pybind11\nimport skbuild\nimport sys\n\n# get the python version\nmajor, minor, *_ = sys.version_info\n# tell cmake where to install pyre packages\npackageDir = f\"lib/python{major}.{minor}/site-packages\"\n\n# invoke\nskbuild.setup(\n    # for cmake\n    cmake_args=[\n        # pybind11\n        f\"-Dpybind11_DIR={pybind11.get_cmake_dir()}\",\n        # pyre version, in case the build happens outside the git repo\n        f\"-DPYRE_VERSION=1.12.0\",\n        # put packages in {site-packages}\n        f\"-DPYRE_DEST_PACKAGES={packageDir}\",\n    ]\n)\n\n# end of file\n",
    "pyproject.toml": "# -*- toml -*-\n# michael a.g. a\u00efv\u00e1zis <michael.aivazis@para-sim.com>\n# (c) 1998-2023 all rights reserved\n\n# build time\n[build-system]\nrequires = [\n    \"wheel\",\n    \"setuptools\",\n    \"setuptools_scm[toml]\",\n    \"cmake\",\n    \"scikit-build\",\n    \"pybind11\",\n    \"numpy\",\n    \"ninja; platform_system!='Windows'\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n# install time\n[project]\nname = \"pyre\"\nversion = \"1.12.0\"\ndescription = \"A framework for building scientific applications\"\nreadme = \"README.md\"\nauthors = [\n    { name = \"Michael A.G. A\u00efv\u00e1zis\", email = \"michael.aivazis@para-sim.com\" },\n]\nmaintainers = [\n    { name = \"Michael A.G. A\u00efv\u00e1zis\", email = \"michael.aivazis@para-sim.com\" },\n]\nrequires-python = \">3.7.2\"\nkeywords = [\"science\", \"framework\"]\nclassifiers = [\n    \"Development Status :: 6 - Mature\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Programming Language :: Python :: 3 :: Only\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n]\ndependencies = [\"PyYAML\"]\n\n# package discovery\n[tool.setuptools.packages.find]\nwhere = [\"packages\"]\ninclude = [\"journal*\"]\n# include = [\"cuda\", \"gsl\", \"journal\", \"merlin\", \"mpi\", \"pyre\"]\nnamespaces = false\n\n# end of file\n"
  },
  "hemelb-codes/hemelb": {
    "geometry-tool/setup.py": "# This file is part of HemeLB and is Copyright (C)\n# the HemeLB team and/or their institutions, as detailed in the\n# file AUTHORS. This software is provided under the terms of the\n# license in the file LICENSE.\n\nimport os\nimport sys\n\nfrom skbuild import setup\n\nif sys.platform == \"darwin\":\n    # Python thinks it's so smart and sets the\n    # MACOSX_DEPLOYMENT_TARGET environment variable that messes around\n    # with what features of the compiler and C++ std lib are\n    # available. Set this to use your current one.\n    import platform\n\n    release, versioninfo, machine = platform.mac_ver()\n    os.environ[\"MACOSX_DEPLOYMENT_TARGET\"] = release\n\nsetup(\n    name=\"HlbGmyTool\",\n    version=\"1.2\",\n    author=\"Rupert Nash\",\n    author_email=\"r.nash@epcc.ed.ac.uk\",\n    packages=[\n        \"HlbGmyTool\",\n        \"HlbGmyTool.Bindings\",\n        \"HlbGmyTool.Util\",\n        \"HlbGmyTool.Model\",\n        \"HlbGmyTool.View\",\n        \"HlbGmyTool.Controller\",\n        \"HlbGmyTool.scripts\",\n    ],\n    entry_points={\n        \"console_scripts\": [\n            \"hlb-gmy-cli=HlbGmyTool.scripts.cli:main\",\n            \"hlb-config2gmy=HlbGmyTool.scripts.config_to_geometry:main\",\n            \"hlb-pro2pr2=HlbGmyTool.scripts.pro_to_pr2:main\",\n        ],\n        \"gui_scripts\": [\n            \"hlb-gmy-gui=HlbGmyTool.scripts.gui:main[gui]\",\n        ],\n    },\n    python_requires=\">=3.6\",\n    install_requires=[\n        \"pyyaml\",\n        # Numpy >= 1.20 requires python 3.7; VMTK conda binaries are 3.6 only\n        \"numpy < 1.20; python_version < '3.7'\",\n        \"numpy; python_version >= '3.7'\",\n        \"vtk ~= 9.0\",\n        \"vmtk ~= 1.5\",\n    ],\n    extras_require={\n        \"gui\": [\"wxPython\"],\n    },\n)\n",
    "geometry-tool/pyproject.toml": "[build-system]\nrequires-python = \">=3.6\"\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build\",\n    \"pybind11\",\n    \"cmake ~= 3.13\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "ghostbsd/ghostbsd-ports": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "KitwareMedical/ITKMorphologicalContourInterpolation": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-morphologicalcontourinterpolation',\n    version='1.1.0',\n    author='D\u017eenan Zuki\u0107',\n    author_email='community@itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/KitwareMedical/ITKMorphologicalContourInterpolation',\n    description=r'Image morphological contour interpolation.',\n    long_description='itk-morphologicalcontourinterpolation provides classes '\n                     'to perform image morphological contour interpolation.\\n'\n                     'Please refer to:\\n'\n                     'Zuki\u0107 D\u017e., Vicory J., McCormick M., Wisse L., Gerig G., Yushkevich P., Aylward S. '\n                     '\"nD Morphological Contour Interpolation\", '\n                     'Insight Journal, January-December 2016, https://hdl.handle.net/10380/3563.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit Segmentation Interpolation-methods',\n    url=r'https://github.com/KitwareMedical/ITKMorphologicalContourInterpolation',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "pupil-labs/pye3d-detector": {
    "setup.py": "#!/usr/bin/env python\n\nimport os\nimport platform\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\ncpp_dir = \"pye3d/cpp\"\ncmake_args = []\n\nif os.environ.get(\"CI\", \"false\") == \"true\" and platform.system() == \"Windows\":\n    # The Ninja cmake generator will use mingw (gcc) on windows travis instances, but we\n    # need to use msvc for compatibility.\n    cmake_args.append(\"-GVisual Studio 17 2022\")\n\n\nif __name__ == \"__main__\":\n    setup(\n        # `packages` cannot be defined in setup.cfg, otherwise the C extensions will\n        # not be copied to the correct place\n        packages=find_packages(),\n        cmake_args=cmake_args,\n        cmake_install_dir=cpp_dir,\n        cmake_source_dir=cpp_dir,\n        package_data={\"pye3d\": [\"refraction_models/*.msgpack\"]},\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=56\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\",\n    \"numpy\",\n    \"cython\",\n    \"setuptools_scm[toml]>=3.4.1\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nskip-string-normalization = true\n\n[tool.setuptools_scm]\n\n[pytest.enabler.cov]\naddopts = \"--cov\"\n",
    "setup.cfg": "[metadata]\nname = pye3d\ndescription = 3D eye model\nlong_description = file: README.rst\nlong_description_content_type = text/x-rst\nurl = https://github.com/pupil-labs/pye3d-detector\nauthor = Pupil Labs GmbH\nauthor_email = info@pupil-labs.com\nlicense_file = LICENSE\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    License :: OSI Approved :: MIT License\n    License :: Other/Proprietary License\n    Natural Language :: English\n    Operating System :: MacOS\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3 :: Only\n    Topic :: Scientific/Engineering\n\n[options]\ninstall_requires =\n    msgpack>=1.0\n    numpy\n    sortedcontainers\n    importlib-metadata;python_version<\"3.8\"\npython_requires = >=3.6\ninclude_package_data = true\n\n[options.packages.find]\nexclude =\n    build*\n    dist*\n    docs*\n    tests*\n\n[options.extras_require]\ndocs =\n    furo\n    jaraco.packaging>=8.2\n    rst.linker>=1.9\n    sphinx<4.4  # 4.4 does not detect TypeVars correctly\nexamples =\n    opencv-python\n    pupil-detectors\nlegacy_sklearn_models =\n    joblib\n    scikit-learn\ntesting =\n    matplotlib\n    opencv-python-headless==4.6.0.66\n    pandas\n    pytest>=6\n    pytest-checkdocs>=2.4\n    pytest-cov\n    pytest-enabler>=1.0.1\n    scikit-image\nwith_opencv =\n    opencv-python\n"
  },
  "iory/texture-mapping": {
    "setup.py": "from __future__ import print_function\n\nimport distutils.spawn\nimport shlex\nimport subprocess\nimport sys\n\nfrom setuptools import find_packages\n\n\nversion = '0.0.7'\n\n\nif sys.argv[-1] == 'release':\n    if not distutils.spawn.find_executable('twine'):\n        print(\n            'Please install twine:\\n\\n\\tpip install twine\\n',\n            file=sys.stderr,\n        )\n        sys.exit(1)\n\n    commands = [\n        'git tag v{:s}'.format(version),\n        'git push origin master --tag',\n        'python setup.py sdist',\n        'twine upload dist/texture-mapping-{:s}.tar.gz'.format(version),\n    ]\n    for cmd in commands:\n        print('+ {}'.format(cmd))\n        subprocess.check_call(shlex.split(cmd))\n    sys.exit(0)\n\nsetup_requires = [\n]\n\ninstall_requires = [\n    'scikit-build',\n    'pillow',\n]\n\nsetup_params = dict(\n    name=\"texture-mapping\",\n    version=version,\n    description=\"PCL Texture Mapping Wrapper of Python\",\n    author='iory',\n    author_email='ab.ioryz@gmail.com',\n    url='https://github.com/iory/texture-mapping',\n    long_description=open('README.md').read(),\n    long_description_content_type='text/markdown',\n    license=\"MIT\",\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Natural Language :: English',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: Implementation :: CPython',\n    ],\n    packages=find_packages(),\n    setup_requires=setup_requires,\n    install_requires=install_requires,\n    entry_points={\n        'console_scripts':\n        ['texture-mapping=texture_mapping.apps.mapping:main']}\n)\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef install_packages(*requirements):\n    # No more convenient way until PEP 518 is implemented;\n    # setuptools only handles eggs\n    subprocess.check_call(\n        [sys.executable, \"-m\", \"pip\", \"install\"] + list(requirements)\n    )\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef get_or_install(name, version=None):\n    \"\"\"If a package is already installed, build against it. If not, install\n\n    \"\"\"\n    # Do not import 3rd-party modules into the current process\n    import json\n    js_packages = json.loads(\n        # valid names & versions are ASCII as per PEP 440\n        subprocess.check_output(\n            [sys.executable,\n             \"-m\", \"pip\", \"list\", \"--format\", \"json\"]).decode('ascii'))\n    try:\n        [package] = (package for package in js_packages\n                     if package['name'] == name)\n    except ValueError:\n        install_packages(\"%s==%s\" % (name, version) if version else name)\n        return version\n    else:\n        return package['version']\n\n\ndef main():\n    get_or_install('scikit-build')\n    import skbuild  # NOQA\n\n    skbuild.setup(**setup_params)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  "realthunder/slvs_py": {
    "setup.py": "from skbuild import setup\n\nimport os, io\nthis_directory = os.path.abspath(os.path.dirname(__file__))\nwith io.open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nif __name__ == '__main__':\n    setup(\n        name='py_slvs',\n        version='1.0.6',\n        packages=['py_slvs'],\n        license='Gnu General Public License 3.0',\n        author='Zheng, Lei',\n        author_email='realthunder.dev@gmail.com',\n        cmake_args=['-DENABLE_GUI:BOOL=OFF','-DBUILD_PYTHON:BOOL=ON'],\n        cmake_source_dir='py_slvs',\n        url='https://github.com/realthunder/slvs_py',\n        description='Python binding of SOLVESPACE geometry constraint solver',\n        long_description=long_description,\n        long_description_content_type='text/markdown'\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "Nicholaswogan/NumbaMinpack": {
    "setup.py": "from skbuild import setup\n\nfrom os import path\nthis_directory = path.abspath(path.dirname(__file__))\nwith open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup(\n    name=\"NumbaMinpack\",\n    packages=['NumbaMinpack'],\n    version='0.1.3',\n    license='MIT',\n    install_requires=['numpy','numba'],\n    author = 'Nicholas Wogan',\n    author_email = 'nicholaswogan@gmail.com',\n    description = 'Python wrapper of Minpack (root finding)'+\\\n                  ' which can be called from within numba functions.',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    python_requires='>3.6',\n    url = \"https://github.com/Nicholaswogan/NumbaMinpack\",\n    cmake_args=['-DSKBUILD=ON']\n    )",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\"]",
    "setup.cfg": "[metadata]\nlicense_file = LICENSE.txt\ndescription-file = README.md"
  },
  "Chrismarsh/mesher": {
    "setup.py": "from skbuild import setup\nimport subprocess\nfrom skbuild.exceptions import SKBuildError\nfrom skbuild.cmaker import get_cmake_version\nimport packaging.version\nfrom setuptools import find_packages\nimport os\n\ndef get_installed_gdal_version():\n    try:\n        version = subprocess.run([\"gdal-config\",\"--version\"], stdout=subprocess.PIPE).stdout.decode()\n\n        version = version.replace('\\n', '')\n\n        version = \"==\"+version\n        return version\n    except FileNotFoundError as e:\n        raise(\"\"\" ERROR: Could not find the system install of GDAL. \n                  Please install it via your package manage of choice.\n                \"\"\"\n            )\n\n# Add CMake as a build requirement if cmake is not installed or is too low a version\n# https://scikit-build.readthedocs.io/en/latest/usage.html#adding-cmake-as-building-requirement-only-if-not-installed-or-too-low-a-version\nsetup_requires = []\ntry:\n    if packaging.version.parse(get_cmake_version()) < packaging.version.parse(\"3.16\"):\n        setup_requires.append('cmake')\nexcept SKBuildError:\n    setup_requires.append('cmake')\n\n\nUSE_CONAN = False\ntry:\n  USE_CONAN = os.environ[\"USE_CONAN\"]\nexcept KeyError as e:\n  pass # it's ok we don't have this\n\nUSE_CONAN = str(USE_CONAN).upper() \n\nsetup(name='mesher',\n    version='2.0.6',\n    description='Landsurface model mesh generation',\n    long_description=\"\"\"\n    Mesher is a novel multi-objective unstructured mesh generation software that allows mesh generation to be generated from an arbitrary number of hydrologically important features while maintaining a variable spatial resolution. \n    Triangle quality is guaranteed as well as a smooth graduation from small to large triangles. Including these additional features resulted in a better representation of spatial heterogeneity versus classic topography-only mesh generation.\n    The paper describing mesher can be `found here <https://www.usask.ca/hydrology/papers/Marsh,_et_al_2018.pdf>`_\n    \n    Key points\n    \n    *  A novel multi-objective unstructured mesh generation software, Mesher\n    *  Heterogeneity in topography is resolved as well as hydrologically important surface and sub-surface attributes\n    *  Spatial heterogeneity is better preserved compared to existing mesh generators\n    \"\"\",\n    author='Chris Marsh',\n    author_email='chris.marsh@usask.ca',\n    url=\"https://github.com/Chrismarsh/mesher\",\n    packages=find_packages(where=\"pysrc\"),\n    package_dir={\n        '': 'pysrc',\n    },\n    include_package_data=True,\n    cmake_args=['-DCMAKE_BUILD_TYPE:STRING=Release',\n              '-DUSE_CONAN:BOOL='+USE_CONAN],\n    scripts=[\"mesher.py\",\"tools/mesh2vtu.py\", \"tools/meshmerge.py\",\"tools/meshpermutation.py\",\"tools/meshstats.py\", \"tools/mesh2shp.py\"],\n    install_requires=['vtk','numpy', 'scipy', 'matplotlib', 'cloudpickle', 'gdal[numpy]'+get_installed_gdal_version(),\n                      'metis', 'mpi4py', 'natsort'],\n    setup_requires=setup_requires,\n    python_requires='>=3.7'\n    )",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"conan\", \"scikit-build>=0.11.1\", \"ninja\",\"packaging\"]\n#conan has an older distro req than scikit-build, so specify conan first to get the correct version\n# scikit version required for this https://github.com/scikit-build/scikit-build/issues/488"
  },
  "ReadAlongs/SoundSwallower": {
    "setup.py": "from setuptools import find_packages\nfrom skbuild import setup\n\nsetup(\n    packages=find_packages(\"py\", exclude=[\"test\"]),\n    package_dir={\"\": \"py\"},\n    package_data={\"soundswallower\": [\"py.typed\", \"_soundswallower.pyi\"]},\n    entry_points={\n        \"console_scripts\": [\n            \"soundswallower = soundswallower.cli:main\",\n        ],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n\t \"setuptools>=45,<64\",\n\t \"wheel\",\n\t \"scikit-build~=0.15\",\n\t \"cmake\",\n\t \"Cython\",\n\t \"ninja\"\n]\nbuild-backend = \"setuptools.build_meta\"\n[tool.cibuildwheel]\n# Build the versions found in Ubuntu LTS, the stable PyPy, Anaconda on Windows\n# ...and some other versions we want for Windows\nbuild = [\n      \"pp38*\",\n      \"cp36-manylinux_*\",\n      \"cp38-manylinux_*\",\n      \"cp37-win*\",\n      \"cp38-win*\",\n      \"cp39-win*\",\n      \"cp310-*\"\n]\n# PyPy 3.8 will choke on CPython 3.8 build leftovers...\nbefore-build = \"rm -rf _skbuild\"\n# PyPy builds are broken on Windows, and skip 32-bit and musl\nskip = [\"*musl*\", \"*_i686\", \"*-win32\", \"pp*win*\"]\n",
    "setup.cfg": "[metadata]\nname = soundswallower\nversion = 0.6.0\ndescription = An even smaller speech recognizer\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nauthor = David Huggins-Daines\nauthor_email = dhdaines@gmail.com\nlicense = MIT\nplatforms = any\nurl = https://github.com/ReadAlongs/SoundSwallower\nproject_urls =\n    Documentation = https://soundswallower.readthedocs.io/\n    Tracker = https://github.com/ReadAlongs/SoundSwallower/issues\nkeywords = asr, speech\nclassifiers =\n    Development Status :: 3 - Alpha\n    Programming Language :: C\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.7\n    License :: OSI Approved :: MIT License\n    Operating System :: OS Independent\n    Natural Language :: English\n    Natural Language :: French\n"
  },
  "HITS-MBM/gromacs-fda": {
    "python_packaging/src/setup.py": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2019,2020,2021, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\n# Python setuptools script to build and install the gmxapi Python interface\n# from a GROMACS installation directory.\n\n# Usage note: things go smoothly when we stick to the setup.py convention of\n# having a package source directory with the same name as the package at the\n# same level as the setup.py script and only expect `pip install .` in the\n# setup.py directory. If we play with the layout more, it is hard to keep all\n# of the `pip` and `setup.py` cases working as expected. This is annoying\n# because running the Python interpreter immediately from the same directory\n# can find the uninstalled source instead of the installed package. We can\n# ease this pain by building an sdist in the enclosing CMake build scope\n# and encouraging users to `pip install the_sdist.archive`. Otherwise, we\n# just have to document that we only support full build-install of the Python\n# package from the directory containing setup.py, which may clutter that\n# directory with some artifacts.\n\nimport os\n\n# Import setuptools early to avoid UserWarning from Distutils.\n# Ref: https://gitlab.com/gromacs/gromacs/-/issues/3715\nimport setuptools\n\n# Allow setup.py to be run when scikit-build is not installed, such as to\n# produce source distribution archives with `python setup.py sdist`\ntry:\n    from skbuild import setup\nexcept ImportError:\n    from distutils.core import setup\n\nusage = \"\"\"\nThe `gmxapi` package requires an existing GROMACS installation, version 2020 or higher.\nTo specify the GROMACS installation to use, provide a GMXTOOLCHAINDIR\nenvironment variable when running setup.py or `pip`.\n\nExample:\n    GMXTOOLCHAINDIR=/path/to/gromacs/share/cmake/gromacs pip install gmxapi\n\nIf you have multiple builds of GROMACS, distinguished by a suffix `$SUFFIX`, the\ntool chain directory will use that suffix.\n\nExample:\n    GMXTOOLCHAINDIR=/path/to/gromacs/share/cmake/gromacs$SUFFIX pip install gmxapi\n\nIn the example, `gmxapi` is downloaded automatically from pypi.org. You can\nreplace `gmxapi` with a local directory or archive file to build from a source\ndistribution.\n\nsetup.py will use the location of GMXTOOLCHAINDIR to locate the\ngmxapi library configured during GROMACS installation. Alternatively, if\ngmxapi_DIR is provided, or if GMXRC has been \"sourced\", the toolchain file\nlocation may be deduced. Note, though, that if multiple GROMACS installations\nexist in the same location (with different suffixes) only the first one will be\nused when guessing a toolchain, because setup.py does not know which corresponds\nto the gmxapi support library.\n\nIf specifying GMXTOOLCHAINDIR and gmxapi_DIR, the tool chain directory must be \nlocated within a subdirectory of gmxapi_DIR.\n\nRefer to project web site for complete documentation.\n\n\"\"\"\n\n\nclass GmxapiInstallError(Exception):\n    \"\"\"Error processing setup.py for gmxapi Python package.\"\"\"\n\n\ngmx_toolchain_dir = os.getenv('GMXTOOLCHAINDIR')\ngmxapi_DIR = os.getenv('gmxapi_DIR')\nif gmxapi_DIR is None:\n    # Infer from GMXRC exports, if available.\n    gmxapi_DIR = os.getenv('GROMACS_DIR')\n\n\ndef _find_first_gromacs_suffix(directory):\n    dir_contents = os.listdir(directory)\n    for entry in dir_contents:\n        if entry.startswith('gromacs'):\n            return entry.strip('gromacs')\n\n\nif gmx_toolchain_dir is None:\n    # Try to guess from standard GMXRC environment variables.\n    if gmxapi_DIR is not None:\n        if os.path.exists(gmxapi_DIR) and os.path.isdir(gmxapi_DIR):\n            share_cmake = os.path.join(gmxapi_DIR, 'share', 'cmake')\n            suffix = _find_first_gromacs_suffix(share_cmake)\n            if suffix is not None:\n                gmx_toolchain_dir = os.path.join(share_cmake, 'gromacs' + suffix)\n\nif gmx_toolchain_dir is None:\n    print(usage)\n    raise GmxapiInstallError('Could not configure for GROMACS installation. Provide GMXTOOLCHAINDIR.')\n\nsuffix = os.path.basename(gmx_toolchain_dir).strip('gromacs')\ngmx_toolchain = os.path.abspath(os.path.join(gmx_toolchain_dir, 'gromacs-toolchain' + suffix + '.cmake'))\n\nif gmxapi_DIR is None:\n    # Example: given /usr/local/gromacs/share/cmake/gromacs/gromacs-toolchain.cmake,\n    # we would want /usr/local/gromacs.\n    # Note that we could point more directly to the gmxapi-config.cmake but,\n    # so far, we have relied on CMake automatically looking into\n    # <package>_DIR/share/cmake/<package>/ for such a file.\n    # We would need a slightly different behavior for packages that link against\n    # libgromacs directly, as sample_restraint currently does.\n    gmxapi_DIR = os.path.join(os.path.dirname(gmx_toolchain), '..', '..', '..')\n\ngmxapi_DIR = os.path.abspath(gmxapi_DIR)\n\nif not os.path.exists(gmxapi_DIR) or not os.path.isdir(gmxapi_DIR):\n    print(usage)\n    raise GmxapiInstallError('Please set a valid gmxapi_DIR.')\n\nif gmxapi_DIR != os.path.commonpath([gmxapi_DIR, gmx_toolchain]):\n    raise GmxapiInstallError('GROMACS toolchain file {} is not in gmxapi_DIR {}'.format(\n        gmx_toolchain,\n        gmxapi_DIR\n    ))\n\ncmake_platform_hints = '-DCMAKE_TOOLCHAIN_FILE={}'.format(gmx_toolchain)\n# Note that <package>_ROOT is not standard until CMake 3.12\n# Reference https://cmake.org/cmake/help/latest/policy/CMP0074.html#policy:CMP0074\ncmake_gmxapi_hint = '-Dgmxapi_ROOT={}'.format(gmxapi_DIR)\ncmake_args = [cmake_platform_hints, cmake_gmxapi_hint]\n\nlong_description = \"\"\"gmxapi provides Python access to GROMACS molecular simulation tools.\nOperations can be connected flexibly to allow high performance simulation and\nanalysis with complex control and data flows. Users can define new operations\nin C++ or Python with the same tool kit used to implement this package.\n\nThis Python package requires a compatible GROMACS installation with the API\nlibraries and headers.\n\nSee http://gmxapi.org/ for details on installation and usage.\n\"\"\"\n\nsetup(\n    name='gmxapi',\n\n    # TODO: single-source version information (currently repeated in gmxapi/version.py and CMakeLists.txt)\n    version='0.2.3',\n    python_requires='>=3.6',\n    install_requires=['networkx>=2.0',\n                      'numpy>=1'],\n\n    packages=['gmxapi', 'gmxapi.simulation'],\n    package_data={'gmxapi': ['gmxconfig.json']},\n\n    cmake_args=cmake_args,\n\n    author='M. Eric Irrgang',\n    author_email='info@gmxapi.org',\n    description='gmxapi Python interface for GROMACS',\n    long_description=long_description,\n    license='LGPL',\n    url='http://gmxapi.org/',\n\n    # The installed package will contain compiled C++ extensions that cannot be loaded\n    # directly from a zip file.\n    zip_safe=False\n)\n",
    "python_packaging/src/pyproject.toml": "[build-system]\nrequires = ['cmake>=3.13',\n            'scikit-build>=0.10',\n            'setuptools>=42',\n            'wheel']\nbuild-backend = 'setuptools.build_meta:__legacy__'\n"
  },
  "NiftyPET/NIPET": {
    "setup.py": "#!/usr/bin/env python3\n\"\"\"\nCompile CUDA source code and setup Python 3 package 'nipet'\nfor namespace 'niftypet'.\n\"\"\"\nimport logging\nimport re\nimport sys\nfrom pathlib import Path\nfrom textwrap import dedent\n\nfrom setuptools import find_packages\nfrom setuptools_scm import get_version\nfrom skbuild import setup\n\nfrom niftypet.ninst import cudasetup as cs\nfrom niftypet.ninst import install_tools as tls\n\n__version__ = get_version(root=\".\", relative_to=__file__)\n\nlogging.basicConfig(level=logging.INFO, format=tls.LOG_FORMAT)\nlog = logging.getLogger(\"nipet.setup\")\npath_current = Path(__file__).resolve().parent\n\ntls.check_platform()\n\n# =================================================================================================\n# automatically detects if the CUDA header files are in agreement with Python constants.\n# =================================================================================================\n\n\ndef chck_vox_h(Cnt):\n    \"\"\"check if voxel size in Cnt and adjust the CUDA header files accordingly.\"\"\"\n    rflg = False\n    fpth = path_current / \"niftypet\" / \"nipet\" / \"include\" / \"def.h\"\n    def_h = fpth.read_text()\n    # get the region of keeping in synch with Python\n    i0 = def_h.find(\"//## start ##//\")\n    i1 = def_h.find(\"//## end ##//\")\n    defh = def_h[i0:i1]\n    # list of constants which will be kept in synch from Python\n    cnt_list = [\n        \"SZ_IMX\", \"SZ_IMY\", \"SZ_IMZ\", \"TFOV2\", \"SZ_VOXY\", \"SZ_VOXZ\", \"SZ_VOXZi\", \"RSZ_PSF_KRNL\"]\n    flg = False\n    for s in cnt_list:\n        m = re.search(\"(?<=#define \" + s + r\")\\s*\\d*\\.*\\d*\", defh)\n        if s[3] == \"V\":\n            # print(s, float(m.group(0)), Cnt[s])\n            if Cnt[s] != float(m.group(0)):\n                flg = True\n                break\n        else:\n            # print(s, int(m.group(0)), Cnt[s])\n            if Cnt[s] != int(m.group(0)):\n                flg = True\n                break\n    # if flag is set then redefine the constants in the sct.h file\n    if flg:\n        strNew = (\"//## start ##// constants definitions in synch with Python.   DON\"\n                  \"T MODIFY MANUALLY HERE!\\n\" + \"// IMAGE SIZE\\n\" + \"// SZ_I* are image sizes\\n\" +\n                  \"// SZ_V* are voxel sizes\\n\")\n        strDef = \"#define \"\n        for s in cnt_list:\n            strNew += strDef + s + \" \" + str(Cnt[s]) + (s[3] == \"V\") * \"f\" + \"\\n\"\n\n        fpth.write_text(def_h[:i0] + strNew + def_h[i1:])\n        rflg = True\n\n    return rflg\n\n\ndef chck_sct_h(Cnt):\n    \"\"\"\n    check if voxel size for scatter correction changed and adjust\n    the CUDA header files accordingly.\n    \"\"\"\n    rflg = False\n    fpth = path_current / \"niftypet\" / \"nipet\" / \"sct\" / \"src\" / \"sct.h\"\n    # pthcmpl = path.dirname(resource_filename(__name__, ''))\n    sct_h = fpth.read_text()\n    # get the region of keeping in synch with Python\n    i0 = sct_h.find(\"//## start ##//\")\n    i1 = sct_h.find(\"//## end ##//\")\n    scth = sct_h[i0:i1]\n    # list of constants which will be kept in sych from Python\n    cnt_list = [\n        \"SS_IMX\", \"SS_IMY\", \"SS_IMZ\", \"SSE_IMX\", \"SSE_IMY\", \"SSE_IMZ\", \"NCOS\", \"SS_VXY\", \"SS_VXZ\",\n        \"IS_VXZ\", \"SSE_VXY\", \"SSE_VXZ\", \"R_RING\", \"R_2\", \"IR_RING\", \"SRFCRS\"]\n    flg = False\n    for i, s in enumerate(cnt_list):\n        m = re.search(\"(?<=#define \" + s + r\")\\s*\\d*\\.*\\d*\", scth)\n        # if s[-3]=='V':\n        if i < 7:\n            # print(s, int(m.group(0)), Cnt[s])\n            if Cnt[s] != int(m.group(0)):\n                flg = True\n                break\n        else:\n            # print(s, float(m.group(0)), Cnt[s])\n            if Cnt[s] != float(m.group(0)):\n                flg = True\n                break\n\n    # if flag is set then redefine the constants in the sct.h file\n    if flg:\n        strNew = dedent(\"\"\"\\\n            //## start ##// constants definitions in synch with Python.   DO NOT MODIFY!\\n\n            // SCATTER IMAGE SIZE AND PROPERTIES\n            // SS_* are used for the mu-map in scatter calculations\n            // SSE_* are used for the emission image in scatter calculations\n            // R_RING, R_2, IR_RING: ring radius, squared radius, inverse radius\n            // NCOS is the number of samples for scatter angular sampling\n            \"\"\")\n\n        strDef = \"#define \"\n        for i, s in enumerate(cnt_list):\n            strNew += strDef + s + \" \" + str(Cnt[s]) + (i > 6) * \"f\" + \"\\n\"\n\n        fpth.write_text(sct_h[:i0] + strNew + sct_h[i1:])\n        # sys.path.append(pthcmpl)\n        rflg = True\n\n    return rflg\n\n\ndef check_constants():\n    \"\"\"get the constants for the mMR from the resources file before\n    getting the path to the local resources.py (on Linux machines it is in ~/.niftypet)\"\"\"\n    resources = cs.get_resources()\n    Cnt = resources.get_mmr_constants()\n\n    sct_compile = chck_sct_h(Cnt)\n    def_compile = chck_vox_h(Cnt)\n    # sct_compile = False\n    # def_compile = False\n\n    if sct_compile or def_compile:\n        txt = \"NiftyPET constants were changed: needs CUDA compilation.\"\n    else:\n        txt = \"- - . - -\"\n\n    log.info(\n        dedent(\"\"\"\\\n            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n            changed sct.h: {}\n            changed def.h: {}\n            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n            {}\n            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"\"\").format(\n            sct_compile, def_compile, txt))\n\n\ncs.resources_setup(gpu=False) # install resources.py\n\n# check and update the constants in C headers according to resources.py\ncheck_constants()\ntry:\n    nvcc_arches = cs.dev_setup() # update resources.py with a supported GPU device\nexcept Exception as exc:\n    nvcc_arches = []\n    log.error(\"could not set up CUDA:\\n%s\", exc)\n\nbuild_ver = \".\".join(__version__.split('.')[:3]).split(\".dev\")[0]\ncmake_args = [f\"-DNIPET_BUILD_VERSION={build_ver}\", f\"-DPython3_ROOT_DIR={sys.prefix}\"]\ntry:\n    if nvcc_arches:\n        cmake_args.append(\"-DCMAKE_CUDA_ARCHITECTURES=\" + \";\".join(sorted(nvcc_arches)))\nexcept Exception as exc:\n    if \"sdist\" not in sys.argv or any(i in sys.argv for i in [\"build\", \"bdist\", \"wheel\"]):\n        log.warning(\"Import or CUDA device detection error:\\n%s\", exc)\nfor i in (Path(__file__).resolve().parent / \"_skbuild\").rglob(\"CMakeCache.txt\"):\n    i.write_text(re.sub(\"^//.*$\\n^[^#].*pip-build-env.*$\", \"\", i.read_text(), flags=re.M))\nsetup(use_scm_version=True, packages=find_packages(exclude=[\"examples\", \"tests\"]),\n      package_data={\"niftypet\": [\"nipet/auxdata/*\"]}, cmake_source_dir=\"niftypet\",\n      cmake_languages=(\"C\", \"CXX\", \"CUDA\"), cmake_minimum_required_version=\"3.18\",\n      cmake_args=cmake_args)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"setuptools_scm[toml]>=3.4\",\n            \"cuvec>=2.8.0\", \"ninst>=0.12.0\", \"numpy>=1.14\", \"miutil[cuda]>=0.4.0\",\n            \"scikit-build>=0.11.0\", \"cmake>=3.18\", \"ninja\"]\n\n[tool.setuptools_scm]\nwrite_to = \"niftypet/nipet/_dist_ver.py\"\nwrite_to_template = \"__version__ = '{version}'\\n\"\n",
    "setup.cfg": "[metadata]\nname=nipet\ndescription=CUDA-accelerated Python utilities for high-throughput PET/MR image reconstruction and analysis\nlong_description=file: README.rst\nlong_description_content_type=text/x-rst\nlicense=Apache 2.0\nlicense_file=LICENCE\nurl=https://github.com/NiftyPET/NIPET\nproject_urls=\n    Changelog=https://github.com/NiftyPET/NIPET/releases\n    Documentation=https://niftypet.readthedocs.io\nauthor=Pawel Markiewicz\nauthor_email=p.markiewicz@ucl.ac.uk\nmaintainer=Casper da Costa-Luis\nmaintainer_email=casper.dcl@physics.org\nkeywords=PET, image reconstruction, analysis\nclassifiers=\n    Development Status :: 5 - Production/Stable\n    Environment :: GPU\n    Environment :: GPU :: NVIDIA CUDA\n    Intended Audience :: Education\n    Intended Audience :: Healthcare Industry\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: Apache Software License\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Programming Language :: C\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3 :: Only\n    Topic :: Scientific/Engineering :: Medical Science Apps.\n[options]\nzip_safe=False\nsetup_requires=\n    setuptools>=42\n    wheel\n    setuptools_scm[toml]\n    cuvec>=2.8.0\n    miutil[cuda]>=0.4.0\n    ninst>=0.12.0\n    numpy>=1.14\n    scikit-build>=0.11.0\n    cmake>=3.18\n    ninja\ninstall_requires=\n    cuvec>=2.10.0\n    miutil>=0.6.0\n    nibabel>=2.4.0\n    nimpa>=2.4.0\n    ninst>=0.12.0\n    numpy>=1.14\n    pydicom>=1.0.2\n    setuptools\n    tqdm>=4.27\npython_requires=>=3.6\n[options.extras_require]\ndev=\n    pre-commit\n    pytest\n    pytest-cov\n    pytest-timeout\n    pytest-xdist\nexamples=jupyter; ipywidgets; matplotlib; brainweb\n\n[flake8]\nmax_line_length=99\nextend-ignore=W504,E225,E261,E701,P1\nexclude=.git,__pycache__,build,dist,.eggs\n\n[yapf]\nspaces_before_comment=15, 20\narithmetic_precedence_indication=true\nallow_split_before_dict_value=false\ncoalesce_brackets=True\ncolumn_limit=99\neach_dict_entry_on_separate_line=False\nspace_between_ending_comma_and_closing_bracket=False\nsplit_before_named_assigns=False\nsplit_before_closing_bracket=False\n\n[isort]\nprofile=black\nline_length=99\nknown_first_party=niftypet,tests\n\n[tool:pytest]\ntimeout=3600\nlog_level=INFO\npython_files=tests/test_*.py\naddopts=-v --tb=short -rxs -W=error --show-capture=stderr --show-capture=log -n=auto --durations=0 --durations-min=2 --cov=niftypet --cov-report=term-missing --cov-report=xml\n"
  },
  "potassco/clingcon": {
    "setup.py": "import sys\nimport site\nfrom os.path import dirname, abspath\nfrom textwrap import dedent\nfrom skbuild import setup\nimport clingo\n\n\nif not site.ENABLE_USER_SITE and \"--user\" in sys.argv[1:]:\n    site.ENABLE_USER_SITE = True\n\nclingopath = abspath(dirname(clingo.__file__))\n\nsetup(\n    version = '5.0.1',\n    name = 'clingcon',\n    description = 'CFFI-based bindings to the clingcon solver.',\n    long_description = dedent('''\\\n        This package allows for adding the clingcon propagator as a\n        theory to clingcon.\n\n        It can also be used as a clingcon solver running:\n\n            python -m clingcon CLINGCON_ARGUMENTS\n        '''),\n    long_description_content_type='text/markdown',\n    author = 'Roland Kaminski',\n    author_email = 'kaminski@cs.uni-potsdam.de',\n    license = 'MIT',\n    url = 'https://github.com/potassco/clingcon',\n    install_requires=[ 'cffi', 'clingo' ],\n    cmake_args=[ '-DCLINGCON_MANAGE_RPATH=OFF',\n                 '-DPYCLINGCON_ENABLE=pip',\n                 '-DPYCLINGCON_INSTALL_DIR=libpyclingcon',\n                 f'-DPYCLINGCON_PIP_PATH={clingopath}' ],\n    packages=[ 'clingcon' ],\n    package_data={ 'clingcon': [ 'py.typed', 'import__clingcon.lib', 'clingcon.h' ] },\n    package_dir={ '': 'libpyclingcon' },\n    python_requires=\">=3.6\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"clingo\"]\n"
  },
  "daanzu/wav2vec2_stt_python": {
    "setup.py": "#\n# This file is part of wav2vec2_stt.\n# (c) Copyright 2021 by David Zurow\n# Licensed under the AGPL-3.0; see LICENSE file.\n#\n\nfrom setuptools import find_packages\nimport datetime, os, re, subprocess\n\nfrom skbuild import setup\n\n\n# Force wheel to be platform specific\n# https://stackoverflow.com/questions/45150304/how-to-force-a-python-wheel-to-be-platform-specific-when-building-it\n# https://github.com/Yelp/dumb-init/blob/48db0c0d0ecb4598d1a6400710445b85d67616bf/setup.py#L11-L27\n# https://github.com/google/or-tools/issues/616#issuecomment-371480314\ntry:\n    from wheel.bdist_wheel import bdist_wheel as bdist_wheel\n    class bdist_wheel_impure(bdist_wheel):\n\n        def finalize_options(self):\n            bdist_wheel.finalize_options(self)\n            # Mark us as not a pure python package\n            self.root_is_pure = False\n\n        def get_tag(self):\n            python, abi, plat = bdist_wheel.get_tag(self)\n            # We don't contain any python source\n            python, abi = 'py2.py3', 'none'\n            return python, abi, plat\n\n    from setuptools.command.install import install\n    class install_platlib(install):\n        def finalize_options(self):\n            install.finalize_options(self)\n            self.install_lib = self.install_platlib\n\nexcept ImportError:\n    bdist_wheel_impure = None\n    install_platlib = None\n\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n# https://packaging.python.org/guides/single-sourcing-package-version/\ndef read(*parts):\n    with open(os.path.join(here, *parts), 'r') as fp:\n        return fp.read()\n\ndef find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\nversion = find_version('wav2vec2_stt', '__init__.py')\nif version.endswith('dev0'):\n    version = version[:-1] + datetime.datetime.now().strftime('%Y%m%d%H%M%S')\n\nwith open(os.path.join(here, 'README.md')) as f:\n    long_description = f.read()\n\nif not os.path.exists('native/simplectc/CMakeLists.txt'):\n    subprocess.check_call(['git', 'submodule', 'update', '--init', 'native/simplectc/'])\n\ntorch_cmake_prefix_path = os.environ.get('TORCH_CMAKE_PREFIX_PATH') \\\n    or subprocess.check_output(['python', '-c', 'import torch;print(torch.utils.cmake_prefix_path)'], text=True).strip()\n\n\nsetup(\n    cmdclass={\n        'bdist_wheel': bdist_wheel_impure,\n        'install': install_platlib,\n    },\n    cmake_args=['-DCMAKE_PREFIX_PATH=' + torch_cmake_prefix_path],\n\n    name='wav2vec2_stt',\n    version=version,\n    description='Simple Python library, distributed via binary wheels with few direct dependencies, for easily using wav2vec 2.0 models for speech recognition.',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://github.com/daanzu/wav2vec2_stt',\n    author='David Zurow',\n    author_email='daanzu@gmail.com',\n    license='AGPL-3.0',\n    # For a list of valid classifiers, see https://pypi.org/classifiers/\n    classifiers=[\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: GNU Affero General Public License v3',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n    ],\n    # keywords='speech recognition',\n    packages=find_packages(exclude=['contrib', 'docs', 'tests']),\n    python_requires='>=3.6, <4',\n    install_requires=[\n        'cffi ~= 1.12',\n        'numpy ~= 1.16, != 1.19.4',\n    ],\n    extras_require={\n        # 'dev': ['check-manifest'],\n        'test': ['pytest'],\n    },\n    package_data={\n        'wav2vec2_stt': ['libwav2vec2_stt_lib.*'],\n        '': ['LICENSE'],\n    },\n    project_urls={\n        'Bug Reports': 'https://github.com/daanzu/wav2vec2_stt/issues',\n        'Funding': 'https://github.com/sponsors/daanzu',\n        # 'Say Thanks!': 'http://saythanks.io/to/example',\n        'Source': 'https://github.com/daanzu/wav2vec2_stt/',\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build~=0.10.0\", \"cmake>=3.15\", \"ninja\", \"torch~=1.9.0\"]\n",
    "setup.cfg": "[metadata]\n# This includes the license file(s) in the wheel.\n# https://wheel.readthedocs.io/en/stable/user_guide.html#including-license-files-in-the-generated-wheel-file\nlicense_files = LICENSE\n\n[bdist_wheel]\n# This flag says to generate wheels that support both Python 2 and Python\n# 3. If your code will not run unchanged on both Python 2 and 3, you will\n# need to generate separate wheels for each Python version that you\n# support. Removing this line (or setting universal to 0) will prevent\n# bdist_wheel from trying to make a universal wheel. For more see:\n# https://packaging.python.org/guides/distributing-packages-using-setuptools/#wheels\n# universal=1\n"
  },
  "RedFantom/masterkeys-linux": {
    "setup.py": "\"\"\"\nAuthor: RedFantom\nLicense: GNU GPLv3\nCopyright (c) 2018-2019 RedFantom\n\"\"\"\ntry:\n    from skbuild import setup\n    from skbuild.command.build import build\nexcept ImportError:\n    print(\"scikit-build is required to build this project\")\n    raise\nfrom shutil import copyfile\nimport glob\nimport os\n\n\ndef read(file_name):\n    with open(file_name) as fi:\n        contents = fi.read()\n    return contents\n\n\nclass BuildCommand(build):\n    \"\"\"Intercept the build command to copy modules\"\"\"\n    def run(self):\n        build.run(self)\n        if len(glob.glob(\"./_skbuild/linux*\")) != 0:\n            source = os.path.join(\"./_skbuild/linux*/cmake-build/*notifications.so*\")\n        else:\n            source = os.path.join(\"./_skbuild/cmake-build/*notifications.so*\")\n        target = os.path.join(\"./examples/notifications/mk_notifications.so\")\n        copyfile(glob.glob(source)[0], target)\n\n\nsetup(\n    name=\"masterkeys\",\n    version=\"0.3.0\",\n    packages=[\"masterkeys\"],\n    description=\"MasterKeys Control Library for Linux\",\n    author=\"RedFantom\",\n    url=\"https://github.com/RedFantom/masterkeys-linux\",\n    download_url=\"https://github.com/RedFantom/masterkeys-linux/releases\",\n    license=\"GNU GPLv3\",\n    classifiers=[\n        \"Programming Language :: Python :: 2.7\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: C\",\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: System :: Hardware\",\n    ],\n    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    zip_safe=False,\n    install_requires=[\"scikit-build\"],\n    cmdclass={\"build\": BuildCommand}\n)\n"
  },
  "InsightSoftwareConsortium/ITKTextureFeatures": {
    "setup.py": "from __future__ import print_function\nfrom os import sys, path\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-texturefeatures',\n    version='3.6.0',\n    author='Insight Software Consortium',\n    author_email='community@itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKTextureFeatures',\n    description=r'An ITK module to compute N-dimension grayscale texture feature images',\n    long_description='ITK is an open-source, cross-platform library that '\n                     'provides developers with an extensive suite of software '\n                     'tools for image analysis. Developed through extreme '\n                     'programming methodologies, ITK employs leading-edge '\n                     'algorithms for registering and segmenting '\n                     'multidimensional scientific images.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit glcm texture features image imaging',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "fedebenelli/PyForFluids": {
    "setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# License: MIT License (https://tldrlegal.com/license/mit-license)\n# Copyright (c) 2021-2022 Federico Benelli and others.\n# All rights reserved.\n\n\"\"\"This file is for the distribution of pyforfluids.\"\"\"\n\n# -> IMPORTS ------------------------------------------------------------------\n\nimport os\n\nimport setuptools  # noqa\n\nfrom skbuild import setup\n\n# -----------------------------------------------------------------------------\n\n\n# -> CONSTANTS ----------------------------------------------------------------\n\nPATH = os.path.normpath(os.path.join(__file__, os.pardir))\n\n\nPACKAGES = [\n    \"pyforfluids\",\n    \"pyforfluids.models\",\n    \"pyforfluids.fortran\",\n    \"pyforfluids.equilibrium\",\n]\n\nwith open(\"README.md\") as fp:\n    LONG_DESCRIPTION = fp.read()\n\n# -----------------------------------------------------------------------------\n\n\n# -> REQUIREMENTS -------------------------------------------------------------\n\nREQUIREMENTS = [\"numpy==1.21.6\", \"pandas>=1.3.5\", \"scipy>=1.7.3\"]\n\n# -----------------------------------------------------------------------------\n\n\n# -> VERSION ------------------------------------------------------------------\n\nINIT_PATH = os.path.join(PATH, \"pyforfluids\", \"__init__.py\")\n\nwith open(INIT_PATH, \"r\") as f:\n    for line in f:\n        if line.startswith(\"__version__\"):\n            VERSION = line.split(\"=\", 1)[-1].replace('\"', \"\").strip()\n            break\n\n# -----------------------------------------------------------------------------\n\n\n# -> SETUP --------------------------------------------------------------------\n\nsetup(\n    name=\"pyforfluids\",\n    version=VERSION,\n    description=\"Fluid's thermodynamic properties\",\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/markdown\",\n    author=\"Federico E. Benelli; M. Candelaria Arpajou\",\n    author_email=\"federico.benelli@mi.unc.edu.ar\",\n    url=\"https://github.com/fedebenelli/pyforfluids\",\n    license=\"MIT\",\n    keywords=\"Thermodynamic, Fluids, Properties, EoS\",\n    classifiers=[\n        \"Development Status :: 2 - Pre-Alpha\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: Fortran\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Topic :: Scientific/Engineering\",\n    ],\n    packages=PACKAGES,\n    install_requires=REQUIREMENTS,\n)\n\n# -----------------------------------------------------------------------------\n",
    "pyproject.toml": "[tool.black]\nline-length = 79\ntarget-version = ['py310']\n\n[build-system]\nbuild-backend = \"setuptools.build_meta\"\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\",\n    \"numpy==1.21.6\",\n    \"wheel\"\n]\n"
  },
  "python-packaging/dowsing": {
    "dowsing/setuptools/setup_py_parsing.py": "\"\"\"\nThis is mostly compatible with pkginfo's metadata classes.\n\"\"\"\n\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nimport libcst as cst\nfrom libcst.metadata import ParentNodeProvider, QualifiedNameProvider, ScopeProvider\n\nfrom ..types import Distribution\nfrom .setup_and_metadata import SETUP_ARGS\n\nLOG = logging.getLogger(__name__)\n\n\ndef from_setup_py(path: Path, markers: Dict[str, Any]) -> Distribution:\n    \"\"\"\n    Reads setup.py (and possibly some imports).\n\n    Will not actually \"run\" the code but will evaluate some conditions based on\n    the markers you provide, since much real-world setup.py checks things like\n    version, platform, or even `sys.argv` to come up with what it passes to\n    `setup()`.\n\n    There should be some other class to read pyproject.toml.\n\n    This needs a path because one day it may need to read other files alongside\n    it.\n    \"\"\"\n\n    # TODO: This does not take care of encodings or py2 syntax.\n    module = cst.parse_module((path / \"setup.py\").read_text())\n\n    # TODO: This is not a good example of LibCST integration.  The right way to\n    # do this is with a scope provider and transformer, and perhaps multiple\n    # passes.\n\n    d = Distribution()\n    d.metadata_version = \"2.1\"\n\n    analyzer = SetupCallAnalyzer()\n    wrapper = cst.MetadataWrapper(module)\n    wrapper.visit(analyzer)\n    if not analyzer.found_setup:\n        raise SyntaxError(\"No simple setup call found\")\n\n    for field in SETUP_ARGS:\n        name = field.get_distribution_key()\n        if not hasattr(d, name):\n            continue\n\n        if field.keyword in analyzer.saved_args:\n            v = analyzer.saved_args[field.keyword]\n            if isinstance(v, Literal):\n                setattr(d, name, v.value)\n            else:\n                LOG.warning(f\"Want to save {field.keyword} but is {type(v)}\")\n\n    return d\n\n\n@dataclass\nclass TooComplicated:\n    reason: str\n\n\n@dataclass\nclass Sometimes:\n    # TODO list of 'when' and 'else'\n    pass\n\n\n@dataclass\nclass Literal:\n    value: Any\n    cst_node: Optional[cst.CSTNode]\n\n\n@dataclass\nclass FindPackages:\n    where: Any = None\n    exclude: Any = None\n    include: Any = None\n\n\nclass FileReference:\n    def __init__(self, filename: str) -> None:\n        self.filename = filename\n\n\nclass SetupCallTransformer(cst.CSTTransformer):\n    METADATA_DEPENDENCIES = (ScopeProvider, ParentNodeProvider, QualifiedNameProvider)\n\n    def __init__(\n        self,\n        call_node: cst.CSTNode,\n        keywords_to_change: Dict[str, Optional[cst.CSTNode]],\n    ) -> None:\n        self.call_node = call_node\n        self.keywords_to_change = keywords_to_change\n\n    def leave_Call(\n        self, original_node: cst.Call, updated_node: cst.Call\n    ) -> cst.BaseExpression:\n        if original_node == self.call_node:\n            new_args = []\n            for arg in updated_node.args:\n                if isinstance(arg.keyword, cst.Name):\n                    if arg.keyword.value in self.keywords_to_change:\n                        value = self.keywords_to_change[arg.keyword.value]\n                        if value is not None:\n                            new_args.append(arg.with_changes(value=value))\n                        # else don't append\n                    else:\n                        new_args.append(arg)\n                else:\n                    new_args.append(arg)\n            return updated_node.with_changes(args=new_args)\n\n        return updated_node\n\n\nclass SetupCallAnalyzer(cst.CSTVisitor):\n    METADATA_DEPENDENCIES = (ScopeProvider, ParentNodeProvider, QualifiedNameProvider)\n\n    # TODO names resulting from other than 'from setuptools import setup'\n    # TODO wrapper funcs that modify args\n    # TODO **args\n    def __init__(self) -> None:\n        super().__init__()\n        # TODO Union[TooComplicated, Sometimes, Literal, FileReference]\n        self.saved_args: Dict[str, Any] = {}\n        self.found_setup = False\n        self.setup_node: Optional[cst.CSTNode] = None\n\n    def visit_Call(self, node: cst.Call) -> Optional[bool]:\n        names = self.get_metadata(QualifiedNameProvider, node)\n        # TODO sometimes there is more than one setup call, we might\n        # prioritize/merge...\n        if any(\n            q.name\n            in (\n                \"setuptools.setup\",\n                \"distutils.core.setup\",\n                \"setup3lib\",\n                \"skbuild.setup\",\n            )\n            for q in names\n        ):\n            self.found_setup = True\n            self.setup_node = node\n            scope = self.get_metadata(ScopeProvider, node)\n            for arg in node.args:\n                # TODO **kwargs\n                if isinstance(arg.keyword, cst.Name):\n                    key = arg.keyword.value\n                    value = self.evaluate_in_scope(arg.value, scope)\n                    self.saved_args[key] = Literal(value, arg)\n                elif arg.star == \"**\":\n                    # kwargs\n                    d = self.evaluate_in_scope(arg.value, scope)\n                    if isinstance(d, dict):\n                        for k, v in d.items():\n                            self.saved_args[k] = Literal(v, None)\n                    else:\n                        # GRR\n                        pass\n                else:\n                    raise ValueError(repr(arg))\n\n            return False\n\n        return None\n\n    BOOL_NAMES = {\"True\": True, \"False\": False, \"None\": None}\n    PRETEND_ARGV = [\"setup.py\", \"bdist_wheel\"]\n\n    def evaluate_in_scope(self, item: cst.CSTNode, scope: Any) -> Any:\n        qnames = self.get_metadata(QualifiedNameProvider, item)\n\n        if isinstance(item, cst.SimpleString):\n            return item.evaluated_value\n        elif isinstance(item, (cst.Integer, cst.Float)):\n            return int(item.value)\n        elif isinstance(item, cst.Name) and item.value in self.BOOL_NAMES:\n            return self.BOOL_NAMES[item.value]\n        elif isinstance(item, cst.Name):\n            name = item.value\n            assignments = scope[name]\n            for a in assignments:\n                # TODO: Only assignments \"before\" this node matter if in the\n                # same scope; really if we had a call graph and walked the other\n                # way, we could have a better idea of what has already happened.\n\n                # Assign(\n                #   targets=[AssignTarget(target=Name(value=\"v\"))],\n                #   value=SimpleString(value=\"'x'\"),\n                # )\n                # TODO or an import...\n                # TODO builtins have BuiltinAssignment\n                try:\n                    node = a.node\n                    if node:\n                        parent = self.get_metadata(ParentNodeProvider, node)\n                        if parent:\n                            gp = self.get_metadata(ParentNodeProvider, parent)\n                        else:\n                            raise KeyError\n                    else:\n                        raise KeyError\n                except (KeyError, AttributeError):\n                    return \"??\"\n\n                # This presumes a single assignment\n                if not isinstance(gp, cst.Assign) or len(gp.targets) != 1:\n                    return \"??\"  # TooComplicated(repr(gp))\n\n                try:\n                    scope = self.get_metadata(ScopeProvider, gp)\n                except KeyError:\n                    # module scope isn't in the dict\n                    return \"??\"\n\n                return self.evaluate_in_scope(gp.value, scope)\n        elif isinstance(item, (cst.Tuple, cst.List)):\n            lst = []\n            for el in item.elements:\n                lst.append(\n                    self.evaluate_in_scope(\n                        el.value, self.get_metadata(ScopeProvider, el)\n                    )\n                )\n            if isinstance(item, cst.Tuple):\n                return tuple(lst)\n            else:\n                return lst\n        elif isinstance(item, cst.Call) and any(\n            q.name == \"setuptools.find_packages\" for q in qnames\n        ):\n            default_args = [\".\", (), (\"*\",)]\n            args = default_args.copy()\n\n            names = (\"where\", \"exclude\", \"include\")\n            i = 0\n            for arg in item.args:\n                if isinstance(arg.keyword, cst.Name):\n                    args[names.index(arg.keyword.value)] = self.evaluate_in_scope(\n                        arg.value, scope\n                    )\n                else:\n                    args[i] = self.evaluate_in_scope(arg.value, scope)\n                    i += 1\n\n            # TODO clear ones that are still default\n            return FindPackages(*args)\n        elif (\n            isinstance(item, cst.Call)\n            and isinstance(item.func, cst.Name)\n            and item.func.value == \"dict\"\n        ):\n            d = {}\n            for arg in item.args:\n                if isinstance(arg.keyword, cst.Name):\n                    d[arg.keyword.value] = self.evaluate_in_scope(arg.value, scope)\n                # TODO something with **kwargs\n            return d\n        elif isinstance(item, cst.Dict):\n            d = {}\n            for el2 in item.elements:\n                if isinstance(el2, cst.DictElement):\n                    d[self.evaluate_in_scope(el2.key, scope)] = self.evaluate_in_scope(\n                        el2.value, scope\n                    )\n            return d\n        elif isinstance(item, cst.Subscript):\n            lhs = self.evaluate_in_scope(item.value, scope)\n            if isinstance(lhs, str):\n                # A \"??\" entry, propagate\n                return \"??\"\n\n            # TODO: Figure out why this is Sequence\n            if isinstance(item.slice[0].slice, cst.Index):\n                rhs = self.evaluate_in_scope(item.slice[0].slice.value, scope)\n                try:\n                    if isinstance(lhs, dict):\n                        return lhs.get(rhs, \"??\")\n                    else:\n                        return lhs[rhs]\n                except Exception:\n                    return \"??\"\n\n            else:\n                # LOG.warning(f\"Omit2 {type(item.slice[0].slice)!r}\")\n                return \"??\"\n        elif isinstance(item, cst.BinaryOperation):\n            lhs = self.evaluate_in_scope(item.left, scope)\n            rhs = self.evaluate_in_scope(item.right, scope)\n            if isinstance(item.operator, cst.Add):\n                try:\n                    return lhs + rhs\n                except Exception:\n                    return \"??\"\n            else:\n                return \"??\"\n        else:\n            # LOG.warning(f\"Omit1 {type(item)!r}\")\n            return \"??\"\n"
  },
  "InsightSoftwareConsortium/ITKMinimalPathExtraction": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-minimalpathextraction',\n    version='1.2.6',\n    author='Insight Software Consortium',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKMinimalPathExtraction',\n    description=r'A minimal path extraction framework based on Fast Marching arrival functions.',\n    long_description='itk-minimalpathextraction provides a minimal path '\n                     'extraction framework based on Fast Marching arrival '\n                     'functions.\\n'\n                     'Please refer to:\\n'\n                     'Mueller, D. \"Fast Marching Minimal Path Extraction in ITK\", '\n                     'Insight Journal, January-June 2008, https://hdl.handle.net/1926/1332.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://github.com/InsightSoftwareConsortium/ITKMinimalPathExtraction',\n    install_requires=[\n        r'itk>=v5.3.0'\n    ]\n    )\n"
  },
  "kokkos/pykokkos-base": {
    "setup.py": "#!/usr/bin/env python\n\nimport os\nimport sys\nimport argparse\nimport warnings\nimport platform\nfrom skbuild import setup\n\n# some Cray systems default to static libraries and the build\n# will fail because BUILD_SHARED_LIBS will get set to off\nif os.environ.get(\"CRAYPE_VERSION\") is not None:\n    os.environ[\"CRAYPE_LINK_TYPE\"] = \"dynamic\"\n\ncmake_args = [\n    f\"-DPYTHON_EXECUTABLE:FILEPATH={sys.executable}\",\n    f\"-DPython3_EXECUTABLE:FILEPATH={sys.executable}\",\n    \"-DCMAKE_INSTALL_RPATH_USE_LINK_PATH:BOOL=ON\",\n]\n\nparser = argparse.ArgumentParser(add_help=False)\nparser.add_argument(\"-h\", \"--help\", help=\"Print help\", action=\"store_true\")\n\n\ndef set_cmake_bool_option(opt, enable_opt, disable_opt):\n    global cmake_args\n    try:\n        if enable_opt:\n            cmake_args.append(f\"-D{opt}:BOOL=ON\")\n        if disable_opt:\n            cmake_args.append(f\"-D{opt}:BOOL=OFF\")\n    except Exception as e:\n        print(f\"Exception: {e}\")\n\n\ndef add_arg_bool_option(lc_name, disp_name, default=None):\n    global parser\n    # enable option\n    parser.add_argument(\n        f\"--enable-{lc_name}\",\n        action=\"store_true\",\n        default=default,\n        help=f\"Explicitly enable {disp_name} build\",\n    )\n    # disable option\n    parser.add_argument(\n        f\"--disable-{lc_name}\",\n        action=\"store_true\",\n        help=f\"Explicitly disable {disp_name} build\",\n    )\n\n\n# add options\nadd_arg_bool_option(\"experimental\", \"ENABLE_EXPERIMENTAL\")\nadd_arg_bool_option(\"layouts\", \"ENABLE_LAYOUTS\")\nadd_arg_bool_option(\"memory-traits\", \"ENABLE_MEMORY_TRAITS\")\nadd_arg_bool_option(\"thin-lto\", \"ENABLE_THIN_LTO\")\nadd_arg_bool_option(\"werror\", \"ENABLE_WERROR\")\nadd_arg_bool_option(\"timing\", \"ENABLE_TIMING\")\nparser.add_argument(\n    \"--cxx-standard\",\n    default=14,\n    type=int,\n    choices=[14, 17, 20],\n    help=\"Set C++ language standard\",\n)\nparser.add_argument(\n    \"--enable-view-ranks\",\n    default=None,\n    type=int,\n    choices=[1, 2, 3, 4, 5, 6, 7],\n    help=\"Maximum number of concrete view ranks\",\n)\nparser.add_argument(\n    \"--kokkos-root\",\n    default=None,\n    type=str,\n    help=\"Path to kokkos install prefix\",\n)\nparser.add_argument(\n    \"--cmake-args\",\n    default=[],\n    type=str,\n    nargs=\"*\",\n    help=\"{}{}{}\".format(\n        \"Pass arguments to cmake. Use w/ pip installations\",\n        \"and --install-option, e.g. --install-option=--cmake-args=\",\n        '\"-DENABLE_LAYOUTS=ON -DKokkos_DIR=/usr/local/lib/cmake/Kokkos\"',\n    ),\n)\n\nargs, left = parser.parse_known_args()\n# if help was requested, print these options and then add '--help' back\n# into arguments so that the skbuild/setuptools argparse catches it\nif args.help:\n    parser.print_help()\n    left.append(\"--help\")\nsys.argv = sys.argv[:1] + left\n\nset_cmake_bool_option(\n    \"ENABLE_EXPERIMENTAL\", args.enable_experimental, args.disable_experimental\n)\nset_cmake_bool_option(\"ENABLE_LAYOUTS\", args.enable_layouts, args.disable_layouts)\nset_cmake_bool_option(\n    \"ENABLE_MEMORY_TRAITS\",\n    args.enable_memory_traits,\n    args.disable_memory_traits,\n)\nset_cmake_bool_option(\"ENABLE_THIN_LTO\", args.enable_thin_lto, args.disable_thin_lto)\nset_cmake_bool_option(\"ENABLE_WERROR\", args.enable_werror, args.disable_werror)\nset_cmake_bool_option(\"ENABLE_TIMING\", args.enable_timing, args.disable_timing)\n\ncmake_args.append(f\"-DCMAKE_CXX_STANDARD={args.cxx_standard}\")\n\nfor itr in args.cmake_args:\n    cmake_args += itr.split()\n\nif args.enable_view_ranks is not None:\n    cmake_args += [f\"-DENABLE_VIEW_RANKS={args.enable_view_ranks}\"]\n\nif args.kokkos_root is not None:\n    os.environ[\"CMAKE_PREFIX_PATH\"] = \":\".join(\n        [args.kokkos_root, os.environ.get(\"CMAKE_PREFIX_PATH\", \"\")]\n    )\n\nif platform.system() == \"Darwin\":\n    # scikit-build will set this to 10.6 and C++ compiler check will fail\n    darwin_version = platform.mac_ver()[0].split(\".\")\n    darwin_version = \".\".join([darwin_version[0], darwin_version[1]])\n    cmake_args += [f\"-DCMAKE_OSX_DEPLOYMENT_TARGET={darwin_version}\"]\n\n# DO THIS LAST!\n# support PYKOKKOS_BASE_SETUP_ARGS environment variables because\n#  --install-option for pip is a pain to use\n# PYKOKKOS_BASE_SETUP_ARGS should be space-delimited set of cmake arguments, e.g.:\n#   export PYKOKKOS_BASE_SETUP_ARGS=\"-DENABLE_LAYOUTS=OFF -DENABLE_MEMORY_TRAITS=ON\"\nenv_cmake_args = os.environ.get(\"PYKOKKOS_BASE_SETUP_ARGS\", None)\nif env_cmake_args is not None:\n    cmake_args += env_cmake_args.split(\" \")\n\n\n# --------------------------------------------------------------------------- #\n#\ndef get_project_version():\n    # open \"VERSION\"\n    with open(os.path.join(os.getcwd(), \"VERSION\"), \"r\") as f:\n        data = f.read().replace(\"\\n\", \"\")\n    # make sure is string\n    if isinstance(data, list) or isinstance(data, tuple):\n        return data[0]\n    else:\n        return data\n\n\n# --------------------------------------------------------------------------- #\n#\ndef get_long_description():\n    long_descript = \"\"\n    try:\n        long_descript = open(\"README.md\").read()\n    except Exception:\n        long_descript = \"\"\n    return long_descript\n\n\n# --------------------------------------------------------------------------- #\n#\ndef parse_requirements(fname=\"requirements.txt\"):\n    _req = []\n    requirements = []\n    # read in the initial set of requirements\n    with open(fname, \"r\") as fp:\n        _req = list(filter(bool, (line.strip() for line in fp)))\n    # look for entries which read other files\n    for itr in _req:\n        if itr.startswith(\"-r \"):\n            # read another file\n            for fitr in itr.split(\" \"):\n                if os.path.exists(fitr):\n                    requirements.extend(parse_requirements(fitr))\n        else:\n            # append package\n            requirements.append(itr)\n    # return the requirements\n    return requirements\n\n\n# suppress:\n#  \"setuptools_scm/git.py:68: UserWarning: \"/.../<PACKAGE>\"\n#       is shallow and may cause errors\"\n# since 'error' in output causes CDash to interpret warning as error\nwith warnings.catch_warnings():\n    print(\"CMake arguments: {}\".format(\" \".join(cmake_args)))\n    setup(\n        name=\"pykokkos-base\",\n        packages=[\"kokkos\"],\n        version=get_project_version(),\n        cmake_args=cmake_args,\n        cmake_languages=(\"C\", \"CXX\"),\n        long_description=get_long_description(),\n        long_description_content_type=\"text/markdown\",\n        install_requires=parse_requirements(\"requirements.txt\"),\n        project_urls={\"kokkos\": \"https://github.com/kokkos/kokkos\"},\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools < 60.0.0\",\n    \"setuptools_scm >= 2.0.0\",\n    \"wheel >= 0.29.0\",\n    \"scikit-build >= 0.8.0\",\n    \"cmake >= 3.16.0\",\n]\nbuild-backend = 'setuptools.build_meta'\n\n[tool.black]\nline-length = 88\ntarget-version = ['py35', 'py36', 'py37', 'py38']\ninclude = '\\.pyi?'\nexclude = '''\n/(\n    \\.eggs\n  | \\.git\n  | \\.hg\n  | \\.mypy_cache\n  | \\.tox\n  | \\.venv\n  | _build\n  | buck-out\n  | build\n  | dist\n  | external\n  | scripts\n  | _skbuild\n  | __pycache__\n  | \\.pyc\n  | \\.pytest_cache\n)/\n'''\n",
    "setup.cfg": "[metadata]\nname = pykokkos-base\nurl = http://github.com/kokkos/kokkos-python\ndownload_url = http://github.com/kokkos/kokkos-python.git\nproject_urls = http://github.com/kokkos/kokkos-python.git\nauthor = Jonathan R. Madsen\nauthor_email = jrmadsen@lbl.gov\nmaintainer = Jonathan R. Madsen\nmaintainer_email = jrmadsen@lbl.gov\nlicense = BSD 3-Clause License\ndescription = Python bindings to Kokkos Views for data interop\nkeywords =\n    kokkos\n    parallelism\n    performance\n    performance portability\n    gpu\n    cuda\n    hip\n    rocm\n    hpx\n    openmp\n    openmptarget\n    sycl\n    serial\nclassifiers =\n    Development Status :: 4 - Beta\n    Environment :: GPU\n    Environment :: GPU :: NVIDIA CUDA\n    Intended Audience :: Developers\n    Intended Audience :: Science/Research\n    Natural Language :: English\n    License :: OSI Approved :: BSD License\n    Operating System :: MacOS\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Operating System :: POSIX :: BSD\n    Operating System :: Unix\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Topic :: Scientific/Engineering\n\n[options]\npackages = kokkos\nzip_safe = false\ninclude_package_data = false\nsetup_requires =\n    scikit-build\n    cmake>=3.16\n\n[flake8]\nignore =\n    F403,\n    F405\nexclude =\n    .git,\n    __pycache__,\n    docs,\n    old,\n    build,\n    dist,\n    _skbuild,\n    external,\nmax-complexity = 20\nmax-line-length = 90\n"
  },
  "equinor/oneseismic": {
    "python/setup.py": "#!/usr/bin/env python3\n\nimport skbuild\n\nif __name__ == \"__main__\":\n    skbuild.setup(\n        packages = [\n            'oneseismic',\n            'oneseismic.internal',\n            'oneseismic.simple',\n            'oneseismic.decoding',\n            'oneseismic.scan',\n            'oneseismic.upload',\n        ],\n    )\n",
    "python/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools >= 40\",\n    \"scikit-build\",\n    \"wheel\",\n    \"pybind11\",\n]\n\n[tool.cibuildwheel]\nbefore-all = [\n    \"\"\"curl \\\n        -L https://github.com/msgpack/msgpack-c/releases/download/cpp-3.3.0/msgpack-3.3.0.tar.gz \\\n        -o msgpack-3.3.0.tar.gz \\\n    \"\"\",\n    \"tar xf msgpack-3.3.0.tar.gz\",\n    \"\"\"cmake \\\n        -S msgpack-3.3.0  \\\n        -B msgpack-3.3.0/build \\\n        -DMSGPACK_CXX_ONLY=ON \\\n        -DMSGPACK_BUILD_DOCS=OFF \\\n        -DCMAKE_INSTALL_PREFIX=core/ \\\n    \"\"\",\n    \"\"\"cmake \\\n        --build msgpack-3.3.0/build \\\n        --target install \\\n        --config Release \\\n    \"\"\",\n]\n\n# To make sure that dependencies are built for the right arch (i686, amd64 etc)\n# then the host arch is added onto the build dir. This *must* be expanded by\n# cibuildwheel since the build host (runner) might be different than the target\n# emulated by the docker image. Ideally there would be a variable that holds\n# what's currently being compiled, but I've yet to find it.\n#\n# Since the command is issued through subprocess.run() then it runs on the\n# system native shell, which means all sorts of problems if that shell is\n# cmd.exe, since it doesn't understand substitution $(). On windows you change\n# the default shell by setting COMSPEC to either bash or powershell (or\n# something else that understands $()), but there is little to gain from\n# running cibuildwheel on a non-CI windows.\nbefore-build = [\n    \"\"\"cmake \\\n        -S core/ \\\n        -B \"cibw-$(python -c 'import platform; print(platform.machine())')/\" \\\n        -DCMAKE_BUILD_TYPE=Release \\\n        -DCMAKE_POSITION_INDEPENDENT_CODE=ON \\\n        -DBUILD_TESTING=OFF \\\n        -DBUILD_CORE=OFF \\\n    \"\"\",\n    \"\"\"cmake \\\n        --build \"cibw-$(python -c 'import platform; print(platform.machine())')/\" \\\n        --parallel \\\n        --target install \\\n        --config Release \\\n    \"\"\",\n]\n\n[tool.cibuildwheel.macos]\nenvironment = { CXXFLAGS=\"-L/usr/local/lib\" }\n",
    "python/setup.cfg": "[metadata]\nname = oneseismic\ndescription = oneseismic\nlong_description = file: README.rst\nlong_description_content_type = text/x-rst\nlicense = LGPL-3.0\nurl = https://github.com/equinor/oneseismic\nversion = 0.4.0\n\n[options]\ninstall_requires =\n    azure-storage-blob\n    azure-identity\n    gql\n    numpy\n    requests\n    segyio\n    tqdm\n    xarray\n    importlib-metadata >= '1.0'; python_version < '3.8'\n\ntests_require =\n    hypothesis\n    pytest\n    pytest-runner\n    segyio\n\n[aliases]\ntest = pytest\n"
  },
  "MrGolden1/sort-python": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    name=\"sort-tracker\",\n    version=\"1.0.7\",\n    description=\"SORT tracker\",\n    author='M.Ali Zarrinzade',\n    author_email=\"ali.zarrinzadeh@gmail.com\",\n    packages=['sort'],\n    install_requires = [\n        'numpy',\n    ],\n    # python_requires=\">=3.7\",\n    long_description=open(\"README.md\").read(),\n    long_description_content_type=\"text/markdown\",\n    license=\"GPL-3.0\",\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Intended Audience :: Science/Research',\n        'Programming Language :: Python :: 3',\n    ],\n    url=\"https://github.com/MrGolden1/sort-python\",\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/MrGolden1/sort-python/issues\",\n    },\n)",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build>=0.13\",\n    \"cmake>=3.18\",\n    \"ninja\",\n    \"numpy\",\n]\nbuild-backend = \"setuptools.build_meta\""
  },
  "anibali/tvl": {
    "tvl_backends/tvl-backends-fffr/setup.py": "import os\nfrom distutils import log\nfrom pathlib import Path\n\nfrom skbuild import setup\nfrom skbuild.command.clean import clean\n\nversion = Path(__file__).absolute().parent.joinpath('VERSION').read_text('utf-8').strip()\n\n\nclass CustomClean(clean):\n    FILES_TO_REMOVE = ['MANIFEST']\n\n    def run(self):\n        super().run()\n        for filename in self.FILES_TO_REMOVE:\n            if os.path.isfile(filename):\n                log.info(\"removing '%s'\", filename)\n            else:\n                log.debug(\"'%s' does not exist -- can't clean it\", filename)\n            if not self.dry_run and os.path.exists(filename):\n                os.remove(filename)\n\n\nsetup(\n    name='tvl-backends-fffr',\n    version=version,\n    author='Aiden Nibali, Matthew Oliver',\n    license='Apache Software License 2.0',\n    packages=['tvl_backends.fffr'],\n    package_dir={'': 'src'},\n    include_package_data=True,\n    py_modules=['pyfffr'],\n    install_requires=[\n        'tvl==' + version,\n        'numpy',\n        'torch',\n    ],\n    cmdclass={'clean': CustomClean},\n)\n",
    "tvl_backends/tvl-backends-fffr/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake >= 3.17\", \"ninja\"]\n",
    "tvl_backends/tvl-backends-nvdec/setup.py": "import os\nfrom distutils import log\nfrom pathlib import Path\n\nfrom skbuild import setup\nfrom skbuild.command.clean import clean\n\nversion = Path(__file__).absolute().parent.joinpath('VERSION').read_text('utf-8').strip()\n\n\nclass CustomClean(clean):\n    FILES_TO_REMOVE = ['MANIFEST']\n\n    def run(self):\n        super().run()\n        for filename in self.FILES_TO_REMOVE:\n            if os.path.isfile(filename):\n                log.info(\"removing '%s'\", filename)\n            else:\n                log.debug(\"'%s' does not exist -- can't clean it\", filename)\n            if not self.dry_run and os.path.exists(filename):\n                os.remove(filename)\n\nsetup(\n    name='tvl-backends-nvdec',\n    version=version,\n    author='Aiden Nibali',\n    license='Apache Software License 2.0',\n    packages=['tvl_backends.nvdec'],\n    package_dir={'': 'src'},\n    include_package_data=True,\n    py_modules=['tvlnv'],\n    install_requires=[\n        'tvl==' + version,\n        'numpy',\n        'torch',\n    ],\n    cmdclass={'clean': CustomClean},\n)\n",
    "tvl_backends/tvl-backends-nvdec/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake >= 3.17\", \"ninja\"]\n"
  },
  "cbritopacheco/rodin": {
    "setup.py": "import os\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\n\nsetup(\n    name=\"rodin\",\n    version=\"0.0.1\",\n    description=\"Rodin Python bindings\",\n    author=\"Carlos Brito-Pacheco\",\n    license=\"Boost\",\n    packages=find_packages(where=\"py\"),\n    package_dir={\"\": \"py\"},\n    # cmake_install_dir=\"rodin/py\",\n    include_package_data=True,\n    python_requires=\">=3.6\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=60.6.0\",\n    \"pybind11~=2.10.0\",\n    \"cmake>=3.12\",\n    \"scikit-build>=0.15.0\",\n    \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\"\n\n"
  },
  "rakytap/sequential-quantum-gate-decomposer": {
    "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jun 26 14:42:56 2020\nCopyright (C) 2020 Peter Rakyta, Ph.D.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see http://www.gnu.org/licenses/.\n\n@author: Peter Rakyta, Ph.D.\n\"\"\"\n## \\file setup.py\n## \\brief Building script for the SQUANDER package\n\n\n\nfrom skbuild import setup\nfrom setuptools import find_packages\n\n\nsetup(\n    name=\"squander\",\n    packages=find_packages(\n        exclude=(\n            \"test_standalone\", \"test_standalone.*\",\n        )\n    ),\n    version='1.8.1',\n    url=\"https://github.com/rakytap/sequential-quantum-gate-decomposer\", \n    maintainer=\"Peter Rakyta\",\n    maintainer_email=\"peter.rakyta@ttk.elte.hu\",\n    include_package_data=True,\n    install_requires=[\n        \"setuptools>=40.8.0\",\n        \"wheel\",\n        \"scikit-build\",          \n        \"ninja\",\n        \"scipy\",\n    ],\n    tests_require=[\"pytest\"],\n    description='The C++ binding for the SQUANDER package',\n    long_description=open(\"./README.md\", 'r').read(),\n    long_description_content_type=\"text/markdown\",\n    keywords=\"test, cmake, extension\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Natural Language :: English\",\n        \"Programming Language :: C\",\n        \"Programming Language :: C++\"\n    ],\n    license='GNU General Public License v3.0',\n)\n\n\n\n\n\n\n",
    "pyproject.toml": "[build-system]\nrequires = [\n        \"setuptools>=40.8.0\",\n    \"wheel\",\n    \"scikit-build\",\n    \"ninja\",\n    \"scipy\", \n]\n\n\n\n"
  },
  "fastscape-lem/fastscapelib-fortran": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    name=\"fastscapelib-fortran\",\n    version=\"2.9.0dev\",\n    description=(\"A library of efficient algorithms\"\n                 \"for landscape evolution modeling\"),\n    author='Jean Braun',\n    license=\"GPLv3\",\n    packages=['fastscapelib_fortran'],\n    package_dir={\"\": \"src_python\"},\n    cmake_args=['-DBUILD_FASTSCAPELIB_STATIC=OFF',\n                '-DUSE_FLEXURE=ON'],\n    cmake_languages=('C', 'Fortran'),\n    cmake_minimum_required_version='3.5'\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"numpy\"]\n"
  },
  "Maximilian-Winter/pytonium": {
    "src/pytonium_python_framework/setup.py": "import shutil\nimport os\nfrom skbuild import setup\nfrom os import listdir\nfrom pathlib import Path\nfrom os.path import isfile, join\nimport zipfile\n\nlinux_bin_folder = \"bin_linux\"\nwindows_bin_folder = \"bin_win\"\nis_sdist_release = False\n\nif 'RELEASE_SDIST' in os.environ:\n    is_sdist_release = True\n\npytonium_manifest_file_list = []\npytonium_packages = ['Pytonium']\n\nif os.path.exists('./Pytonium/test/cache'):\n    shutil.rmtree('./Pytonium/test/cache')\n\n\ndef compress_binaries(os_bin_folder):\n    if not isfile(f\"./Pytonium/{os_bin_folder}.zip\") and is_sdist_release:\n        print(\"Building Pytonium Release\")\n        print(\"Creating Pytonium binaries zip file...\")\n        compression_out = zipfile.ZIP_LZMA\n        linux_bin_zip_file = zipfile.ZipFile(f\"./Pytonium/{os_bin_folder}.zip\", mode=\"w\")\n\n        pytonium_binaries_path = f\"./Pytonium/{os_bin_folder}/\"\n        binaries = [f for f in listdir(pytonium_binaries_path) if isfile(join(pytonium_binaries_path, f))]\n\n        pytonium_locales_path = f\"./Pytonium/{os_bin_folder}/locales/\"\n        locales_files = [f for f in listdir(pytonium_locales_path) if isfile(join(pytonium_locales_path, f))]\n        try:\n            for file_to_write in binaries:\n                linux_bin_zip_file.write(pytonium_binaries_path + file_to_write, file_to_write, compress_type=compression_out)\n                os.remove(pytonium_binaries_path + file_to_write)\n                open(pytonium_binaries_path + file_to_write, 'x').close()\n\n            for file_to_write in locales_files:\n                linux_bin_zip_file.write(pytonium_locales_path + file_to_write, \"locales/\" + file_to_write,\n                         compress_type=compression_out)\n                os.remove(pytonium_locales_path + file_to_write)\n                open(pytonium_locales_path + file_to_write, 'x').close()\n\n        except FileNotFoundError as e:\n            print(f' *** Exception occurred during zip process - {e}')\n        finally:\n            linux_bin_zip_file.close()\n    else:\n        print(\"Scanning the Pytonium binaries...\")\n        pytonium_binaries_path = f\"./Pytonium/{os_bin_folder}/\"\n        binaries = [f for f in listdir(pytonium_binaries_path) if isfile(join(pytonium_binaries_path, f))]\n\n        for file_to_write in binaries:\n            if is_sdist_release:\n                os.remove(pytonium_binaries_path + file_to_write)\n                open(pytonium_binaries_path + file_to_write, 'x').close()\n\n        pytonium_locales_path = f\"./Pytonium/{os_bin_folder}/locales/\"\n        locales_files = [f for f in listdir(pytonium_locales_path) if isfile(join(pytonium_locales_path, f))]\n\n        for file_to_write in locales_files:\n            if is_sdist_release:\n                os.remove(pytonium_locales_path + file_to_write)\n                open(pytonium_locales_path + file_to_write, 'x').close()\n\n\ndef generate_package_list_and_manifest_file_list(os_bin_folder):\n    if is_sdist_release:\n        pytonium_manifest_file_list.append(f'./Pytonium/{os_bin_folder}.zip')\n        pytonium_manifest_file_list.append(\"CMakeLists.txt\")\n        for path in Path('./Pytonium').rglob('*'):\n            if isfile(path):\n                pytonium_manifest_file_list.append(str(path))\n            else:\n                pytonium_packages.append(str(path).replace(\"/\", \".\"))\n    else:\n        pytonium_manifest_file_list.append(f'./Pytonium/{os_bin_folder}.zip')\n        pytonium_packages.append(f\"Pytonium.{os_bin_folder}\")\n        pytonium_packages.append(\"Pytonium.test\")\n        pytonium_packages.append(f\"Pytonium.{os_bin_folder}.locales\")\n        for path in Path(f'./Pytonium/{os_bin_folder}').rglob('*'):\n            if os.name == 'nt':\n                if isfile(path) and not str(path).endswith('.so'):\n                    pytonium_manifest_file_list.append(str(path))\n            else:\n                if isfile(path) and not str(path).endswith('.dll'):\n                    pytonium_manifest_file_list.append(str(path))\n\n        for path in Path('./Pytonium/test').rglob('*'):\n            if isfile(path):\n                pytonium_manifest_file_list.append(str(path))\n\n\ndef generate_manifest_file():\n    with open('./MANIFEST.in', 'w') as fp:\n\n        for item in pytonium_manifest_file_list:\n            fp.write(\"include %s\\n\" % item)\n\n\ndef extract_bin_zip(bin_folder):\n    pytonium_path = os.path.abspath(__file__)\n    pytonium_path = os.path.dirname(pytonium_path)\n    pytonium_path += \"/Pytonium\"\n    pytonium_bin_zip_path = f'{pytonium_path}/{bin_folder}.zip'\n\n    if os.path.exists(pytonium_bin_zip_path):\n        print(\"Extracting the Pytonium binaries...\")\n        compression = zipfile.ZIP_LZMA\n        with zipfile.ZipFile(pytonium_bin_zip_path, compression=compression, mode='r') as zip_ref:\n            zip_ref.extractall(f'{pytonium_path}/{bin_folder}')\n            zip_ref.close()\n\n\nif is_sdist_release:\n    extract_bin_zip(\"bin_linux\")\n    extract_bin_zip(\"bin_win\")\nelse:\n    if os.name == \"nt\":\n        extract_bin_zip(\"bin_win\")\n    else:\n        extract_bin_zip(\"bin_linux\")\n\n\nif os.path.exists('./Pytonium/src/cef-binaries-linux/Release/libcef.so'):\n    os.remove('./Pytonium/src/cef-binaries-linux/Release/libcef.so')\n\nif is_sdist_release:\n    generate_package_list_and_manifest_file_list(\"bin_win\")\n    generate_package_list_and_manifest_file_list(\"bin_linux\")\nelse:\n    if os.name == \"nt\":\n        generate_package_list_and_manifest_file_list(\"bin_win\")\n    else:\n        generate_package_list_and_manifest_file_list(\"bin_linux\")\n\ngenerate_manifest_file()\n\nif is_sdist_release:\n    compress_binaries(\"bin_win\")\n    compress_binaries(\"bin_linux\")\nelse:\n    if os.name == \"nt\":\n        compress_binaries(\"bin_win\")\n    else:\n        compress_binaries(\"bin_linux\")\n\n\nshutil.copyfile('./Pytonium/bin_linux/libcef.so', 'Pytonium/src/cef-binaries-linux/Release/libcef.so')\n\nsetup(\n    name='Pytonium',\n    packages=pytonium_packages,\n    cmake_args=['-DUSE_SANDBOX=OFF'],\n    include_package_data=True\n)\n\nif is_sdist_release:\n    extract_bin_zip(\"bin_linux\")\n    extract_bin_zip(\"bin_win\")\nelse:\n    if os.name == \"nt\":\n        extract_bin_zip(\"bin_win\")\n    else:\n        extract_bin_zip(\"bin_linux\")\n\n\n\n\n#import shutil\n#import os\n#from skbuild import setup\n#from os import listdir\n#from pathlib import Path\n#from os.path import isfile, join\n#import zipfile\n#\n#is_sdist_release = False\n#\n#if 'RELEASE_SDIST' in os.environ:\n#    is_sdist_release = True\n#\n#pytonium_manifest_file_list = []\n#pytonium_packages = ['Pytonium']\n#\n#if os.path.exists('./Pytonium/test/cache'):\n#    shutil.rmtree('./Pytonium/test/cache')\n#\n#\n#def compress_binaries(bin_folder):\n#    if not isfile(f\"./Pytonium/{bin_folder}.zip\") and is_sdist_release:\n#        print(\"Building Pytonium Release\")\n#        print(\"Creating Pytonium binaries zip file...\")\n#        compression_out = zipfile.ZIP_LZMA\n#        zf = zipfile.ZipFile(f\"./Pytonium/{bin_folder}.zip\", mode=\"w\")\n#\n#        pytonium_binaries_path = f\"./Pytonium/{bin_folder}/\"\n#        binaries = [f for f in os.listdir(pytonium_binaries_path) if isfile(join(pytonium_binaries_path, f))]\n#\n#        pytonium_locales_path = f\"./Pytonium/{bin_folder}/locales/\"\n#        locales_files = [f for f in os.listdir(pytonium_locales_path) if isfile(join(pytonium_locales_path, f))]\n#        try:\n#            for file_to_write in binaries:\n#                zf.write(pytonium_binaries_path + file_to_write, file_to_write, compress_type=compression_out)\n#                os.remove(pytonium_binaries_path + file_to_write)\n#                open(pytonium_binaries_path + file_to_write, 'x').close()\n#\n#            for file_to_write in locales_files:\n#                zf.write(pytonium_locales_path + file_to_write, \"locales/\" + file_to_write,\n#                         compress_type=compression_out)\n#                os.remove(pytonium_locales_path + file_to_write)\n#                open(pytonium_locales_path + file_to_write, 'x').close()\n#\n#        except FileNotFoundError as e:\n#            print(f' *** Exception occurred during zip process - {e}')\n#        finally:\n#            zf.close()\n#    else:\n#        if is_sdist_release:\n#            print(\"Scanning the Pytonium binaries...\")\n#            pytonium_binaries_path = f\"./Pytonium/{bin_folder}/\"\n#            binaries = [f for f in os.listdir(pytonium_binaries_path) if isfile(join(pytonium_binaries_path, f))]\n#\n#            for file_to_write in binaries:\n#                if is_sdist_release:\n#                    os.remove(pytonium_binaries_path + file_to_write)\n#                    open(pytonium_binaries_path + file_to_write, 'x').close()\n#\n#            pytonium_locales_path = f\"./Pytonium/{bin_folder}/locales/\"\n#            locales_files = [f for f in os.listdir(pytonium_locales_path) if isfile(join(pytonium_locales_path, f))]\n#\n#            for file_to_write in locales_files:\n#                if is_sdist_release:\n#                    os.remove(pytonium_locales_path + file_to_write)\n#                    open(pytonium_locales_path + file_to_write, 'x').close()\n#\n#\n#def generate_manifest_file():\n#    if is_sdist_release:\n#        pytonium_manifest_file_list.append('Pytonium/bin_win.zip')\n#        pytonium_manifest_file_list.append('Pytonium/bin_linux.zip')\n#        pytonium_manifest_file_list.append(\"CMakeLists.txt\")\n#        for path in Path('./Pytonium').rglob('*'):\n#            if isfile(path):\n#                pytonium_manifest_file_list.append(str(path))\n#            else:\n#                pytonium_packages.append(str(path).replace(\"/\", \".\"))\n#    else:\n#\n#        if os.name == \"nt\":\n#            os_bin_folder = \"bin_win\"\n#            pytonium_manifest_file_list.append('Pytonium/bin_win.zip')\n#\n#        else:\n#            os_bin_folder = \"bin_linux\"\n#            pytonium_manifest_file_list.append('Pytonium/bin_linux.zip')\n#\n#        pytonium_packages.append(f\"Pytonium.{os_bin_folder}\")\n#        pytonium_packages.append(\"Pytonium.test\")\n#        pytonium_packages.append(f\"Pytonium.{os_bin_folder}.locales\")\n#        for path in Path(f'./Pytonium/{os_bin_folder}').rglob('*'):\n#            if os.name == 'nt':\n#                if isfile(path) and not str(path).endswith('.so'):\n#                    pytonium_manifest_file_list.append(str(path))\n#            else:\n#                if isfile(path) and not str(path).endswith('.dll'):\n#                    pytonium_manifest_file_list.append(str(path))\n#\n#        for path in Path('./Pytonium/test').rglob('*'):\n#            if isfile(path):\n#                pytonium_manifest_file_list.append(str(path))\n#\n#    with open('./MANIFEST.in', 'w') as fp:\n#\n#        for item in pytonium_manifest_file_list:\n#            fp.write(\"include %s\\n\" % item)\n#\n#\n#if os.path.exists('./Pytonium/src/cef-binaries-linux/Release/libcef.so'):\n#    os.remove('./Pytonium/src/cef-binaries-linux/Release/libcef.so')\n#\n#generate_manifest_file()\n#shutil.copyfile('./Pytonium/bin_linux/libcef.so', './Pytonium/src/cef-binaries-linux/Release/libcef.so')\n#\n#if is_sdist_release:\n#    compress_binaries(\"bin_win\")\n#    compress_binaries(\"bin_linux\")\n#else:\n#    if os.name == \"nt\":\n#        compress_binaries(\"bin_win\")\n#    else:\n#        compress_binaries(\"bin_linux\")\n#\n#setup(\n#    name='Pytonium',\n#    packages=pytonium_packages,\n#    cmake_args=['-DUSE_SANDBOX=OFF'],\n#    include_package_data=True\n#)\n#\n#pytonium_path = os.path.abspath(__file__)\n#pytonium_path = os.path.dirname(pytonium_path)\n#\n#if is_sdist_release:\n#    pytonium_bin_zip_path = f'{pytonium_path}/bin_win.zip'\n#    if os.path.exists(pytonium_bin_zip_path):\n#        compression = zipfile.ZIP_LZMA\n#        with zipfile.ZipFile(pytonium_bin_zip_path, compression=compression, mode='r') as zip_ref:\n#            zip_ref.extractall(f'{pytonium_path}/bin_win')\n#            zip_ref.close()\n#\n#    pytonium_bin_zip_path = f'{pytonium_path}/bin_linux.zip'\n#    if os.path.exists(pytonium_bin_zip_path):#\n#        compression = zipfile.ZIP_LZMA\n#        with zipfile.ZipFile(pytonium_bin_zip_path, compression=compression, mode='r') as zip_ref:\n#            zip_ref.extractall(f'{pytonium_path}/bin_linux')\n#            zip_ref.close()\n#\n#else:\n#\n#    if os.name == \"nt\":\n#        os_bin_folder = \"bin_win\"\n#    else:\n#        os_bin_folder = \"bin_linux\"\n#\n#    pytonium_bin_zip_path = f'{pytonium_path}/{os_bin_folder}.zip'\n#    if os.path.exists(pytonium_bin_zip_path):\n#        compression = zipfile.ZIP_LZMA\n#        with zipfile.ZipFile(pytonium_bin_zip_path, compression=compression, mode='r') as zip_ref:\n#            zip_ref.extractall(f'{pytonium_path}/{os_bin_folder}')\n#            zip_ref.close()\n#",
    "src/pytonium_python_framework/pyproject.toml": "[build-system]\nrequires = [  \"setuptools>=42\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\", \"Cython>=3.0.0a11\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"Pytonium\"\nversion = \"0.0.9\"\ndescription = \"A framework for building python apps, with a GUI based on the web-technologies HTML, CSS and Javascript.\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nclassifiers = [ \"Programming Language :: Python :: 3\", \"License :: OSI Approved :: BSD License\", \"Operating System :: Microsoft :: Windows\", \"Operating System :: POSIX :: Linux\"]\n[[project.authors]]\nname = \"Maximilian Winter\"\nemail = \"maximilian.winter.91@gmail.com\"\n\n[project.urls]\nHomepage = \"https://github.com/Maximilian-Winter/pytonium\"\n\"Bug Tracker\" = \"https://github.com/Maximilian-Winter/pytonium/issues\"\n"
  },
  "theengs/explorer": {
    "setup.py": "from pathlib import Path\n\nfrom skbuild import setup\n\n# Read the contents of the README file\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\nsetup(\n    name=\"TheengsExplorer\",\n    version=\"version_tag\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"Theengs\",\n    url=\"https://github.com/theengs/explorer\",\n    license=\"GPL-3.0 License\",\n    package_dir={\"TheengsExplorer\": \"TheengsExplorer\"},\n    packages=[\"TheengsExplorer\"],\n    include_package_data=True,\n    install_requires=[\"TheengsDecoder>=0.4.0\", \"textual>=0.1.15\", \"bluetooth-numbers>=0.1.1\", \"bleak>=0.17.0\", \"humanize>=4.4.0\"],\n)\n"
  },
  "dumux/dumux": {
    "setup.py": "# SPDX-FileCopyrightInfo: Copyright \u00a9 DuMux Project contributors, see AUTHORS.md in root folder\n# SPDX-License-Identifier: GPL-3.0-or-later\n\ntry:\n    from dune.packagemetadata import metaData\nexcept ImportError:\n    from packagemetadata import metaData\nfrom setuptools import find_namespace_packages\nfrom skbuild import setup\n\n# When building a new package, update the version numbers below and run:\n# > python setup.py sdist\n# > python -m twine upload dist/*\n\ndumuxVersion = \"3.4.0.dev20210308\"\nduneVersion = \"2.8.0.dev20210308\"\n\nmetadata = metaData(duneVersion)[1]\nmetadata[\"version\"] = dumuxVersion\nmetadata[\"long_description\"] = metadata[\"long_description\"].replace(\n    \"doc/logo/dumux_logo_hires_whitebg.png\", \"https://dumux.org/images/logo.svg\"\n)\nmetadata[\"packages\"] = find_namespace_packages(where=\"python\", include=[\"dumux.*\"])\n\n# auto-generate pyproject.toml with duneVersion when building sdist\nfrom skbuild.command.sdist import sdist\n\n\nclass mysdist(sdist):\n    def run(self):\n        requires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"requests\"]\n        requires += metadata[\"install_requires\"]\n        with open(\"pyproject.toml\", \"w\") as f:\n            f.write(\"[build-system]\\n\")\n            f.write(\"requires = ['\" + \"', '\".join(requires) + \"']\\n\")\n            f.write(\"build-backend = 'setuptools.build_meta'\\n\")\n        sdist.run(self)\n\n\nmetadata[\"cmdclass\"] = {\"sdist\": mysdist}\n\nsetup(**metadata)\n",
    "pyproject.toml": "[build-system]\nrequires = ['setuptools', 'wheel', 'scikit-build', 'cmake', 'ninja', 'requests', 'dune-common<=2.8.0.dev20201218', 'dune-grid<=2.8.0.dev20201218', 'dune-localfunctions<=2.8.0.dev20201218', 'dune-istl<=2.8.0.dev20201218']\nbuild-backend = 'setuptools.build_meta'\n\n[tool.black]\nline-length = 100\n"
  },
  "Narasimha1997/py_cpu": {
    "setup.py": "from skbuild import setup\n\nlong_description = open('README.md').read()\n\nsetup(\n    name=\"py_cpu\",\n    version=\"0.1.2\",\n    author=\"Narasimha Prasanna HN\",\n    author_email=\"narasimhaprasannahn@gmail.com\",\n    description=\"Python bindings for Google's cpu_features library.\",\n    url=\"https://github.com/Narasimha1997/py_cpu.git\",\n    license=\"Apache 2.0 License\",\n    has_package_data=False,\n    package_dir={\"\": \"src\"},\n    packages = [\"py_cpu\"],\n    cmake_install_dir = \"src/py_cpu\",\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Developers',\n        'Topic :: System :: Hardware',\n        'License :: OSI Approved :: Apache Software License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.9',      \n    ],\n    python_requires='>=3',\n    long_description = long_description,\n    long_description_content_type = 'text/markdown'\n)",
    "pyproject.toml": "\n[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"cmake\",\n    \"scikit-build\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "SafeRoboticsLab/Safe_Occlusion_Aware_Planning": {
    "ThirdParty/octomap-python/setup.py": "import subprocess\nimport sys\n\nfrom setuptools import Extension\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef install_packages(*requirements):\n    # No more convenient way until PEP 518 is implemented;\n    # setuptools only handles eggs\n    subprocess.check_call(\n        [sys.executable, \"-m\", \"pip\", \"install\"] + list(requirements)\n    )\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef get_or_install(name, version=None):\n    # Do not import 3rd-party modules into the current process\n    import json\n    js_packages = json.loads(\n        subprocess.check_output(\n            [sys.executable, \"-m\", \"pip\", \"list\", \"--format\", \"json\"]\n        ).decode('ascii'))  # valid names & versions are ASCII as per PEP 440\n    try:\n        [package] = (\n            package for package in js_packages if package['name'] == name\n        )\n    except ValueError:\n        install_packages(\"%s==%s\" % (name, version) if version else name)\n        return version\n    else:\n        return package['version']\n\n\ndef get_long_description():\n    with open('README.md') as f:\n        long_description = f.read()\n\n    try:\n        import github2pypi\n        return github2pypi.replace_url(\n            slug='wkentaro/octomap-python', content=long_description\n        )\n    except Exception:\n        return long_description\n\n\ndef main():\n    get_or_install('cython')\n    get_or_install('numpy')\n    get_or_install('scikit-build')\n\n    from Cython.Distutils import build_ext\n    import numpy\n    import skbuild\n\n    ext_modules = [\n        Extension(\n            'octomap',\n            ['octomap/octomap.pyx'],\n            include_dirs=[\n                'src/octomap/octomap/include',\n                'src/octomap/dynamicEDT3D/include',\n                numpy.get_include(),\n            ],\n            library_dirs=[\n                'src/octomap/lib',\n            ],\n            libraries=[\n                'dynamicedt3d',\n                'octomap',\n                'octomath',\n            ],\n            language='c++',\n        )\n    ]\n\n    skbuild.setup(\n        name='octomap-python',\n        version='1.8.0.post12',\n        install_requires=['numpy'],\n        extras_require={\n            'example': ['glooey', 'imgviz>=1.2.0', 'pyglet', 'trimesh[easy]'],\n        },\n        license='BSD',\n        maintainer='Kentaro Wada',\n        maintainer_email='www.kentaro.wada@gmail.com',\n        url='https://github.com/wkentaro/octomap-python',\n        description='Python binding of the OctoMap library.',\n        long_description=get_long_description(),\n        long_description_content_type='text/markdown',\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Intended Audience :: Developers',\n            'Natural Language :: English',\n            'Programming Language :: Python',\n            'Programming Language :: Python :: 2',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: Implementation :: CPython',\n            'Programming Language :: Python :: Implementation :: PyPy',\n        ],\n        ext_modules=ext_modules,\n        cmdclass={'build_ext': build_ext},\n        cmake_source_dir='src/octomap',\n    )\n\n\nif __name__ == '__main__':\n    main()\n",
    "ThirdParty/octomap-python/setup.cfg": "[flake8]\nexclude=.anaconda*,examples/legacy,tests,src\n"
  },
  "Barkhausen-Institut/hermespy": {
    "setup.py": "from skbuild import setup\nfrom setuptools import find_namespace_packages\nfrom sphinx.setup_command import BuildDoc\n\ncmdclass = {'build_sphinx': BuildDoc}\n\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name=\"hermespy\",\n    version=\"1.0.0\",\n    author=\"Jan Adler\",\n    author_email=\"jan.adler@barkhauseninstitut.org\",\n    description=\"The Heterogeneous Radio Mobile Simulator\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/Barkhausen-Institut/hermespy\",\n    project_urls={\n        \"Documentation\": \"https://hermespy.org/\",\n        \"Barkhausen Institute\": \"https://www.barkhauseninstitut.org\",\n        \"Bug Tracker\": \"https://github.com/Barkhausen-Institut/hermespy/issues\",\n    },\n    classifiers=[\n        \"Programming Language :: Python :: 3.9\",\n        \"License :: OSI Approved :: GNU Affero General Public License v3\",\n        \"Operating System :: OS Independent\",\n        \"Development Status :: 4 - Beta\",\n        \"Natural Language :: English\",\n        \"Topic :: Scientific/Engineering\",\n    ],\n    packages=find_namespace_packages(include=['hermespy.*']),\n    package_data={\n        'hermespy.core': ['styles/*.mplstyle'],\n        'hermespy.channel': ['res/*'],\n    },\n    include_package_data=True,\n    exclude_package_data={\n        '': ['3rdparty', 'tests'],\n    },\n    extras_require={\n        \"test\": ['pytest', 'coverage'],\n        \"quadriga\": [\"oct2py\"],\n        \"documentation\": [\n            'sphinx-autodoc-typehints',\n            'sphinxcontrib-apidoc',\n            'sphinxcontrib-mermaid',\n            'sphinxcontrib-bibtex',\n            'sphinx-rtd-theme',\n            'sphinx-rtd-dark-mode',\n            'sphinx-tabs',\n            'sphinx-copybutton',\n            'sphinx-carousel',\n            'nbsphinx',\n            'ipywidgets',\n            'scikit-build',\n        ],\n        \"uhd\": ['usrp-uhd-client>=0.0.1'],\n        \"audio\": ['sounddevice'],\n        \"develop\": [\n            \"pybind11\",\n            \"scikit-build\",\n            \"cmake\",\n            \"sphinx\",\n            \"wheel\",\n            \"black\",\n            \"flake8\",\n        ]\n    },\n    zip_safe=False,\n    python_requires=\">=3.9\",\n    entry_points={\n        'console_scripts': ['hermes=hermespy.bin:hermes'],\n    },\n    install_requires=[\n        'matplotlib>=3.5.2',\n        'h5py~=3.7.0',\n        'numpy>=1.21.6',\n        'scipy~=1.9.3',\n        'pybind11~=2.10.1',\n        'ray~=2.1.0',\n        'ruamel.yaml~=0.17.21',\n        'sparse~=0.13.0',\n        'numba~=0.56.4',\n        'sphinx~=5.3.0',\n        'rich~=12.6.0',\n        'ZODB~=5.7.0',\n    ],\n    command_options={\n        'build_sphinx': {\n            'project': ('setup.py', 'HermesPy'),\n            'version': ('setup.py', '1.0.0'),\n            # 'release': ('setup.py', release),\n            'source_dir': ('setup.py', 'docssource'),\n            'build_dir': ('setup.py', 'documentation'),\n        }\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"sphinx\",\n    \"wheel\",\n    \"pybind11\",\n    \"scikit-build\",\n    \"cmake\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 400\ntarget-version = ['py39']"
  },
  "wolfmanstout/talon-gaze-ocr": {
    ".subtrees/rapidfuzz/setup.py": "import os\n\ndef show_message(*lines):\n    print(\"=\" * 74)\n    for line in lines:\n        print(line)\n    print(\"=\" * 74)\n\nwith open('README.md', 'rt', encoding=\"utf8\") as f:\n    readme = f.read()\n\nsetup_args = {\n    \"name\": \"rapidfuzz\",\n    \"version\": \"2.4.3\",\n    \"install_requires\": [\"jarowinkler >= 1.2.0, < 2.0.0\"],\n    \"extras_require\": {'full': ['numpy']},\n    \"url\": \"https://github.com/maxbachmann/RapidFuzz\",\n    \"author\": \"Max Bachmann\",\n    \"author_email\": \"pypi@maxbachmann.de\",\n    \"description\": \"rapid fuzzy string matching\",\n    \"long_description\": readme,\n    \"long_description_content_type\": \"text/markdown\",\n\n    \"license\": \"MIT\",\n    \"classifiers\": [\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"License :: OSI Approved :: MIT License\"\n    ],\n\n    \"packages\": [\"rapidfuzz\", \"rapidfuzz.distance\"],\n    \"package_dir\": {\n        '': 'src',\n    },\n    \"package_data\": {\n        \"rapidfuzz\": [\"*.pyi\", \"py.typed\"],\n        \"rapidfuzz.distance\": [\"*.pyi\"]\n    },\n    \"python_requires\": \">=3.6\"\n}\n\ndef run_setup(with_binary):\n    if with_binary:\n        from skbuild import setup\n        import rapidfuzz_capi\n\n        setup(\n            **setup_args,\n            cmake_args=[\n                f'-DRF_CAPI_PATH:STRING={rapidfuzz_capi.get_include()}'\n            ]\n        )\n    else:\n        from setuptools import setup\n        setup(**setup_args)\n\n# when packaging only build wheels which include the C extension\npackaging = \"1\" in {\n    os.environ.get(\"CIBUILDWHEEL\", \"0\"),\n    os.environ.get(\"CONDA_BUILD\", \"0\"),\n    os.environ.get(\"RAPIDFUZZ_BUILD_EXTENSION\", \"0\")\n}\nif packaging:\n    run_setup(True)\nelse:\n    try:\n        run_setup(True)\n    except:\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Failure information, if any, is above.\",\n            \"Retrying the build without the C extension now.\",\n        )\n        run_setup(False)\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Plain-Python build succeeded.\",\n        )\n",
    ".subtrees/rapidfuzz/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13.0\",\n    \"Cython==3.0.0a11\",\n    \"rapidfuzz_capi==1.0.5\"\n]\nbuild-backend = \"backend\"\nbackend-path = [\"_custom_build\"]\n",
    ".subtrees/jarowinkler/setup.py": "import os\n\ndef show_message(*lines):\n    print(\"=\" * 74)\n    for line in lines:\n        print(line)\n    print(\"=\" * 74)\n\nwith open('README.md', 'rt', encoding=\"utf8\") as f:\n    readme = f.read()\n\nsetup_args = {\n    \"name\": \"jarowinkler\",\n    \"version\": \"1.2.0\",\n    \"url\": \"https://github.com/maxbachmann/JaroWinkler\",\n    \"author\": \"Max Bachmann\",\n    \"author_email\": \"pypi@maxbachmann.de\",\n    \"description\": \"library for fast approximate string matching using Jaro and Jaro-Winkler similarity\",\n    \"long_description\": readme,\n    \"long_description_content_type\": \"text/markdown\",\n\n    \"license\": \"MIT\",\n    \"classifiers\": [\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"License :: OSI Approved :: MIT License\"\n    ],\n\n    \"packages\": [\"jarowinkler\"],\n    \"package_dir\": {'': 'src'},\n    \"package_data\": {\"jarowinkler\": [\"*.pyi\", \"py.typed\"]},\n    \"python_requires\": \">=3.6\"\n}\n\ndef run_setup(with_binary):\n    if with_binary:\n        from skbuild import setup\n        import rapidfuzz_capi\n\n        setup(\n            **setup_args,\n            cmake_args=[\n                f'-DRF_CAPI_PATH:STRING={rapidfuzz_capi.get_include()}'\n            ]\n        )\n    else:\n        from setuptools import setup\n        setup(**setup_args)\n\n# when packaging only build wheels which include the C extension\npackaging = \"1\" in {\n    os.environ.get(\"CIBUILDWHEEL\", \"0\"),\n    os.environ.get(\"CONDA_BUILD\", \"0\"),\n    os.environ.get(\"JAROWINKLER_BUILD_EXTENSION\", \"0\")\n}\nif packaging:\n    run_setup(True)\nelse:\n    try:\n        run_setup(True)\n    except:\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Failure information, if any, is above.\",\n            \"Retrying the build without the C extension now.\",\n        )\n        run_setup(False)\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Plain-Python build succeeded.\",\n        )\n",
    ".subtrees/jarowinkler/pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13.0\",\n    \"Cython==3.0.0a11\",\n    \"rapidfuzz_capi==1.0.5\"\n]\nbuild-backend = \"backend\"\nbackend-path = [\"_custom_build\"]\n"
  },
  "clEsperanto/pyclesperanto": {
    "setup.py": "import sys, os\n\nsys.path.append(os.path.dirname(__file__))\n\n# Get the version from the version file and the package description from the README file\nwith open(\"README.md\") as fp:\n    readme = fp.read()\n\nver_dic = {}\nversion_file = open(\"pyclesperanto/_version.py\")\ntry:\n    version_file_contents = version_file.read()\nfinally:\n    version_file.close()\n\nexec(compile(version_file_contents, \"pyclesperanto/_version.py\", \"exec\"), ver_dic)\n\nconda_prefix = os.environ.get('CONDA_PREFIX')\ncmake_args_list = [\n    \"-DCLIC_VERSION:String=\" + ver_dic[\"CLIC_VERSION\"]\n]\nif conda_prefix:\n    cmake_args_list.append(\"-DCMAKE_PREFIX_PATH:FILEPATH=\" + conda_prefix)\n\nfrom skbuild import setup\n\nsetup(\n    name=\"pyclesperanto\",\n    version=ver_dic[\"VERSION\"],\n    cmake_args=cmake_args_list,\n    author=\"Stephane Rigaud\",\n    author_email=\"stephane.rigaud@pasteur.fr\",\n    license=\"BSD-3-Clause\",\n    description=\"GPU-accelerated image processing in python using OpenCL\",\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n    packages=[\"pyclesperanto\"],\n    cmake_install_dir=\"pyclesperanto\",\n    python_requires=\">=3.7\",\n    install_requires=[\n        \"numpy\",\n        \"toolz\",\n        \"matplotlib\",\n    ],\n    classifiers=[\n        \"Development Status :: 2 - Pre-Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Scientific/Engineering :: Image Processing\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Operating System :: OS Independent\",\n        \"License :: OSI Approved :: BSD License\",\n    ],\n    project_urls={\n        \"Documentation\": \"https://github.com/clEsperanto/pyclesperanto#README.md\",\n        \"Source\": \"https://github.com/clEsperanto/pyclesperanto/\",\n        \"Issues\": \"https://github.com/clEsperanto/pyclesperanto/issues\",\n    },\n)\n\n# When building extension modules `cmake_install_dir` should always be set to the\n# location of the package you are building extension modules for.\n# Specifying the installation directory in the CMakeLists subtley breaks the relative\n# paths in the helloTargets.cmake file to all of the library components.\n",
    "pyproject.toml": "[build-system]\nbuild-backend = \"setuptools.build_meta\"\nrequires = [\n  \"setuptools\",\n  \"wheel\",\n  \"scikit-build>=0.16.4\",\n  \"cmake>=3.20\",\n  \"pybind11>=2.10.3\",\n]\n\n[tool.pytest.ini_options]\naddopts = \"-ra -q\"\ntestpaths = [\n  \"tests\",\n]\n\n[tool.cibuildwheel]\nbuild = [\"cp37-*\", \"cp38-*\", \"cp39-*\", \"cp310-*\", \"cp311-*\"]\nbuild-frontend = \"build\"\nbuild-verbosity = 1\ntest-command = \"pytest {project}/tests/test_import.py\"\ntest-requires = [\"numpy\", \"pytest\", \"pytest-cov\", \"pytest-benchmark\"]\n\n[tool.cibuildwheel.linux]\nbefore-all = [\n  \"yum install -y ruby\",\n  \"bash {package}/scripts/build-opencl-linux.sh\",\n]\nrepair-wheel-command = \"auditwheel show {wheel} && auditwheel repair --lib-sdir .libs -w {dest_dir} {wheel}\"\nskip = [\"cp27-*\", \"cp36-*\", \"pp*\", \"*-musllinux*\"]\n\n#[[tool.cibuildwheel.overrides]]\n#select = \"*-musllinux*\"\n#before-all = [\n#    \"apk add ruby\",\n#    \"bash {package}/scripts/build-ocl.sh\",\n#]\n\n[tool.cibuildwheel.windows]\nbefore-all = \"bash {package}/scripts/build-opencl-windows.sh\"\nenvironment = {SKBUILD_CONFIGURE_OPTIONS = \"-DOpenCL_LIBRARY:FILEPATH='C:/Program Files/OpenCL-ICD-Loader/lib/OpenCL.lib' -DOpenCL_LIBRARIES:FILEPATH='C:/Program Files/OpenCL-ICD-Loader/lib/OpenCL.lib' -DOpenCL_FOUND:BOOL=TRUE\"}\nskip = [\"cp27-*\", \"cp36-*\", \"pp*\", \"*-win32\"]\n\n[tool.cibuildwheel.macos]\nbefore-all = \"bash {package}/scripts/build-opencl-macos.sh\"\nenvironment = {MACOSX_DEPLOYMENT_TARGET = '10.14'}\nskip = [\"cp27-*\", \"cp36-*\", \"pp*\", \"*_universal2\"]\n"
  },
  "Nicholaswogan/fortran-cython-examples": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    name=\"fortran_cython_examples\",\n    version=\"0.1\",\n    description=\"a description\",\n    author='Nicholas Wogan',\n    license=\"MIT\",\n    packages=['fortran_cython_examples'],\n    install_requires=['cython','numpy'],\n    cmake_args=['-DSKBUILD=ON']\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\", \"cython\", \"numpy\"]\n"
  },
  "kaaengine/kaa": {
    "setup.py": "import os\n\nimport versioneer\nfrom skbuild import setup\n\n\nreadme_path = os.path.join(os.path.dirname(__file__), 'README.md')\nwith open(readme_path, 'rb') as fh:\n    readme_content = fh.read().decode('utf-8')\n\n\nKAA_SETUP_CMAKE_SOURCE = os.environ.get('KAA_SETUP_CMAKE_SOURCE', '')\n\nsetup(\n    name=\"kaaengine\",\n    author=\"labuzm, maniek2332\",\n    author_email=\"labuzm@gmail.com, maniek2332@gmail.com\",\n    version=versioneer.get_version(),\n    cmdclass=versioneer.get_cmdclass(),\n    python_requires=\">=3.5\",\n    description=\"Pythonic game engine for humans.\",\n    long_description=readme_content,\n    long_description_content_type='text/markdown',\n    url=\"https://github.com/kaaengine/kaa\",\n    packages=['kaa'],\n    package_dir={'': 'src'},\n    entry_points={\n        'console_scripts': [\n            'shaderc=kaa.cli:shaderc',\n            'compile_shader=kaa.cli:compile_shader'\n        ]\n    },\n    install_requires=[\n        \"parsy==1.3.0\",\n        \"dataclasses==0.8 ; python_version == '3.6'\"\n    ],\n    extras_require={\n        'stats_graph': [\n            'matplotlib>=3.1.1',\n        ]\n    },\n    license=\"MIT\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Topic :: Games/Entertainment\",\n        \"Topic :: Software Development\",\n    ],\n    project_urls={\n        \"Documentation\": 'https://kaa.readthedocs.io/en/latest/',\n        \"Source Code\": 'https://github.com/kaaengine/kaa/',\n    },\n    cmake_source_dir=KAA_SETUP_CMAKE_SOURCE,\n    package_data={\n      'kaa': ['*.pyi', 'py.typed'],\n    },\n    include_package_data=True,\n    cmake_args=[\n        '-DKAA_INSTALL_KAACORE:BOOL=OFF',\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=40\", \"wheel\", \"cython==0.29.21\", \"cmake>=3.13\", \"ninja\", \"scikit-build==0.11.1\", \"cymove==1.0.0\"]\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\n",
    "setup.cfg": "[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = src/kaa/_version.py\nversionfile_build = kaa/_version.py\ntag_prefix = v\n\n[pyhistory]\nhistory_dir = .pyhistory\nhistory_file = CHANGELOG.rst\n"
  },
  "cluster3d/cluster3d.github.io": {
    "baseline method/AtlasNet/auxiliary/sampling_and_meshing/O-CNN/virtual_scanner/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"ocnn.virtualscanner\",\n    version=\"18.09.05\",\n    description=\"Virtual scanner utilities\",\n    author='Microsoft',\n    author_email=\"dapisani@microsoft.com\",\n    packages=['ocnn', 'ocnn.virtualscanner'],\n    zip_safe=False,\n    install_requires=['Cython', 'pyyaml'],\n    package_dir={'': 'python'},\n    package_data={'ocnn.virtualscanner': ['*.pxd']}\n)\n"
  },
  "primitiv/primitiv-python": {
    "setup.py": "#!/usr/bin/env python3\n\nimport os\nimport sys\n\nfrom distutils.dir_util import copy_tree\nfrom setuptools.extension import Extension\n\nimport numpy as np\n\nfrom Cython.Build import build_ext\n\nVERSION = \"0.4.0\"\n\nSUBMODULE_DIR = \"primitiv-core\"\nEIGEN_DIR = \"eigen-headers\"\n\nSUBMODULE_CMAKELIST = os.path.join(SUBMODULE_DIR, \"CMakeLists.txt\")\nEIGEN_HEADER_DIR = os.path.join(EIGEN_DIR, \"Eigen\")\n\nbuild_number = os.getenv(\"PRIMITIV_PYTHON_BUILD_NUMBER\")\nif build_number is not None:\n    version_full = VERSION + \".\" + build_number\nelse:\n    version_full = VERSION\n\nbundle_eigen_headers = False\nif \"--bundle-eigen-headers\" in sys.argv:\n    i = sys.argv.index(\"--bundle-eigen-headers\")\n    sys.argv.pop(i)\n    eigen_path = sys.argv.pop(i)\n    copy_tree(eigen_path, EIGEN_DIR)\n    bundle_eigen_headers = True\n\ndirname = os.path.dirname(os.path.abspath(__file__))\n\nif \"--no-build-core-library\" in sys.argv:\n    build_core = False\n    sys.argv.remove(\"--no-build-core-library\")\nelse:\n    build_core = os.path.exists(os.path.join(dirname, SUBMODULE_CMAKELIST))\n\neigen_bundled_exists = os.path.exists(os.path.join(dirname, EIGEN_HEADER_DIR))\nif \"--disable-eigen\" in sys.argv:\n    enable_eigen = False\n    sys.argv.remove(\"--disable-eigen\")\nelse:\n    enable_eigen = eigen_bundled_exists\n\nif build_core:\n    import skbuild\n    from skbuild import setup\nelse:\n    from setuptools import setup\n\nbundle_core_library = False\nif \"--bundle-core-library\" in sys.argv:\n    if not build_core:\n        print(\"%s is not found\" % SUBMODULE_CMAKELIST, file=sys.stderr)\n        print(\"\", file=sys.stderr)\n        print(\"Run the following command to download primitiv core library:\",\n              file=sys.stderr)\n        print(\"  git submodule update --init\", file=sys.stderr)\n        print(\"\", file=sys.stderr)\n        sys.exit(1)\n    bundle_core_library = True\n    sys.argv.remove(\"--bundle-core-library\")\n\nenable_cuda = False\nif \"--enable-cuda\" in sys.argv:\n    enable_cuda = True\n    sys.argv.remove(\"--enable-cuda\")\n\nif \"--enable-eigen\" in sys.argv:\n    enable_eigen = True\n    sys.argv.remove(\"--enable-eigen\")\n\nenable_opencl = False\nif \"--enable-opencl\" in sys.argv:\n    enable_opencl = True\n    sys.argv.remove(\"--enable-opencl\")\n\n\ndef ext_common_args(*args, libraries=[], **kwargs):\n    if build_core:\n        libs = [\"primitiv\"]\n        libs.extend(libraries)\n        return Extension(\n            *args, **kwargs,\n            language=\"c++\",\n            libraries=libs,\n            library_dirs=[os.path.join(skbuild.constants.CMAKE_INSTALL_DIR, \"lib\")],\n            include_dirs=[\n                np.get_include(),\n                os.path.join(skbuild.constants.CMAKE_INSTALL_DIR, \"include\"),\n                os.path.join(dirname, \"primitiv\"),\n            ],\n            extra_compile_args=[\"-std=c++11\"],\n        )\n    else:\n        return Extension(\n            *args, **kwargs,\n            language=\"c++\",\n            libraries=[\"primitiv\"],\n            include_dirs=[\n                np.get_include(),\n                os.path.join(dirname, \"primitiv\"),\n            ],\n            extra_compile_args=[\"-std=c++11\"],\n        )\n\n\next_modules = [\n    ext_common_args(\"primitiv._shape\",\n                    sources=[\"primitiv/_shape.pyx\"]),\n    ext_common_args(\"primitiv._tensor\",\n                    sources=[\"primitiv/_tensor.pyx\"]),\n    ext_common_args(\"primitiv._device\",\n                    sources=[\"primitiv/_device.pyx\"]),\n    ext_common_args(\"primitiv.devices._naive_device\",\n                    sources=[\"primitiv/devices/_naive_device.pyx\"]),\n    ext_common_args(\"primitiv._parameter\",\n                    sources=[\"primitiv/_parameter.pyx\"]),\n    ext_common_args(\"primitiv._initializer\",\n                    sources=[\"primitiv/_initializer.pyx\"]),\n    ext_common_args(\"primitiv.initializers._initializer_impl\",\n                    sources=[\"primitiv/initializers/_initializer_impl.pyx\"]),\n    ext_common_args(\"primitiv._graph\",\n                    sources=[\"primitiv/_graph.pyx\"]),\n    ext_common_args(\"primitiv._optimizer\",\n                    sources=[\"primitiv/_optimizer.pyx\"]),\n    ext_common_args(\"primitiv.optimizers._optimizer_impl\",\n                    sources=[\"primitiv/optimizers/_optimizer_impl.pyx\"]),\n    ext_common_args(\"primitiv._function\",\n                    sources=[\"primitiv/_function.pyx\"]),\n    ext_common_args(\"primitiv._model\",\n                    sources=[\"primitiv/_model.pyx\"]),\n    ext_common_args(\"primitiv.config\",\n                    sources=[\"primitiv/config.pyx\"]),\n]\n\nif enable_cuda:\n    ext_modules.append(\n        ext_common_args(\n            \"primitiv.devices._cuda_device\",\n            libraries=[\n                \"cublas\",\n                \"cudart\",\n                \"curand\",\n                \"pthread\",\n                \"rt\",\n            ],\n            sources=[\"primitiv/devices/_cuda_device.pyx\"],\n        )\n    )\n\nif enable_eigen:\n    ext_modules.append(\n        ext_common_args(\n            \"primitiv.devices._eigen_device\",\n            sources=[\"primitiv/devices/_eigen_device.pyx\"],\n        )\n    )\n\nif enable_opencl:\n    ext_modules.append(\n        ext_common_args(\n            \"primitiv.devices._opencl_device\",\n            libraries=[\n                \"clblast\",\n                \"OpenCL\",\n            ],\n            sources=[\"primitiv/devices/_opencl_device.pyx\"],\n        )\n    )\n\nsetup_kwargs = {}\nif build_core:\n    setup_kwargs[\"cmake_source_dir\"] = SUBMODULE_DIR\n    setup_kwargs[\"cmake_install_dir\"] = \"./\"\n    setup_kwargs[\"setup_requires\"] = [\n        \"cmake>=0.9.0\",\n        \"cython>=0.29.5\",\n        \"scikit-build>=0.6.1\",\n    ]\n    setup_kwargs[\"cmake_args\"] = [\"-DPRIMITIV_BUILD_STATIC_LIBRARY=ON\"]\n    if sys.platform == \"darwin\":\n        # NOTE(vbkaisetsu):\n        # scikit-build adds -DCMAKE_OSX_DEPLOYMENT_TARGET with the default target if it does not\n        # set manually. However scikit-build does not check cmake_args argument of setup()\n        # for the target.\n        try:\n            cmake_args_pos = sys.argv.index(\"--\")\n        except ValueError:\n            cmake_args_pos = len(sys.argv)\n            sys.argv.append(\"--\")\n        sys.argv.insert(cmake_args_pos + 1, \"-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.12\")\n    if enable_cuda:\n        setup_kwargs[\"cmake_args\"].append(\"-DPRIMITIV_USE_CUDA=ON\")\n    if enable_eigen:\n        setup_kwargs[\"cmake_args\"].append(\"-DPRIMITIV_USE_EIGEN=ON\")\n        if eigen_bundled_exists:\n            setup_kwargs[\"cmake_args\"].append(\"-DEIGEN3_INCLUDE_DIR=%s\" % os.path.join(dirname, EIGEN_DIR))\n    if enable_opencl:\n        setup_kwargs[\"cmake_args\"].append(\"-DPRIMITIV_USE_OPENCL=ON\")\n\nwith open(os.path.join(dirname, \"MANIFEST.in\"), \"w\") as fp:\n    print(\"include README.md package_description.rst primitiv/py_optimizer.h\", file=fp)\n    print(\"recursive-include primitiv *.pyx *.pxd\", file=fp)\n    if bundle_core_library:\n        print(\"recursive-include %s *\" % SUBMODULE_DIR, file=fp)\n    if bundle_eigen_headers:\n        print(\"include %s/COPYING.* %s/README.md\" % (EIGEN_DIR, EIGEN_DIR), file=fp)\n        print(\"recursive-include %s *\" % EIGEN_HEADER_DIR, file=fp)\n\nsetup(\n    name=\"primitiv\",\n    version=version_full,\n    description=\"primitiv: A Neural Network Toolkit. (Python frontend)\",\n    long_description=open(os.path.join(dirname,\n                                       \"package_description.rst\")).read(),\n    url=\"https://github.com/primitiv/primitiv-python\",\n    author=\"primitiv developer group\",\n    author_email=\"primitiv-developer-group@googlegroups.com\",\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: POSIX\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    ],\n    ext_modules=ext_modules,\n    cmdclass={'build_ext': build_ext},\n    packages=[\n        \"primitiv\",\n        \"primitiv.devices\",\n        \"primitiv.initializers\",\n        \"primitiv.optimizers\",\n    ],\n    install_requires=[\n        \"numpy>=1.16.1\",\n    ],\n    **setup_kwargs,\n)\n",
    "setup.cfg": "[metadata]\ndescription-file = package_description.rst\n"
  },
  "tdegeus/cppcolormap": {
    "setup.py": "from pathlib import Path\n\nfrom setuptools_scm import get_version\nfrom skbuild import setup\n\nproject_name = \"cppcolormap\"\n\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\nsetup(\n    name=project_name,\n    description=\"Library with colormaps\",\n    long_description=\"Library with colormaps\",\n    keywords=\"colormap, plot, matplotlib\",\n    version=get_version(),\n    license=\"MIT\",\n    author=\"Tom de Geus\",\n    author_email=\"tom@geus.me\",\n    url=f\"https://github.com/tdegeus/{project_name}\",\n    packages=[f\"{project_name}\"],\n    package_dir={\"\": \"python\"},\n    cmake_install_dir=f\"python/{project_name}\",\n    cmake_minimum_required_version=\"3.13\",\n)\n"
  },
  "PrincetonUniversity/SPEC": {
    "setup.py": "#!/usr/bin/env python3\n\nimport os # environ\nimport sys\nimport json\nimport argparse\nimport setuptools\n\nfrom os.path import basename, splitext\nfrom glob import glob\nimport numpy\n\nprint(\"system.platform is {}\".format(sys.platform))\nif (sys.platform == \"darwin\"):\n    from distutils import sysconfig\n    vars = sysconfig.get_config_vars()\n    vars['LDSHARED'] = vars['LDSHARED'].replace('-bundle', '-dynamiclib')\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n# Load machine-specific options from cmake_config.json.\n# It should contain a dict with an array called cmake_args.\nwith open('cmake_config.json') as fp:\n    d = json.load(fp)\n\n# Include additional parameters from CMAKE_ARGS environment variable.\n# This is the way Anaconda tells CMake its specific needs.\nif 'CMAKE_ARGS' in os.environ:\n\n  print(\"CMAKE_ARGS = '%s'\"%(os.environ['CMAKE_ARGS']))\n  for cmake_arg in os.environ['CMAKE_ARGS'].split(\" \"):\n    d['cmake_args'].append(cmake_arg)\n\n# Tell CMake about where to find numpy libraries\n# see also: https://stackoverflow.com/a/14657667\nd['cmake_args'].append(\"-DCMAKE_C_FLAGS=-I\"+numpy.get_include())\n\nsetup(\n    name=\"spec\",\n    version=\"0.0.1\",\n    #license=\"MIT\",\n    packages=['spec'],\n    package_dir={'': 'Utilities/python_wrapper'},\n    #py_modules=[splitext(basename(path))[0] for path in glob('src/vmec/*.py')],\n    install_requires=['f90wrap', 'scikit-build'],\n    classifiers=[\n        \"Development Status :: 1 - Alpha\",\n        \"Intended Audience :: Nuclear Fusion Community\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Topic :: MHD Equilibrium Solver\"],\n    cmake_args=d['cmake_args'],\n)\n"
  },
  "tjol/ckdl": {
    "setup.py": "'''\n# ckdl - KDL reading and writing using a C backend\n\n**ckdl** is a C library that implements reading and writing a the\n[KDL Document Language](https://kdl.dev/).\n\nThis package lets Python programs read and write KDL files, using\n*ckdl* as a back-end.\n\nInstall with\n\n    pip install ckdl\n\n## Examples\n\n### Reading\n\n```pycon\n>>> import ckdl\n>>> kdl_txt = \"\"\"\n... best-primes 2 3 5 7\n... colours importance=(%)1000 { green; blue shade=\"\u0441\u0438\u043d\u0438\u0439\"; blue shade=\"\u0433\u043e\u043b\u0443\u0431\u043e\u0439\"; violet }\n... \"\"\"\n>>> doc = ckdl.parse(kdl_txt)\n>>> doc\n<Document; 2 nodes>\n>>> doc[0]\n<Node best-primes; 4 args>\n>>> doc[0].args\n[2, 3, 5, 7]\n>>> doc[1].properties\n{'importance': <Value (%)1000>}\n>>> doc[1].properties['importance'].value\n1000\n>>> doc[1].properties['importance'].type_annotation\n'%'\n>>> doc[1].children\n[<Node green>, <Node blue; 1 property>, <Node blue; 1 property>, <Node violet>]\n>>> doc[1].children[1].properties['shade']\n'\u0441\u0438\u043d\u0438\u0439'\n```\n\n### Writing\n\n```pycon\n>>> import ckdl\n>>> mydoc = ckdl.Document(ckdl.Node(\"best-primes\", 7, 11, 13), ckdl.Node(\"worst-primes\", ckdl.Value(\"undoubtedly\", 5)))\n>>> print(str(mydoc))\nbest-primes 7 11 13\nworst-primes (undoubtedly)5\n```\n'''\n\nfrom skbuild import setup\n\nsetup(\n    name=\"ckdl\",\n    version=\"0.1.1\",\n    description=\"KDL parser and writer with a C back-end\",\n    long_description=__doc__,\n    long_description_content_type=\"text/markdown\",\n    author=\"Thomas Jollans\",\n    url=\"https://github.com/tjol/ckdl\",\n    project_urls={\n        \"Documentation\": \"https://ckdl.readthedocs.io/\"\n    },\n    keywords=\"kdl parser configuration\",\n    classifiers = [\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3\"\n    ],\n    package_dir={\"\": \"bindings/python/src\"},\n    packages=[\"ckdl\"],\n    cmake_args=[\n        \"-DBUILD_TESTS:BOOL=OFF\",\n        \"-DBUILD_KDLPP:BOOL=OFF\",\n        \"-DCMAKE_POSITION_INDEPENDENT_CODE:BOOL=ON\",\n    ],\n    cmake_install_target=\"install-ckdl-py\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools>=42\",\n  \"scikit-build\",\n  \"cmake>=3.8\",\n  \"ninja; platform_system!='Windows'\",\n  \"cython\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "TkinterEP/python-tkextrafont": {
    "setup.py": "\"\"\"\nAuthor: RedFantom\nLicense: GNU GPLv3\nCopyright (c) 2021 RedFantom\n\"\"\"\nimport sys\n\n\ndef read(file_name):\n    with open(file_name) as fi:\n        contents = fi.read()\n    return contents\n\n\ndef printf(*args, **kwargs):\n    kwargs.update({\"flush\": True})\n    print(*args, **kwargs)\n\n\nif \"linux\" in sys.platform:\n    try:\n        from skbuild import setup\n        from skbuild.command.build import build\n    except ImportError:\n        printf(\"scikit-build is required to build this project\")\n        printf(\"install with `python -m pip install scikit-build`\")\n        raise\n\n\n    class BuildCommand(build):\n        \"\"\"\n        Intercept the build command to build the required modules in ./build\n\n        extrafont depends on a library built from source. Building this library\n        requires the following to be installed, Ubuntu package names:\n        - fontconfig\n        - libfontconfig1\n        - libfontconfig1-dev\n        - tcl-dev\n        - tk-dev\n        \"\"\"\n\n        def run(self):\n            build.run(self)\n\n\n    kwargs = {\n        \"install_requires\": [\"scikit-build\"], \"cmdClass\": {\"build\": BuildCommand},\n        \"package_data\": {\"tkextrafont\": [\"extrafont.tcl\", \"fontnameinfo.tcl\", \"futmp.tcl\", \"pkgIndex.tcl\"]}\n    }\n\nelif \"win\" in sys.platform:\n    import os\n    import shutil\n    from setuptools import setup\n    import subprocess as sp\n    from typing import List, Optional\n\n    dependencies = [\"cmake\", \"tk\", \"toolchain\", \"fontconfig\"]\n\n    for dep in dependencies:\n        printf(\"Installing dependency {}...\".format(dep), end=\" \")\n        sp.call([\"pacman\", \"--needed\", \"--noconfirm\", \"-S\", \"mingw-w64-x86_64-{}\".format(dep)])  # , stdout=sp.PIPE)\n        printf(\"Done.\")\n    sp.call([\"cmake\", \".\", \"-G\", \"MinGW Makefiles\"])\n    sp.call([\"mingw32-make\"])\n\n\n    class DependencyWalker(object):\n        \"\"\"\n        Walk the dependencies of a DLL file and find all DLL files\n\n        DLL files are searched for in all the directories specified by\n        - The PATH environment variable\n        - The DLL_SEARCH_PATHS environment variable\n        \"\"\"\n\n        def __init__(self, dll_file: str, dependencies_exe=\"deps\\\\dependencies.exe\", specials=dict()):\n            if not os.path.exists(dependencies_exe):\n                printf(\"dependencies.exe is required to find all dependency DLLs\")\n                raise FileNotFoundError(\"Invalid path specified for dependencies.exe\")\n            self._exe = dependencies_exe\n            if not os.path.exists(dll_file):\n                raise FileNotFoundError(\"'{}' does not specify a valid path to first file\".format(dll_file))\n            self._dll_file = dll_file\n            self._dll_cache = {}\n            self._specials = specials\n            self.walked = {}\n\n        @property\n        def dependency_dll_files(self) -> List[str]:\n            \"\"\"Return a list of abspaths to the dependency DLL files\"\"\"\n            printf(\"Walking dependencies of {}\".format(self._dll_file))\n            dlls = [self._dll_file] + list(map(self._find_dll_abs_path, self._specials.keys()))\n            done = []\n            while set(dlls) != set(done):  # As long as not all dlls are done, keep searching\n                for dll in set(dlls) - set(done):  # Go only over not-yet done DLLs\n                    if dll is None:\n                        done.append(None)\n                        continue\n                    printf(\"Looking for dependencies of {}\".format(dll))\n                    p = sp.Popen([self._exe, \"-imports\", dll], stdout=sp.PIPE)\n                    stdout, stderr = p.communicate()\n                    new_dlls = self._parse_dependencies_output(stdout)\n                    for new_dll in new_dlls:\n                        p = self._find_dll_abs_path(new_dll)\n                        if p is None:\n                            continue\n                        elif \"system32\" in p:\n                            continue\n                        elif p not in dlls:\n                            dlls.append(p)\n                    done.append(dll)\n            return list(set(dlls) - set((None,)))\n\n        @staticmethod\n        def _parse_dependencies_output(output: bytes) -> List[str]:\n            \"\"\"Parse the output of the dependencies.exe command\"\"\"\n            dlls: List[str] = list()\n            for line in map(str.strip, output.decode().split(\"\\n\")):\n                if not line.startswith(\"Import from module\"):\n                    continue\n                line = line[len(\"Import from module\"):].strip(\":\").strip()\n                dlls.append(line)\n            return dlls\n\n        def _find_dll_abs_path(self, dll_name: str) -> Optional[str]:\n            \"\"\"Find the absolute path of a specific DLL file specified\"\"\"\n            if dll_name in self._dll_cache:\n                return self._dll_cache[dll_name]\n            printf(\"Looking for path of {}...\".format(dll_name), end=\"\")\n            for var in (\"PATH\", \"DLL_SEARCH_DIRECTORIES\"):\n                printf(\".\", end=\"\")\n                val = os.environ.get(var, \"\")\n                for dir in val.split(\";\"):\n                    if not os.path.exists(dir) and os.path.isdir(dir):\n                        continue\n                    if dir not in self.walked:\n                        self.walked[dir] = list(os.walk(dir))\n                    for dirpath, subdirs, files in self.walked[dir]:\n                        if dll_name in files:\n                            p = os.path.join(dirpath, dll_name)\n                            printf(\" Found: {}\".format(p))\n                            self._dll_cache[dll_name] = p\n                            return p\n            printf(\"Not found.\")\n            self._dll_cache[dll_name] = None\n            return None\n\n        def copy_to_target(self, target: str):\n            for p in self.dependency_dll_files:\n                if os.path.basename(p) in self._specials:\n                    t = os.path.join(target, *self._specials[os.path.basename(p)].split(\"/\"), os.path.basename(p))\n                    d = os.path.dirname(t)\n                    if not os.path.exists(d):\n                        os.makedirs(d)\n                    printf(\"Copying special {} -> {}\".format(p, t))\n                    shutil.copyfile(p, t)\n                else:\n                    printf(\"Copying {}\".format(p))\n                    target_file = os.path.join(target, os.path.basename(p))\n                    try:\n                        shutil.copyfile(p, target_file)\n                    except shutil.SameFileError:\n                        continue\n\n\n    specials = {}\n    DependencyWalker(\"libextrafont.dll\", specials=specials).copy_to_target(\"tkextrafont\")\n    kwargs = {\"package_data\": {\n        \"tkextrafont\": [\"*.dll\", \"pkgIndex.tcl\", \"extrafont.tcl\", \"fontnameinfo.tcl\", \"futmp.tcl\"] + [\n            \"{}/{}\".format(dir.strip(\"/\"), base) for base, dir in specials.items()]}}\n\nelse:\n    printf(\"Only Linux and Windows are currently supported by the build system\")\n    printf(\"If you wish to help design a build method for your OS, please\")\n    printf(\"contact the project author.\")\n    raise RuntimeError(\"Unsupported platform\")\n\nsetup(\n    name=\"tkextrafont\",\n    version=\"v0.6.3\",\n    packages=[\"tkextrafont\"],\n    description=\"Fonts loader for Tkinter\",\n    author=\"The extrafont and tkextrafont authors\",\n    url=\"https://github.com/TkinterEP/tkextrafont\",\n    download_url=\"https://github.com/TkinterEP/tkextrafont/releases\",\n    license=\"GNU GPLv3\",\n    long_description=read(\"README.md\"),\n    long_description_content_type=\"text/markdown\",\n    zip_safe=False,\n    **kwargs\n)\n"
  },
  "dmpelt/foam_ct_phantom": {
    "setup.py": "#-----------------------------------------------------------------------\n#Copyright 2019 Centrum Wiskunde & Informatica, Amsterdam\n#\n#Author: Daniel M. Pelt\n#Contact: D.M.Pelt@cwi.nl\n#Website: http://dmpelt.github.io/foam_ct_phantom/\n#License: MIT\n#\n#This file is part of foam_ct_phantom, a Python package for generating\n#foam-like phantoms for CT.\n#-----------------------------------------------------------------------\n\nfrom skbuild import setup\nfrom setuptools import find_packages\nsetup(\n    name='foam_ct_phantom',\n    packages=find_packages(),\n    version=open('VERSION').read().strip(),\n    include_package_data=True,\n    cmake_languages=['C',],\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n    ],\n)\n"
  },
  "Nicholaswogan/PhotochemPy": {
    "setup.py": "from skbuild import setup\n\nfrom os import path\nthis_directory = path.abspath(path.dirname(__file__))\nwith open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup(\n    name=\"PhotochemPy\",\n    packages=['PhotochemPy'],\n    python_requires='>=3.7',\n    version=\"0.2.17\",\n    license=\"MIT\",\n    install_requires=['numpy>=1.21','scipy'],\n    author='Nicholas Wogan',\n    author_email = 'nicholaswogan@gmail.com',\n    description = \"Photochemical model of planet's atmospheres.\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url = \"https://github.com/Nicholaswogan/PhotochemPy\",\n    include_package_data=True,\n    cmake_args=['-DSKBUILD=ON',\\\n                '-DBUILD_F2PY_PHOTOCHEM=ON',\\\n                '-DBUILD_STATIC_PHOTOCHEM=OFF']\n)\n\n\n",
    "pyproject.toml": "[project]\nrequires-python = \">=3.7\"\n\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\", \"numpy>=1.21\"]\n",
    "setup.cfg": "[metadata]\nlicense_file = LICENSE.txt\ndescription-file = README.md"
  },
  "HITS-MCM/gromacs-ramd": {
    "python_packaging/src/setup.py": "#\n# This file is part of the GROMACS molecular simulation package.\n#\n# Copyright (c) 2019, by the GROMACS development team, led by\n# Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,\n# and including many others, as listed in the AUTHORS file in the\n# top-level source directory and at http://www.gromacs.org.\n#\n# GROMACS is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public License\n# as published by the Free Software Foundation; either version 2.1\n# of the License, or (at your option) any later version.\n#\n# GROMACS is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with GROMACS; if not, see\n# http://www.gnu.org/licenses, or write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA.\n#\n# If you want to redistribute modifications to GROMACS, please\n# consider that scientific software is very special. Version\n# control is crucial - bugs must be traceable. We will be happy to\n# consider code for inclusion in the official distribution, but\n# derived work must not be called official GROMACS. Details are found\n# in the README & COPYING files - if they are missing, get the\n# official version at http://www.gromacs.org.\n#\n# To help us fund GROMACS development, we humbly ask that you cite\n# the research papers on the package. Check out http://www.gromacs.org.\n\n# Python setuptools script to build and install the gmxapi Python interface\n# from a GROMACS installation directory.\n\n# Usage note: things go smoothly when we stick to the setup.py convention of\n# having a package source directory with the same name as the package at the\n# same level as the setup.py script and only expect `pip install .` in the\n# setup.py directory. If we play with the layout more, it is hard to keep all\n# of the `pip` and `setup.py` cases working as expected. This is annoying\n# because running the Python interpreter immediately from the same directory\n# can find the uninstalled source instead of the installed package. We can\n# ease this pain by building an sdist in the enclosing CMake build scope\n# and encouraging users to `pip install the_sdist.archive`. Otherwise, we\n# just have to document that we only support full build-install of the Python\n# package from the directory containing setup.py, which may clutter that\n# directory with some artifacts.\n\nimport os\n\nfrom skbuild import setup\n\nusage = \"\"\"\nThe `gmxapi` package requires an existing GROMACS installation, version 2020 or higher.\nTo specify the GROMACS installation to use, provide a GMXTOOLCHAINDIR\nenvironment variable when running setup.py or `pip`.\n\nExample:\n    GMXTOOLCHAINDIR=/path/to/gromacs/share/cmake/gromacs pip install gmxapi\n\nIf you have multiple builds of GROMACS, distinguished by a suffix `$SUFFIX`, the\ntool chain directory will use that suffix.\n\nExample:\n    GMXTOOLCHAINDIR=/path/to/gromacs/share/cmake/gromacs$SUFFIX pip install gmxapi\n\nIn the example, `gmxapi` is downloaded automatically from pypi.org. You can\nreplace `gmxapi` with a local directory or archive file to build from a source\ndistribution.\n\nsetup.py will use the location of GMXTOOLCHAINDIR to locate the\ngmxapi library configured during GROMACS installation. Alternatively, if\ngmxapi_DIR is provided, or if GMXRC has been \"sourced\", the toolchain file\nlocation may be deduced. Note, though, that if multiple GROMACS installations\nexist in the same location (with different suffixes) only the first one will be\nused when guessing a toolchain, because setup.py does not know which corresponds\nto the gmxapi support library.\n\nIf specifying GMXTOOLCHAINDIR and gmxapi_DIR, the tool chain directory must be \nlocated within a subdirectory of gmxapi_DIR.\n\nRefer to project web site for complete documentation.\n\n\"\"\"\n\n\nclass GmxapiInstallError(Exception):\n    \"\"\"Error processing setup.py for gmxapi Python package.\"\"\"\n\n\ngmx_toolchain_dir = os.getenv('GMXTOOLCHAINDIR')\ngmxapi_DIR = os.getenv('gmxapi_DIR')\nif gmxapi_DIR is None:\n    # Infer from GMXRC exports, if available.\n    gmxapi_DIR = os.getenv('GROMACS_DIR')\n\ndef _find_first_gromacs_suffix(directory):\n    dir_contents = os.listdir(directory)\n    for entry in dir_contents:\n        if entry.startswith('gromacs'):\n            return entry.strip('gromacs')\n\nif gmx_toolchain_dir is None:\n    # Try to guess from standard GMXRC environment variables.\n    if gmxapi_DIR is not None:\n        if os.path.exists(gmxapi_DIR) and os.path.isdir(gmxapi_DIR):\n            share_cmake = os.path.join(gmxapi_DIR, 'share', 'cmake')\n            suffix = _find_first_gromacs_suffix(share_cmake)\n            if suffix is not None:\n                gmx_toolchain_dir = os.path.join(share_cmake, 'gromacs' + suffix)\n\nif gmx_toolchain_dir is None:\n    print(usage)\n    raise GmxapiInstallError('Could not configure for GROMACS installation. Provide GMXTOOLCHAINDIR.')\n\nsuffix = os.path.basename(gmx_toolchain_dir).strip('gromacs')\ngmx_toolchain = os.path.abspath(os.path.join(gmx_toolchain_dir, 'gromacs-toolchain' + suffix + '.cmake'))\n\nif gmxapi_DIR is None:\n    # Example: given /usr/local/gromacs/share/cmake/gromacs/gromacs-toolchain.cmake,\n    # we would want /usr/local/gromacs.\n    # Note that we could point more directly to the gmxapi-config.cmake but,\n    # so far, we have relied on CMake automatically looking into\n    # <package>_DIR/share/cmake/<package>/ for such a file.\n    # We would need a slightly different behavior for packages that link against\n    # libgromacs directly, as sample_restraint currently does.\n    gmxapi_DIR = os.path.join(os.path.dirname(gmx_toolchain), '..', '..', '..')\n\ngmxapi_DIR = os.path.abspath(gmxapi_DIR)\n\nif not os.path.exists(gmxapi_DIR) or not os.path.isdir(gmxapi_DIR):\n    print(usage)\n    raise GmxapiInstallError('Please set a valid gmxapi_DIR.')\n\nif gmxapi_DIR != os.path.commonpath([gmxapi_DIR, gmx_toolchain]):\n    raise GmxapiInstallError('GROMACS toolchain file {} is not in gmxapi_DIR {}'.format(\n        gmx_toolchain,\n        gmxapi_DIR\n    ))\n\ncmake_platform_hints = '-DCMAKE_TOOLCHAIN_FILE={}'.format(gmx_toolchain)\n# Note that <package>_ROOT is not standard until CMake 3.12\n# Reference https://cmake.org/cmake/help/latest/policy/CMP0074.html#policy:CMP0074\ncmake_gmxapi_hint = '-Dgmxapi_ROOT={}'.format(gmxapi_DIR)\ncmake_args = [cmake_platform_hints, cmake_gmxapi_hint]\n\nsetup(\n    name='gmxapi',\n\n    # TODO: (pending infrastructure and further discussion) Replace with CMake variables from GMXAPI version.\n    version='0.1.0.1',\n    python_requires='>=3.5, <3.9',\n    setup_requires=['cmake>=3.12',\n                    'setuptools>=28',\n                    'scikit-build>=0.7'],\n\n    packages=['gmxapi', 'gmxapi.simulation'],\n\n    cmake_args=cmake_args,\n\n    author='M. Eric Irrgang',\n    author_email='info@gmxapi.org',\n    description='gmxapi Python interface for GROMACS',\n    license='LGPL',\n    url='http://gmxapi.org/',\n\n    # The installed package will contain compiled C++ extensions that cannot be loaded\n    # directly from a zip file.\n    zip_safe=False\n)\n"
  },
  "tilde-lab/pyfactxx": {
    "FaCT++.Python/setup.py": "#!/usr/bin/env python\n#\n# pyfactxx - Python interface to FaCT++ reasoner\n#\n# Copyright (C) 2016-2018 by Artur Wroblewski <wrobell@riseup.net>\n# Copyright (C) 2021-2022 by Ivan Rygaev <ir@tilde.pro>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n\nimport re\nimport ast\nimport pathlib\nfrom skbuild import setup\n\n\nroot = pathlib.Path(__file__).parent.resolve()\nDEBUG = False\n\n_version_re = re.compile(r'__version__\\s+=\\s+(.*)')\n\nwith open('pyfactxx/__init__.py', 'rb') as f:\n    version = str(ast.literal_eval(_version_re.search(\n        f.read().decode('utf-8')).group(1)))\n\nconfig = 'Debug' if DEBUG else 'Release'\ncmake_args = [\n    f'-DCMAKE_BUILD_TYPE={config}',\n    f'-DPYFACTXX_ROOT={root.as_posix()}'\n]\n\nsetup(\n    version=version,\n    packages=[\n        \"pyfactxx\",\n        \"pyfactxx.coras\"],\n    package_dir={\n        \"pyfactxx\": \"pyfactxx\", \n        \"pyfactxx.coras\": \"pyfactxx/coras\"},\n    cmake_source_dir=str(root/'pyfactxx'),\n    cmake_args=cmake_args\n)\n",
    "FaCT++.Python/pyproject.toml": "[build-system]\nrequires = [  \n  \"setuptools>=42\",\n  \"cython>0.25\",\n  \"wheel\",\n  \"scikit-build\",\n  \"cmake\",\n  \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"",
    "FaCT++.Python/setup.cfg": "[metadata]\nname = pyfactxx\ndescription = Python bindings to FaCT++ reasoner\nauthor = Artur Wroblewski\nauthor_email = wrobell@riseup.net\nmaintainer = Ivan Rygaev, Andrey Sobolev\nmaintainer_email = ir@tilde.pro\nurl = https://github.com/tilde-lab/pyfactxx\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nlicense = GNU GPL 3.0\nlicense_files = file: COPYING\nclassifiers =\n    Development Status :: 4 - Beta\n    Intended Audience :: Science/Research\n    Topic :: Scientific/Engineering :: Artificial Intelligence\n    License :: OSI Approved :: GNU General Public License v3 (GPLv3)\n    Programming Language :: C++\n    Programming Language :: Cython\n    Programming Language :: Lisp\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n\n[options]\nzip_safe = False\ninclude_package_data = True\npython_requires = >=3.7\ninstall_requires = rdflib\ntests_require = pytest, pytest-cov\n\n[sdist]\nformats = zip\n\n[tool:pytest]\naddopts = --cov=pyfactxx\n\n[coverage:report]\nshow_missing = 1\npartial_branches = 1\n\n"
  },
  "InsightSoftwareConsortium/ITKColorNormalization": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\nwith open(\"README.md\", \"r\") as fp:\n    readme = fp.read()\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"scikit-build is required to build from source.\", file=sys.stderr)\n    print(\"Please run:\", file=sys.stderr)\n    print(\"\", file=sys.stderr)\n    print(\"  python -m pip install scikit-build\")\n    sys.exit(1)\n\nsetup(\n    name=\"itk-spcn\",\n    version=\"0.2.0\",\n    author=\"Lee Newberg\",\n    author_email=\"lee.newberg@kitware.com\",\n    packages=[\"itk\"],\n    package_dir={\"itk\": \"itk\"},\n    description=r\"This performs structure preserving color normalization on an image using a reference image.\",\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\",\n    ],\n    license=\"Apache\",\n    keywords=\"ITK InsightToolkit\",\n    url=r\"https://github.com/InsightSoftwareConsortium/ITKColorNormalization/\",\n    install_requires=[r\"itk>=5.3.0\"],\n)\n"
  },
  "learnforpractice/pyeoskit": {
    "setup.py": "from skbuild import setup\nfrom distutils.sysconfig import get_python_lib\nimport platform\n\ndata = [\n        'data/*',\n        'contracts/eosio.bios/*',\n        'contracts/eosio.msig/*',\n        'contracts/eosio.system/*',\n        'contracts/eosio.token/*',\n        'contracts/eosio.wrap/*',\n        'contracts/micropython/*',\n        'test_template.py',\n]\n\nif platform.system() == 'Windows':\n    data.append(\"pyeoskit.dll\")\n\nsetup(\n    name=\"pyeoskit\",\n    version=\"1.1.12\",\n    description=\"Python Toolkit for EOS\",\n    author='learnforpractice',\n    license=\"MIT\",\n    url=\"https://github.com/learnforpractice/pyeoskit\",\n    packages=['pyeoskit'],\n    # The extra '/' was *only* added to check that scikit-build can handle it.\n    package_dir={'pyeoskit': 'pysrc'},\n    package_data={'pyeoskit': data\n    },\n    install_requires=[\n        'requests_unixsocket>=0.2.0',\n        'httpx>=0.19.0',\n        'base58>=2.1.1',\n        'asn1>=2.4.2',\n        'ledgerblue>=0.1.41'\n    ],\n    include_package_data=True\n)",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n\n",
    "setup.cfg": "[metadata]\nlong_description = file:README.md\nlong_description_content_type = text/markdown\n"
  },
  "MikePopoloski/pyslang": {
    "setup.py": "from subprocess import check_output\n\nfrom skbuild import setup\n\n\ndef get_git_version():\n    command = \"git describe --tags --long --dirty\"\n    try:\n        git_version = check_output(command.split(), cwd=\"slang\").decode(\"utf-8\").strip()\n    except Exception:\n        return None\n\n    if git_version.startswith(\"v\"):\n        git_version = git_version[1:]\n\n    parts = git_version.split(\"-\")\n    assert len(parts) in (3, 4)\n\n    tag, count = parts[:2]\n    return \"{}.{}\".format(tag, count)\n\n\ndef get_version():\n    # Try to read existing release version file.\n    try:\n        f = open(\"RELEASE-VERSION\", \"r\")\n        fs_version = f.readlines()[0].strip()\n    except Exception:\n        fs_version = None\n\n    # Get the version as described by git, if present.\n    version = get_git_version()\n    if version is None:\n        version = fs_version\n\n    if version is None:\n        raise ValueError(\"Cannot find the version number!\")\n\n    if version != fs_version:\n        f = open(\"RELEASE-VERSION\", \"w\")\n        f.write(\"{}\\n\".format(version))\n\n    return version\n\n\nsetup(\n    version=get_version(),\n    packages=[\"\"],\n    package_dir={\"\": \"slang\"},\n    cmake_source_dir=\"slang\",\n    cmake_install_dir=\"slang\",\n    cmake_install_target=\"pyslang-install-pylib\",\n    cmake_args=[\n        \"-DSLANG_INCLUDE_TESTS=OFF\",\n        \"-DSLANG_INCLUDE_TOOLS=OFF\",\n        \"-DSLANG_INCLUDE_PYLIB=ON\",\n    ],\n    extras_require={\"test\": [\"pytest\"]},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"pybind11>=2.10.0\",\n    \"cmake>=3.15\",\n    \"scikit-build>=0.15.0\",\n    \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\narchs = ['auto64']\nskip = ['pp*', 'cp36-*', '*musllinux*']\nbuild-verbosity = 1\ntest-command = \"pytest {project}/tests\"\ntest-extras = [\"test\"]\ntest-skip = [\"*universal2:arm64\"]\n",
    "setup.cfg": "[metadata]\nname = pyslang\n# version = <see setup.py>\ndescription = Python bindings for slang, a library for compiling SystemVerilog\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nurl = https://github.com/MikePopoloski/pyslang\nauthor = Mike Popoloski\nproject_urls =\n    Bug Tracker = https://github.com/MikePopoloski/slang/issues\n    Documentation = https://sv-lang.com/\n    Source Code = https://github.com/MikePopoloski/pyslang\nkeywords = slang, verilog, systemverilog, parsing, compiler, eda\nlicense = MIT\nlicense_files = LICENSE\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Developers\n    License :: OSI Approved :: MIT License\n    Operating System :: MacOS :: MacOS X\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Operating System :: Unix\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)\n    Topic :: Software Development :: Compilers\n    Topic :: Software Development :: Libraries :: Python Modules\n\n[options]\npython_requires = >=3.7\n"
  },
  "EthanJamesLew/f16-flight-dynamics": {
    "setup.py": "from skbuild import setup\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name=\"f16dynamics\",\n    version=\"0.0.1\",\n    author=\"Ethan Lew\",\n    author_email=\"ethanlew16@gmail.com\",\n    description=\"F16 Flight Dynamics\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    package_dir={\"\": \"python-bindings\"},\n    cmake_install_dir='python-bindings/f16dynamics',\n    packages=['f16dynamics'],\n    python_requires=\">=3.6\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    \"pybind11\",\n    \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\""
  },
  "terrierteam/pyterrier_pisa": {
    "setup.py": "import shutil\nfrom pathlib import Path\nimport sys\nimport os\nfrom setuptools import find_packages\nfrom skbuild import setup\nimport skbuild\nimport zipfile\nimport numpy as np\n\n\nclass bdist_wheel(skbuild.command.bdist_wheel.bdist_wheel):\n  def run(self):\n    res = super().run()\n    wheel = self.distribution.dist_files[0][2]\n    pisathon_so = list((Path(self.distribution.package_dir['pyterrier_pisa']).parent.parent).glob('**/_pisathon*.so'))[0]\n    lib_tbb = list((Path(self.distribution.package_dir['pyterrier_pisa']).parent.parent.parent).glob('**/libtbb.so.2'))[0]\n    print(f'patching wheel with {pisathon_so} and {lib_tbb}')\n    base_path = Path('/tmp/libtbb' if os.environ.get(\"PT_PISA_MANYLINUX\", \"False\") == \"True\" else '_skbuild/libtbb')\n    base_path.mkdir(exist_ok=True, parents=True)\n    shutil.copy(lib_tbb, base_path/lib_tbb.name)\n    shutil.copy(pisathon_so, base_path/pisathon_so.name)\n    return res\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name=\"pyterrier_pisa\",\n    version=\"0.0.4\" + os.environ.get('PT_PISA_VERSION_SUFFIX', ''),\n    description=\"A PyTerrier interface to the PISA search engine\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author='Sean MacAvaney',\n    license=\"\",\n    packages=find_packages(where='src'),\n    package_dir={'': 'src'},\n    include_package_data=True,\n    install_requires=['python-terrier>=0.8.0', 'numpy>=1.21.0'],\n    python_requires=\">=3.7\",\n    entry_points={\n        'console_scripts': ['pyterrier_pisa=pyterrier_pisa.cli:main'],\n    },\n    cmdclass={'bdist_wheel': bdist_wheel}\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n"
  },
  "Kitware/DIVA": {
    "python/setup.py": "from setuptools import find_packages\n\nfrom skbuild import setup\n\nwith open('../README.rst') as f:\n    long_description = f.read()\n\ndiva_source_dir = \"..\"\nsetup(name='diva-framework',\n      version='0.0.6',\n      author='Kitware, Inc.',\n      author_email='diva-framework@kitware.com',\n      url='https://github.com/Kitware/DIVA',\n      license='BSD 3-Clause',\n      description='The DIVA Framework is a software framework designed'\n      'to provide an architecture and a set of software modules which'\n      'will facilitate the development of DIVA analytics',\n      long_description=long_description,\n      packages=find_packages(),\n      setup_requires=[\n          'setuptools',\n          'scikit-build'\n      ],\n      install_requires=[\n          'kwiver==1.4.5',\n          'opencv-python'\n      ],\n      cmake_args=[\n          '-DCMAKE_BUILD_TYPE=Release',\n          '-DKWIVER_PYTHON_MAJOR_VERSION=3',\n          '-DDIVA_PYTHON_MAJOR_VERSION=3',\n          '-DDIVA_SUPERBUILD=OFF',\n          '-DDIVA_BUILD_SHARED=OFF',\n          '-DDIVA_BUILD_WITH_CUDA=OFF',\n          '-DDIVA_BUILD_WITH_CUDNN=OFF',\n          '-DDIVA_ENABLE_PROCESS=ON',\n      ],\n      cmake_install_dir='diva',\n      cmake_source_dir=diva_source_dir,\n      entry_points={\n          'kwiver.python_plugin_registration' : [\n              'simple_draw_detected_object_set=diva.arrows.simple_draw_detected_object_set',\n              'image_viewer_process=diva.processes.image_viewer_process',\n              'simple_detector_process=diva.processes.simple_detector_process'],\n          'kwiver.cpp_search_paths': [\n              'diva_processes=diva.processes.register_cpp_processes:get_cpp_path']},\n      scripts=[\n          '{}/scripts/cli_helpers/cleanup_chunk.py'.format(diva_source_dir),\n          '{}/scripts/cli_helpers/cleanup_experiment.py'.format(diva_source_dir),\n          '{}/scripts/cli_helpers/generate_experiments.py'.format(diva_source_dir),\n          '{}/scripts/cli_helpers/merge_videos.py'.format(diva_source_dir)],\n      classifiers=[\n          'Development Status :: 3 - Alpha',\n          'Programming Language :: Python :: 3.5',\n          'Programming Language :: Python :: 3.6',\n          'Programming Language :: Python :: 3.7',\n          'Programming Language :: Python :: 3.8',\n          'Operating System :: Unix',\n          'Intended Audience :: Developers',\n          'Intended Audience :: Science/Research',\n          'Topic :: Scientific/Engineering :: Artificial Intelligence'],\n      platforms=['linux', 'Unix'],\n      python_requires='>=3.5')\n"
  },
  "dune-project/dune-grid": {
    "setup.py": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\nimport os, sys\ntry:\n    from dune.packagemetadata import metaData\nexcept ImportError:\n    from packagemetadata import metaData\nfrom skbuild import setup\nsetup(**metaData()[1])\n",
    "pyproject.toml": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\n[build-system]\nrequires = ['dune-geometry@git+https://gitlab.dune-project.org/core/dune-geometry.git', 'numpy', 'pip', 'setuptools', 'wheel', 'scikit-build', 'cmake', 'ninja', 'requests']\nbuild-backend = 'setuptools.build_meta'\n"
  },
  "learnforpractice/mixin-python": {
    "setup.py": "import os\nimport sys\nimport platform\nfrom setuptools import find_packages\nfrom skbuild import setup\n    \n# Require pytest-runner only when running tests\npytest_runner = (['pytest-runner>=2.0,<3dev']\n                 if any(arg in sys.argv for arg in ('pytest', 'test'))\n                 else [])\n\nsetup_requires = pytest_runner\n\ndata_files = [\n#    ('lib',['src/mixin/mixin.so']),\n]\n\ndata = []\nif platform.system() == 'Windows':\n    data.append(\"mixin.dll\")\n\nversion = platform.python_version_tuple()\nversion = '%s.%s' % (version[0], version[1])\n\nsetup(\n    name=\"mixin-python\",\n    version=\"0.2.8\",\n    description=\"Mixin Binding Project\",\n    author='learnforpractice',\n    url=\"https://github.com/learnforpractice/mixin-python\",\n    license=\"GPL-3.0\",\n    packages=['pymixin'],\n    package_dir={'pymixin': 'pysrc'},\n    package_data={'pymixin': data},\n    data_files = data_files,\n    scripts=[],\n    install_requires=[\n        \"PyJWT>=2.4.0\",\n        \"websockets>=9.1\",\n        \"cryptography>=3.4.7\",\n        \"dataclasses-json\",\n        \"httpx\"\n    ],\n    tests_require=['pytest'],\n    setup_requires=setup_requires,\n    include_package_data=True\n)\n",
    "setup.cfg": "[metadata]\nlong_description = file:README.md\nlong_description_content_type = text/markdown\n\n# [options.entry_points]\n# console_scripts =\n#     eosio-go = pymixin.main:main\n"
  },
  "OpenChemistry/stempy": {
    "setup.py": "import os\nimport shutil\n\nfrom skbuild import setup\n\n\ndef extra_cmake_args():\n    # Warning: if you use paths on Windows, you should use \"\\\\\"\n    # for the path delimiter to work on CI.\n    env = os.getenv('EXTRA_CMAKE_ARGS')\n    return env.split(';') if env else []\n\n\ncmake_args = [] + extra_cmake_args()\n\nif os.name == 'nt':\n    # Need to export all headers on windows...\n    cmake_args.append('-DCMAKE_WINDOWS_EXPORT_ALL_SYMBOLS=TRUE')\n\n\nif os.getenv('USE_PYTHON_IN_PATH'):\n    python_exe = shutil.which('python')\n    if python_exe:\n        # For this program, we use find_package(Python3 ...)\n        cmake_args.append(f'-DPython3_EXECUTABLE={python_exe}')\n\n\nwith open('requirements.txt') as f:\n    install_requires = f.read()\n\nsetup(\n    name='stempy',\n    use_scm_version=True,\n    description='A package for the ingestion of 4D STEM data.',\n    long_description='A package for the ingestion of 4D STEM data.',\n    url='https://github.com/OpenChemistry/stempy',\n    author='Kitware Inc',\n    license='BSD 3-Clause',\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'License :: OSI Approved :: BSD License',\n        'Programming Language :: Python :: 3',\n    ],\n    keywords='',\n    packages=['stempy'],\n    install_requires=install_requires,\n    cmake_args=cmake_args,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build==0.14.1\", \"setuptools_scm[toml]\"]\n"
  },
  "IBM/libgroupsig": {
    "src/wrappers/python/setup.py": "#from skbuild import setup  # This line replaces 'from setuptools import setup'\nfrom setuptools import setup, find_packages\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name=\"pygroupsig\",\n    version=\"1.1.0\",\n    author=\"Jesus Diaz Vico\",\n    author_email=\"jdv@zurich.ibm.com\",\n    description=\"A Python wrapper for libgroupsig\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/IBM/libgroupsig.git\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: Apache Software License\",\n\t\"Operating System :: OS Independent\",\n    ],\n    package_dir={'pygroupsig': 'pygroupsig'},\n    packages=['pygroupsig'],\n    python_requires='>=3',\n    setup_requires=[\"cffi\"],\n    cffi_modules=[\"pygroupsig/libgroupsig_build.py:ffibuilder\"],\n    install_requires=[\"cffi\", \"path.py\"],\n    test_suite=\"nose.collector\",\n    tests_require=[\"nose\"],\n)\n"
  },
  "dioptra-io/caracal": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    name=\"pycaracal\",\n    version=\"0.14.5\",\n    author=\"Maxime Mouchet\",\n    author_email=\"max@maxmouchet.com\",\n    url=\"https://github.com/dioptra-io/caracal\",\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3\",\n        \"Topic :: Internet\",\n    ],\n    python_requires=\">=3.8\",\n    package_dir={\"\": \"python\"},\n    packages=[\"pycaracal\"],\n    cmake_args=[\n        \"-DWITH_CONAN=ON\",\n        \"-DWITH_PYTHON=ON\",\n    ],\n    cmake_install_dir=\"python/pycaracal\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"cmake\", \"conan<2.0\", \"ninja\", \"scikit-build\", \"pybind11\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild-frontend = \"build\"\nmanylinux-aarch64-image = \"manylinux_2_28\"\nmanylinux-x86_64-image = \"manylinux_2_28\"\ntest-command = \"$([[ -f /usr/bin/sudo ]] && echo 'sudo') pytest --log-cli-level=DEBUG {project}/python/tests\"\ntest-requires = [\"pytest\", \"pytest-asyncio\"]\n# Avoid testing on emulated architectures, some syscalls are not supported:\n# `RuntimeError: eth0: SIOCETHTOOL(ETHTOOL_GET_TS_INFO) ioctl failed: Function not implemented`\ntest-skip = \"*aarch64\"\n"
  },
  "yaozhenghangma/Material-MC": {
    "setup.py": "import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\n\nsetup(\n    name=\"mmc\",\n    version=\"0.0.1\",\n    description=\"A general Monte Carlo Simulation program for materials with arbitrary lattice.\",\n    author=\"Yaozhenghang Ma\",\n    author_email=\"Yaozhenghang.Ma@gmail.com\",\n    license=\"GNU GPLv3\",\n    url=\"https://github.com/yaozhenghangma/material-monte-carlo/\",\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/yaozhenghangma/material-monte-carlo/issues/\",\n        \"Documentation\": \"https://material-monte-carlo.readthedocs.io/\",\n    },\n    install_requires=[\n        \"setuptools>=42\",\n        \"pybind11>=2.9.2\",\n        \"cmake>=3.13\",\n        \"scikit-build>=0.14.1\",\n        \"numpy\",\n    ],\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/material-monte-carlo\",\n    include_package_data=True,\n    extras_require={\"test\": [\"pytest\"]},\n    python_requires=\">=3.8\",\n)",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"pybind11>=2.9.2\",\n    \"cmake>=3.13\",\n    \"scikit-build>=0.14.1\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\""
  },
  "InsightSoftwareConsortium/ITKVtkGlue": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-vtkglue',\n    version='0.3.0',\n    author='NumFOCUS',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/Kitware/ITKVtkGlue',\n    description=r'This module contains classes that bridge and ITK and VTK image processing and visualization pipeline.',\n    long_description='ITK is an open-source, cross-platform library that provides developers with an extensive suite of software tools for image analysis. VTK enables visualization of images in three dimension. This module converts ITK and VTK image data structures in a processing pipelining without copying the pixel buffer.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://www.itk.org/',\n    install_requires=[\n        r'itk>=5.0.0.post1',\n        r'vtk==8.1.*'\n    ]\n    )\n"
  },
  "aldebaran/libqi-python": {
    "setup.py": "#! /usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport platform\nimport pathlib\nfrom setuptools import find_packages\nfrom skbuild import setup\nfrom packaging import version\nimport toml\n\npy_version = version.parse(platform.python_version())\nmin_version = version.parse('3.5')\nif py_version < min_version:\n    raise RuntimeError('Python 3.5+ is required.')\n\n# Parse `pyproject.toml` runtime dependencies.\npyproject_data = toml.loads(pathlib.Path('pyproject.toml').read_text())\npyproject_deps = pyproject_data['project']['dependencies']\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\nversion = {}\nwith open(os.path.join(here, \"qi\", \"_version.py\")) as f:\n    exec(f.read(), version)\n\n# Get the long description from the README file\nwith open(os.path.join(here, 'README.rst'), encoding='utf-8') as f:\n    long_description = f.read()\n\nsetup(\n    name='qi',\n    version=version['__version__'],\n    description='LibQi Python bindings',\n    long_description=long_description,\n    long_description_content_type='text/x-rst',\n    keywords=['libqi', 'qi', 'naoqi',\n              'softbank', 'robotics', 'aldebaran',\n              'robot', 'nao', 'pepper', 'romeo'],\n    url='https://github.com/aldebaran/libqi-python',\n    author='SoftBank Robotics Europe',\n    author_email='release@softbankrobotics.com',\n    license='BSD 3-Clause License',\n    python_requires='~=3.5',\n    install_requires=pyproject_deps,\n    packages=find_packages(exclude=[\n        '*.test', '*.test.*', 'test.*', 'test'\n    ]),\n    include_package_data=True,\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'License :: OSI Approved :: BSD License',\n        'Intended Audience :: Developers',\n        'Topic :: Software Development :: Libraries',\n        'Topic :: Software Development :: Libraries :: Application Frameworks',\n        'Topic :: Software Development :: Embedded Systems',\n        'Framework :: Robot Framework :: Library',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3 :: Only',\n    ],\n    cmake_args=['-DQIPYTHON_STANDALONE:BOOL=ON'],\n)\n",
    "pyproject.toml": "[project]\ndependencies = [\n  \"packaging\"\n]\n\n# PEP 518\n[build-system]\n# Minimum requirements for the build system to execute.\nrequires = [\n  \"setuptools >= 47, < 51\", # setuptools 51 dropped support for Python 3.5.\n  \"wheel >= 0.34\", # tested with 0.34.\n  \"scikit-build >= 0.10\", # tested with 0.10.\n  \"cmake ~= 3.16\", # CMake >= 3.16, CMake < 4.\n  \"ninja ~= 1\", # ninja >= 1, ninja < 2.\n  \"toml ~= 10\",\n  \"packaging ~= 21\",\n]\n"
  },
  "pupil-labs/pupil-detectors": {
    "setup.py": "import platform\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\npackage = \"pupil_detectors\"\npackage_dir = \"src\"\n\ncmake_args = []\n\nif platform.system() == \"Windows\":\n    # The Ninja cmake generator will use mingw (gcc) on windows travis instances, but we\n    # need to use msvc for compatibility.\n    cmake_args.append(\"-GVisual Studio 17 2022\")\n\n\nif __name__ == \"__main__\":\n    setup(\n        cmake_args=cmake_args,\n        cmake_install_dir=\"src/pupil_detectors\",\n        cmake_source_dir=\"src/pupil_detectors\",\n        packages=find_packages(package_dir),\n        package_dir={\"\": package_dir},\n        include_package_data=False,\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"setuptools_scm[toml]>=3.4.1\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja\",\n    \"numpy\",\n    \"cython\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\n\n[tool.cibuildwheel]\narchs = [\"native\"]\nskip = \"{cp,pp}27-* {cp,pp}35-* pp*\"\n\nbuild-frontend = \"build\"\n\ntest-command = \"pytest {package}/tests -v\"\nbefore-test = \"\"\ntest-requires = [\"pytest\"]\ntest-extras = []\n\nmanylinux-x86_64-image = \"manylinux2014\"\n\n[tool.cibuildwheel.macos]\nbefore-all = [\"brew install eigen opencv\"]\n\n[tool.cibuildwheel.linux]\nbefore-all = [\"yum install -y eigen3-devel\", \"bash scripts/manylinux-before-all.sh\"]\n\n[tool.cibuildwheel.windows]\nbefore-all = [\"choco install eigen opencv\"]\nenvironment = { OpenCV_DIR=\"c:/tools/opencv/build\" }\nbefore-build = \"pip install delvewheel\"\nrepair-wheel-command = \"delvewheel repair -w {dest_dir} {wheel} --add-path C:/tools/opencv/build/x64/vc15/bin\"\n",
    "setup.cfg": "[metadata]\nname = pupil_detectors\ndescription = Pupil Labs 2D Pupil Detector\nlong_description = file: README.rst\nlong_description_content_type = text/x-rst\nurl = https://github.com/pupil-labs/pupil-detectors\nauthor = Pupil Labs GmbH\nauthor_email = info@pupil-labs.com\nlicense = MIT\nlicense_files = [COPYING, COPYING.lesser]\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Intended Audience :: Developers\n    License :: OSI Approved :: MIT License\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3 :: Only\nproject_urls =\n    Changelog=https://github.com/pupil-labs/pupil-detectors/blob/master/CHANGES.rst\n\n[options]\ninstall_requires =\n    numpy\n    opencv-python\n    cysignals;platform_system != \"Windows\"\n    importlib-metadata;python_version<\"3.8\"\npython_requires = >=3.6\n\n[options.extras_require]\ndocs =\n    jaraco.packaging>=9\n    rst.linker>=1.9\n    sphinx\ntesting =\n    pytest>=6\n    pytest-checkdocs>=2.4\n    pytest-cov\n    pytest-enabler>=1.3\n    pytest-mypy>=0.9.1;python_implementation != \"PyPy\"\n"
  },
  "HiroIshida/tinyfk": {
    "setup.py": "import sys\n\n# see \n# https://github.com/scikit-build/scikit-build-sample-projects/blob/master/projects/hello-pybind11/setup.py\ntry:\n    from skbuild import setup\nexcept ImportError:\n    raise Exception\n\nsetup(\n    name=\"tinyfk\",\n    version=\"0.6.1\",\n    description=\"a fast kinematics solver\",\n    author='Hirokazu Ishida',\n    license=\"MIT\",\n    packages=[\"tinyfk\"],\n    package_dir={'': 'python'},\n    cmake_install_dir='python/tinyfk/',\n    package_data={\"tinyfk\": [\"py.typed\"]}\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 100\n\n[tool.isort]\nprofile = \"black\"\n"
  },
  "InsightSoftwareConsortium/ITKGrowCut": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-growcut',\n    version='0.1.2',\n    author='Insight Software Consortium',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKGrowCut',\n    description=r'Segments a 3D image from foreground and background seeds.',\n    long_description='ITKGrowCut is a remote module for ITK. It segments a 3D image from user-provided foreground and background seeds.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.2.1'\n    ]\n    )\n"
  },
  "planetmarshall/pillow-jpls": {
    "setup.py": "import sys\nfrom os import path\nfrom setuptools import find_packages\nimport re\n\n\n_semver_regex = r\"\"\"(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)\"\"\"\n_project_regex = r\"^project\\(.*$\"\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\n\ndef _current_directory():\n    return path.abspath(path.dirname(__file__))\n\n\ndef _long_description():\n    with open(path.join(_current_directory(), 'README.md'), encoding='utf-8') as fp:\n        return fp.read()\n\n\ndef _version():\n    with open(path.join(_current_directory(), 'CMakeLists.txt'), encoding='utf-8') as fp:\n        text = fp.read()\n        project_line = re.search(_project_regex, text, re.MULTILINE | re.IGNORECASE)\n        semver = re.search(_semver_regex, project_line.group())\n        return \"{major}.{minor}.{patch}\".format(**semver.groupdict())\n\n\nsetup(\n    name=\"pillow-jpls\",\n    version=_version(),\n    description=\"A JPEG-LS plugin for the Pillow imaging library\",\n    author=\"Andrew Marshall\",\n    author_email=\"andrew@algodynamic.com\",\n    url=\"https://github.com/planetmarshall/pillow-jpls\",\n    license=\"BSD-3-Clause\",\n    long_description=_long_description(),\n    long_description_content_type=\"text/markdown\",\n    packages=find_packages(),\n    cmake_install_dir=\"pillow_jpls\",\n    install_requires=[\n        \"Pillow\"\n    ],\n    python_requires=\">=3.6\"\n)",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"pybind11~=2.6.0\",\n    \"cmake\",\n    \"conan\",\n    \"ninja\",\n    \"scikit-build\",\n]\n\nbuild-backend = \"setuptools.build_meta\""
  },
  "airsim/rmol": {
    "setup.py": "\nimport os, sys, setuptools\nfrom skbuild import setup\nfrom pathlib import Path\n\n# Home directory for RMOL, assumed to be the parent directory\n# of this setup.py file\nrmol_dir = Path(__file__).resolve().parents[1]\n\n# Installation directories of other Travel Market Simulator compoenents\n# are assumed to be ../../install/component, as if installed by\n# MetaSim (https://github.com/airsim/metasim).\n# If that is not the case, adapt the paths to the components\n# in the CMake arguments below\ninstall_dir = rmol_dir.parent / 'install'\n\n#\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup (\n    name='rmol',\n    version='1.0.6-1',\n    author='Denis Arnaud',\n    author_email='denis.arnaud_pypi@m4x.org',\n    description=('''Simple Python wrapper for RMOL'''),\n    license='MIT',\n    keywords='api python rmol revenue management package',\n    url='https://github.com/airsim/rmol',\n    packages=setuptools.find_packages(),\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    cmake_args = [\n      '-DINSTALL_DOC:BOOL=OFF',\n      '-DRUN_GCOV:BOOL=OFF',\n      '-DLIB_SUFFIX=',\n      f'-DWITH_STDAIR_PREFIX={install_dir}/stdair',\n      f'-DWITH_AIRRAC_PREFIX={install_dir}/airrac'\n      ] + (\n      ['-DREADLINE_ROOT=/usr/local/opt/portable-readline',\n       '-DREADLINE_INCLUDE_DIR=/usr/local/opt/portable-readline/include',\n       '-DREADLINE_LIBRARY=/usr/local/opt/libedit/lib/libedit.dylib',\n       '-DICU_ROOT=/usr/local/opt/icu4c'] if sys.platform.startswith(\"darwin\") else []\n      )\n)\n\n"
  },
  "jimbraun/XCDF": {
    "setup.py": "import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\n\nsetup(\n    packages=find_packages(where=\"src/pybindings\"),\n    package_dir={\"\": \"src/pybindings\"},\n    cmake_install_dir=\"src/pybindings/xcdf\",\n    include_package_data=True,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools>=42\",\n  \"wheel\",\n  \"scikit-build\",\n  \"cmake\",\n  \"pybind11\"\n]\nbuild-backend = \"setuptools.build_meta\"",
    "setup.cfg": "[metadata]\nname = xcdf\nversion = 4.0.0\ndescription = Python bindings for the eXplicitly Compacted Data Format (XCDF) built using pybind11\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nlicense = MIT\nproject_urls=\n    Bug Tracker = https://github.com/jimbraun/XCDF/issues\n    Source Code = https://github.com/jimbraun/XCDF\n\nclassifiers =\n    License :: OSI Approved :: MIT License\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3.11\n\tTopic :: Scientific/Engineering :: Astronomy\n    Intended Audience :: Science/Research\n    Topic :: Software Development :: Libraries :: Python Modules\n\n\n\n[options]\ninstall_requires =\n    numpy\npython_requires = >=3.7\n\n[options.extras_require]\ntests = \n    pytest"
  },
  "dekamps/miind": {
    "setup.py": "import io\nimport os\nimport os.path\nimport pathlib\nimport sys\nimport runpy\nimport subprocess\nimport re\nimport sysconfig\nimport shutil\nimport platform\nfrom sys import platform\nimport skbuild\nfrom skbuild import cmaker\n\ndef main():\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n\n    cmake_source_dir = \".\"\n    \n    # Build empty miind and miind_api directories in root folder. \n    # We don't want them there in the repo as they're just placeholders.\n    miind_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'miind')\n    try:\n        os.mkdir(miind_dir)\n    except:\n        print(\"Could not create miind directory\", miind_dir)\n    miind_api_dir = os.path.join(miind_dir, 'miind_api')\n    try:\n        os.mkdir(miind_api_dir)\n    except:\n        print(\"Could not create miind_api directory\", miind_api_dir)\n\n    python_version = cmaker.CMaker.get_python_version()\n    python_lib_path = cmaker.CMaker.get_python_library(python_version).replace(\n        \"\\\\\", \"/\"\n    )\n    python_include_dir = cmaker.CMaker.get_python_include_dir(python_version).replace(\n        \"\\\\\", \"/\"\n    )\n\n    package_version = \"1.0.20\"\n\n    package_name = \"miind\"\n\n    with open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n        long_description = fh.read()\n\n    packages = [\"miind\", \"miind.miind_api\"]\n\n    package_data = {\n        \"miind\": [],\n        \"miind.testfiles\": [],\n        \"miind.miind_api\": [],\n        \"miind.build\": [],\n        \"miind.build.apps.MatrixGenerator\": [],\n        \"miind.build.apps.Projection\": [],\n        \"miind.build.examples\": []\n    }\n\n    # Files from CMake output to copy to package.\n    # Path regexes with forward slashes relative to CMake install dir.\n    rearrange_cmake_output_data = {\n        \"miind\": ([\"lib/miindsim.pyd\",\"lib/miindsimv.pyd\",\"lib/miindgen.pyd\"] if platform == \"win32\" else []) + ([\"bin\\/.+\\.dll\"] if platform == \"win32\" else []) + ([\"lib/miindsim.so\",\"lib/miindgen.so\"] if platform not in [\"win32\"] else []) + ([\"lib/miindsimv.so\",\"lib/miindgen.so\"] if platform not in [\"win32\",\"darwin\"] else []) + [\"share\\/miind\\/python\\/miind\\/.+\"],\n        \"miind.miind_api\": [\"share\\/miind\\/python\\/miind\\/miind_api\\/.+\"],\n        \"miind.build\": [],\n        \"miind.build.apps.MatrixGenerator\": ([\"bin\\/gsl.dll\", \"bin\\/gslcblas.dll\", \"bin\\/vcruntime140.dll\", \"bin\\/vcruntime140_1.dll\", \"bin\\/msvcp140.dll\"] if platform == \"win32\" else []) + ([\"bin\\/MatrixGenerator.+\", \"bin\\/Bind.+\"] if platform == \"win32\" else []) + ([\"share\\/miind\\/apps\\/MatrixGenerator\\/.+\"] if platform != \"win32\" else []),\n        \"miind.build.apps.Projection\": ([\"bin\\/gsl.dll\", \"bin\\/gslcblas.dll\", \"bin\\/vcruntime140.dll\", \"bin\\/vcruntime140_1.dll\", \"bin\\/msvcp140.dll\"] if platform == \"win32\" else []) + ([\"bin\\/Projection.+\"] if platform == \"win32\" else []) + ([\"share\\/miind\\/apps\\/Projection\\/.+\"] if platform != \"win32\" else []),\n        \"miind.build.examples\": [\"share\\/miind\\/examples\\/.+\"],\n        \"miind.testfiles\": [\"share\\/miind\\/python\\/miind\\/testfiles\\/.+\"]\n    }\n\n    # Files in sourcetree outside package dir that should be copied to package.\n    # Raw paths relative to sourcetree root.\n    files_outside_package_dir = {\"miind\": []}\n    \n    # vcpkg builds libraries which are too new for manylinux2014 so\n    # is disabled for Linux\n    cmake_args = (\n        [\n            '-DCMAKE_BUILD_TYPE=Release',\n            '-DENABLE_OPENMP:BOOL=ON',\n            '-DENABLE_MPI:BOOL=OFF',\n            '-DENABLE_TESTING:BOOL=ON',\n            '-DENABLE_CUDA:BOOL=ON',\n            '-DENABLE_ROOT:BOOL=OFF',\n            '-DCMAKE_CUDA_FLAGS=--generate-code=arch=compute_30,code=[compute_30,sm_30]'\n        ]\n    )\n        \n    if platform == \"win32\":\n        cmake_args = (\n            [\n                '-DCMAKE_BUILD_TYPE=Release',\n                '-DENABLE_OPENMP:BOOL=ON',\n                '-DENABLE_MPI:BOOL=OFF',\n                '-DENABLE_TESTING:BOOL=ON',\n                '-DENABLE_CUDA:BOOL=ON',\n                '-DENABLE_ROOT:BOOL=OFF',\n                '-DVCPKG_MANIFEST_INSTALL:BOOL=ON',\n                '-DVCPKG_MANIFEST_MODE:BOOL=ON',\n                '-DCMAKE_CUDA_FLAGS=--generate-code=arch=compute_50,code=[compute_50,sm_50]',\n                '-DVCPKG_TARGET_TRIPLET=x64-windows',\n                '-DCMAKE_TOOLCHAIN_FILE=' + os.path.dirname(os.path.abspath(__file__)) + '/vcpkg/scripts/buildsystems/vcpkg.cmake'\n            ]\n        )\n    \n    # Building python-3 in vcpkg on macos seems broken. It is exluded for now.\n    if platform == \"darwin\":\n        cmake_args = (\n            [\n                '-DCMAKE_BUILD_TYPE=Release',\n                '-DENABLE_OPENMP:BOOL=OFF',\n                '-DENABLE_MPI:BOOL=OFF',\n                '-DENABLE_TESTING:BOOL=ON',\n                '-DENABLE_CUDA:BOOL=OFF',\n                '-DENABLE_ROOT:BOOL=OFF'\n            ]\n        )\n    \n\n    # https://github.com/scikit-build/scikit-build/issues/479\n    if \"CMAKE_ARGS\" in os.environ:\n        import shlex\n\n        cmake_args.extend(shlex.split(os.environ[\"CMAKE_ARGS\"]))\n        del shlex\n\n    # works via side effect\n    RearrangeCMakeOutput(\n        rearrange_cmake_output_data, files_outside_package_dir, package_data.keys()\n    )\n\n    skbuild.setup(\n        name=package_name,\n        version=package_version,\n        url=\"https://github.com/dekamps/miind\",\n        description=\"MIIND\",\n        long_description=long_description,\n        long_description_content_type=\"text/markdown\",\n        packages=packages,\n        package_data=package_data,\n        install_requires=[\n              'shapely',\n              'descartes',\n              'numpy',\n              'matplotlib',\n              'scipy'\n        ],\n        python_requires=\">=3.6\",\n        classifiers=[\n            \"Programming Language :: Python\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: 3 :: Only\",\n            \"Programming Language :: Python :: 3.6\",\n            \"Programming Language :: Python :: 3.7\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Operating System :: MacOS\",\n            \"Operating System :: Unix\",\n            \"Operating System :: Microsoft :: Windows\",\n        ],\n        cmake_args=cmake_args,\n        cmake_source_dir=cmake_source_dir,\n    )\n    \n\n\nclass RearrangeCMakeOutput(object):\n    \"\"\"\n        Patch SKBuild logic to only take files related to the Python package\n        and construct a file hierarchy that SKBuild expects (see below)\n    \"\"\"\n\n    _setuptools_wrap = None\n\n    # Have to wrap a function reference, or it's converted\n    # into an instance method on attr assignment\n    import argparse\n\n    wraps = argparse.Namespace(_classify_installed_files=None)\n    del argparse\n\n    package_paths_re = None\n    packages = None\n    files_outside_package = None\n\n    def __init__(self, package_paths_re, files_outside_package, packages):\n        cls = self.__class__\n        assert not cls.wraps._classify_installed_files, \"Singleton object\"\n        import skbuild.setuptools_wrap\n\n        cls._setuptools_wrap = skbuild.setuptools_wrap\n        cls.wraps._classify_installed_files = (\n            cls._setuptools_wrap._classify_installed_files\n        )\n        cls._setuptools_wrap._classify_installed_files = (\n            self._classify_installed_files_override\n        )\n\n        cls.package_paths_re = package_paths_re\n        cls.files_outside_package = files_outside_package\n        cls.packages = packages\n\n    def __del__(self):\n        cls = self.__class__\n        cls._setuptools_wrap._classify_installed_files = (\n            cls.wraps._classify_installed_files\n        )\n        cls.wraps._classify_installed_files = None\n        cls._setuptools_wrap = None\n\n    def _classify_installed_files_override(\n        self,\n        install_paths,\n        package_data,\n        package_prefixes,\n        py_modules,\n        new_py_modules,\n        scripts,\n        new_scripts,\n        data_files,\n        cmake_source_dir,\n        cmake_install_reldir,\n    ):\n        \"\"\"\n            From all CMake output, we're only interested in a few files\n            and must place them into CMake install dir according\n            to Python conventions for SKBuild to find them:\n                package\\\n                    file\n                    subpackage\\\n                        etc.\n        \"\"\"\n\n        cls = self.__class__\n\n        # 'relpath'/'reldir' = relative to CMAKE_INSTALL_DIR/cmake_install_dir\n        # 'path'/'dir' = relative to sourcetree root\n        cmake_install_dir = os.path.join(\n            cls._setuptools_wrap.CMAKE_INSTALL_DIR(), cmake_install_reldir\n        )\n        install_relpaths = [\n            os.path.relpath(p, cmake_install_dir) for p in install_paths\n        ]\n        fslash_install_relpaths = [\n            p.replace(os.path.sep, \"/\") for p in install_relpaths\n        ]\n        relpaths_zip = list(zip(fslash_install_relpaths, install_relpaths))\n        del install_relpaths, fslash_install_relpaths\n\n        final_install_relpaths = []\n\n        print(\"Copying files from CMake output\")\n\n        for package_name, relpaths_re in cls.package_paths_re.items():\n            package_dest_reldir = package_name.replace(\".\", os.path.sep)\n            for relpath_re in relpaths_re:\n                found = False\n                r = re.compile(relpath_re + \"$\")\n                for fslash_relpath, relpath in relpaths_zip:\n                    m = r.match(fslash_relpath)\n                    if not m:\n                        continue\n                    found = True\n                    # We want to keep directory structure as we find it.\n                    try:\n                        num_dirs_to_remove = len(relpath_re.split('/'))-1\n                        new_install_relpath = os.path.join(\n                            package_dest_reldir, *pathlib.Path(relpath).parts[num_dirs_to_remove:]\n                        )\n                        \n                    except:\n                        new_install_relpath = os.path.join(\n                            package_dest_reldir, os.path.basename(relpath)\n                        )\n                    cls._setuptools_wrap._copy_file(\n                        os.path.join(cmake_install_dir, relpath),\n                        os.path.join(cmake_install_dir, new_install_relpath),\n                        hide_listing=False,\n                    )\n                    final_install_relpaths.append(new_install_relpath)\n                    del m, fslash_relpath, new_install_relpath\n                else:\n                    if not found:\n                        raise Exception(\"Not found: '%s'\" % relpath_re)\n                del r, found\n\n        del relpaths_zip\n\n        print(\"Copying files from non-default sourcetree locations\")\n\n        for package_name, paths in cls.files_outside_package.items():\n            package_dest_reldir = package_name.replace(\".\", os.path.sep)\n            for path in paths:\n                new_install_relpath = os.path.join(\n                    package_dest_reldir,\n                    # Don't yet have a need to copy\n                    # to subdirectories of package dir\n                    os.path.basename(path),\n                )\n                cls._setuptools_wrap._copy_file(\n                    path,\n                    os.path.join(cmake_install_dir, new_install_relpath),\n                    hide_listing=False,\n                )\n                final_install_relpaths.append(new_install_relpath)\n\n        final_install_paths = [\n            os.path.join(cmake_install_dir, p) for p in final_install_relpaths\n        ]\n\n        return (cls.wraps._classify_installed_files)(\n            final_install_paths,\n            package_data,\n            package_prefixes,\n            py_modules,\n            new_py_modules,\n            scripts,\n            new_scripts,\n            data_files,\n            # To get around a check that prepends source dir to paths and breaks package detection code.\n            cmake_source_dir=\"\",\n            _cmake_install_dir=cmake_install_reldir,\n        )\n\n# This creates a list which is empty but returns a length of 1.\n# Should make the wheel a binary distribution and platlib compliant.\nclass EmptyListWithLength(list):\n    def __len__(self):\n        return 1\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build!=0.14.0\", \"cmake\"]"
  },
  "dantrim/hamming-codec": {
    "setup.py": "import sys\nimport pathlib\n\nimport os\nimport subprocess\nfrom setuptools.command.sdist import sdist\nfrom setuptools.command.install import install\n\n# from pybind11 import get_cmake_dir\nfrom pybind11.setup_helpers import Pybind11Extension, build_ext\n\n# from setuptools import setup\n\n# the directory containing this file\nHERE = pathlib.Path(__file__).parent\n\n# the text of the README file\nREADME = (HERE / \"README.md\").read_text()\n\n__version__ = \"0.3.5\"\n\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\next_modules = [\n    Pybind11Extension(\n        \"_hamming_codec\",\n        [\"src/python/module.cpp\"],\n        include_dirs=[\"src/cpp\"],\n        # Example: passing in the version to the compiled code\n        define_macros=[(\"VERSION_INFO\", __version__), (\"BUILD_PYTHON\", \"on\")],\n    ),\n]\n\n\ndef check_submodules():\n    \"\"\"verify that the submodules are checked out and clean\n    use `git submodule update --init`; on failure\n    \"\"\"\n    if not os.path.exists(\".git\"):\n        return\n    with open(\".gitmodules\") as f:\n        for line in f:\n            if \"path\" in line:\n                p = line.split(\"=\")[-1].strip()\n                if not os.path.exists(p):\n                    raise ValueError(\"Submodule {} missing\".format(p))\n\n    proc = subprocess.Popen([\"git\", \"submodule\", \"status\"], stdout=subprocess.PIPE)\n    status, _ = proc.communicate()\n    status = status.decode(\"ascii\", \"replace\")\n    for line in status.splitlines():\n        if line.startswith(\"-\") or line.startswith(\"+\"):\n            raise ValueError(\"Submodule not clean: {}\".format(line))\n\n\nclass SdistChecker(sdist):\n    \"\"\" check submodules on sdist to prevent incomplete tarballs \"\"\"\n\n    def run(self):\n        check_submodules()\n        sdist.run(self)\n\n\nclass InstallChecker(install):\n    \"\"\" check submodules on install to prevent failed installs \"\"\"\n\n    def run(self):\n        check_submodules()\n        install.run(self)\n\n\ncmake_compiler_defines = f\"-DBUILD_PYTHON=on -DVERSION_INFO={__version__}\"\nprint(f\"cmake compiler defines = {cmake_compiler_defines}\")\n\nsetup(\n    name=\"hamming_codec\",\n    version=__version__,\n    description=\"Simple encode/decode utilities for bit-error correcting Hamming codes\",\n    long_description=README,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/dantrim/hamming-codec\",\n    author=\"Daniel Joseph Antrim\",\n    author_email=\"dantrim1023@gmail.com\",\n    license=\"MIT\",\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n    ],\n    package_dir={\"\": \"src/python\"},\n    packages=[\"hamming_codec\", \"cli\"],\n    install_requires=[\"typer\"],\n    ext_modules=ext_modules,\n    cmake_args=[\"-DBUILD_PYTHON=on\"],\n    cmake_install_dir=\"src/python/hamming_codec\",\n    entry_points={\"console_scripts\": [\"hamming=cli:cli.app\"]},\n    cmdclass={\"build_ext\": build_ext, \"install\": InstallChecker, \"sdist\": SdistChecker},\n    include_package_data=True,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"cmake>=3.15\",\n    \"pybind11\",\n    \"scikit-build\",\n    \"ninja\",\n    \"typer\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 88\ntarget-version = [\"py36\", \"py37\", \"py38\"]\ninclude = '\\.pyi?$'\nexclude = '''\n/(\n    \\.git\n  | .eggs\n  | build\n)/\n'''\n"
  },
  "SimpleITK/SimpleITKPythonPackage": {
    "setup.py": "from __future__ import print_function\nfrom os import sys\nfrom skbuild import setup\n\nwith open('SimpleITK/Readme.md', encoding='utf-8') as f:\n    long_description = f.read()\n\n\nsetup(\n    name='SimpleITK',\n    version='2.2.1',\n    author='Insight Software Consortium',\n    author_email='insight-users@itk.org',\n    packages=['SimpleITK'],\n    package_dir={'SimpleITK':'SimpleITK'},\n    download_url=r'https://www.itk.org/SimpleITKDoxygen/html/PyDownloadPage.html',\n    description=r'SimpleITK is a simplified interface to the Insight Toolkit (ITK) for image registration and segmentation',\n    long_description = long_description,\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords = 'SimpleITK ITK InsightToolkit segmentation registration',\n    url = r'http://simpleitk.org/',\n    project_urls={\n        \"Bug Tracker\": \"https://github.com/SimpleITK/SimpleITK/issues\",\n        \"Documentation\": \"https://simpleitk.readthedocs.io/en/release/\",\n        \"Source Code\": \"https://github.com/SimpleITK/SimpleITK\",\n    },\n    install_requires=[],\n    zip_safe=False\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"scikit-build >= 0.14\", \"wheel\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "SarderLab/Histo-cloud": {
    "setup.py": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\n\nfrom setuptools import find_packages\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    sys.stderr.write(\"\"\"scikit-build is required to build from source or run tox.\nPlease run:\n  python -m pip install scikit-build\n\"\"\")\n    # from setuptools import setup\n    sys.exit(1)\n\n\nwith open('README.rst', 'rt') as readme_file:\n    readme = readme_file.read()\n\n\ndef prerelease_local_scheme(version):\n    \"\"\"\n    Return local scheme version unless building on master in CircleCI.\n\n    This function returns the local scheme version number\n    (e.g. 0.0.0.dev<N>+g<HASH>) unless building on CircleCI for a\n    pre-release in which case it ignores the hash and produces a\n    PEP440 compliant pre-release version number (e.g. 0.0.0.dev<N>).\n    \"\"\"\n    from setuptools_scm.version import get_local_node_and_date\n\n    if os.getenv('CIRCLE_BRANCH') in {'master'}:\n        return ''\n    else:\n        return get_local_node_and_date(version)\n\n\nsetup(\n    name='histomicstk',\n    use_scm_version={'local_scheme': prerelease_local_scheme},\n    description='A Python toolkit for Histopathology Image Analysis',\n    long_description=readme,\n    long_description_content_type='text/x-rst',\n    author='Kitware, Inc.',\n    author_email='developers@digitalslidearchive.net',\n    url='https://github.com/DigitalSlideArchive/HistomicsTK',\n    packages=find_packages(exclude=['tests', '*_test']),\n    package_dir={\n        'histomicstk': 'histomicstk',\n    },\n    include_package_data=True,\n    install_requires=[\n        # scientific packages\n        'nimfa>=1.3.2',\n        'numpy>=1.12.1',\n        'scipy>=0.19.0',\n        'Pillow>=3.2.0',\n        'pandas>=0.19.2',\n        'scikit-image>=0.14.2',\n        'scikit-learn>=0.18.1',\n        'imageio>=2.3.0',\n        'shapely[vectorized]',\n        'opencv-python-headless<4.7',\n        'sqlalchemy',\n        'matplotlib',\n        'pyvips',\n        'termcolor',\n        'openpyxl',\n        'xlrd<2',\n        # dask packages\n        'dask[dataframe]>=1.1.0',\n        'distributed>=1.21.6',\n        # large image sources\n        'large-image[sources]',\n        'girder-slicer-cli-web',\n        'girder-client',\n        # cli\n        'ctk-cli',\n    ],\n    license='Apache Software License 2.0',\n    keywords='histomicstk',\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'License :: OSI Approved :: Apache Software License',\n        'Programming Language :: Python :: 2',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Topic :: Scientific/Engineering :: Artificial Intelligence',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ],\n    zip_safe=False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"numpy\", \"cython\", \"setuptools-scm\"]\n\n"
  },
  "gnikit/findent-pypi": {
    "setup.py": "import os\n\nfrom skbuild import setup\n\n# Read version from file, same as in CMakeLists.txt\nwith open(os.path.join(os.getcwd(), \"version.txt\")) as f:\n    version = f.read()\n\nsetup(\n    name=\"findent\",\n    version=version,\n    description=\"findent: powerful Fortran formatter\",\n    python_requires=\">=3.7\",\n    long_description=open(os.path.join(os.getcwd(), \"doc/README.md\")).read(),\n    long_description_content_type=\"text/markdown\",\n    author=\"Willem Vermin\",\n    # author_email=\"wvermin@gmail.com\",\n    maintainer=\"Giannis Nikiteas\",\n    keywords=\"fortran, formatter, format converter, dependency generator\",\n    url=\"https://github.com/wvermin/findent\",\n    license=\"BSD License 2.0\",\n    platforms=\"Posix, Windows\",\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Programming Language :: Fortran\",\n        \"Programming Language :: C++\",\n        \"Topic :: Software Development\",\n        \"Topic :: Text Processing\",\n    ],\n    cmake_args=(\"-G\", \"Unix Makefiles\"),\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"scikit-build>=0.13\", \"cmake>=3.18\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild = \"cp311-*\" # build wheels only for one Python version\n\n[tool.cibuildwheel.linux]\nbefore-all = \"yum -y install bison flex || apt-get -y install bison flex || apk add --upgrade bison flex\"\ntest-command = \"echo 'installed'\"\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"arm64\"]\nbefore-all = \"brew install bison flex make\"\ntest-command = \"echo 'installed'\"\n\n[tool.cibuildwheel.macos.environment]\nCC = \"clang\"\nCXX = \"clang++\"\n\n[tool.cibuildwheel.windows]\narchs = [\"auto64\"]\n\n[tool.cibuildwheel.windows.environment]\nCC = \"gcc.exe\"\nCXX = \"g++.exe\"\n"
  },
  "sasq64/musicplayer": {
    "setup.py": "from skbuild import setup\nsetup(\n    name=\"musix\",\n    version=\"0.1.1\",\n    packages=[\"musix\"],\n    package_dir={\"\": \"python\"},\n    cmake_install_dir=\"python/musix\",\n    cmake_args=[\"-DPYTHON_MODULE=ON\", \"-DMACOSX_DEPLOYMENT_TARGET=10.15\"],\n    package_data={\"musix\": [\"py.typed\", \"*.pyi\", \"**/*.pyi\", \"*/*/*.pyi\"]},\n    zip_safe=False,\n)\n",
    "pyproject.toml": "[project]\nname = \"musix\"\nversion = \"0.1.1\"\ndescription = \"Music library\"\nauthors = [\n    {name = \"Jonas Minnberg\", email=\"sasq64@gmail.com\"}\n]\nlicense = {file = \"LICENSE.md\"}\nreadme = \"PYTHON.md\"\nrequires-python = \">=3.7\"\n\n[project.urls]\nrepository = \"https://github.com/sasq64/musicplayer\"\n\n[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13\",\n    \"wheel\",\n    \"ninja\",\n    \"cmake>=3.12\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n"
  },
  "fadoss/maude-bindings": {
    "setup.py": "from skbuild import setup\n\nwith open(\"build/PythonPkgDescription.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(\n    name='maude',\n    version='1.2.3',\n    author='ningit',\n    author_email='ningit@users.noreply.github.com',\n    description='Python bindings for Maude',\n    long_description=long_description,\n    url='https://github.com/fadoss/maude-bindings',\n    project_urls={\n        'Bug Tracker'   : 'https://github.com/fadoss/maude-bindings/issues',\n        'Documentation' : 'https://fadoss.github.io/maude-bindings',\n        'Source Code'   : 'https://github.com/fadoss/maude-bindings'\n    },\n    long_description_content_type=\"text/markdown\",\n    license='GPLv2',\n    packages=['maude'],\n    classifiers=[\n         'Intended Audience :: Science/Research',\n         'Programming Language :: Python',\n         'Programming Language :: Python :: 3',\n         'Topic :: Scientific/Engineering',\n         'Operating System :: OS Independent',\n     ]\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"meson\"]\n"
  },
  "flatironinstitute/baobzi": {
    "setup.py": "from skbuild import setup\n\n# read the contents of your README file\nfrom pathlib import Path\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\nsetup(name='baobzi',\n      version='0.9.6',\n      description='An adaptive fast function approximator based on tree search',\n      long_description=long_description,\n      long_description_content_type='text/markdown',\n      author='Robert Blackwell',\n      author_email='rblackwell@flatironinstitute.org',\n      url='https://github.com/flatironinstitute/baobzi',\n      packages=['baobzi'],\n      package_dir={'baobzi': 'src/python'},\n      install_requires=['numpy'],\n      cmake_args=['-DBAOBZI_BUILD_TESTS:BOOL=OFF', '-DBAOBZI_BUILD_EXAMPLES:BOOL=OFF', '-DBAOBZI_BUILD_FORTRAN:BOOL=OFF'],\n      )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n"
  },
  "jupyter-xeus/xeus-python-wheel": {
    "setup.py": "import os\nimport sys\n\ntry:\n    from skbuild import setup\n    from skbuild.exceptions import SKBuildError\n    from skbuild.cmaker import get_cmake_version\n    from packaging.version import LegacyVersion\n\n    setup_requires = []\n    try:\n        if LegacyVersion(get_cmake_version()) < LegacyVersion(\"3.15\"):\n            setup_requires.append('cmake')\n    except SKBuildError:\n        setup_requires.append('cmake')\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\npython_path = sys.executable\n\ntry:\n    import pathlib\n    import re\n    cmake = pathlib.Path(__file__).parent / 'CMakeLists.txt'\n    xeus_version = None\n    with open(str(cmake)) as f:\n        for line in f:\n            m = re.search(r'XEUS_PYTHON_GIT_TAG\\s+([^\\s)]+)', line)\n            if m is not None:\n                xeus_version = m.group(1)\n\n    if xeus_version is None:\n        raise ValueError(\"Couldn't find the version in CMakeLists.txt\")\nexcept Exception as e:\n    print('Could not determine the version of xeus_python')\n    print(e)\n    sys.exit(1)\n\n\ndef accept_file(name):\n    return not (\n        name.endswith('.a') or      # static libraries\n        name.endswith('.lib') or    # lib files\n        name.endswith('.hpp') or    # headers\n        name.endswith('.h') or      # headers\n        name.endswith('.cmake') or  # cmake files\n        name.endswith('.pc') or     # package-config files\n        name.endswith('.txt')       # text files\n    )\n\n\ndef cmake_process_manifest_hook(cmake_manifest):\n    print(cmake_manifest)\n    print('\\n\\n')\n    cmake_manifest = list(filter(accept_file, cmake_manifest))\n    print(cmake_manifest)\n    return cmake_manifest\n\n\nopenssl_config = os.environ.get('OPENSSL_CONFIG_COMMAND', './config')\nlibsodium_config = os.environ.get('LIBSODIUM_CONFIG_COMMAND', './configure')\n\nsetup(\n    name=\"xeus-python\",\n    version=xeus_version,\n    description='A wheel for xeus-python',\n    author='Sylvain Corlay, Johan Mabille, Martin Renou',\n    license='',\n    packages=['xpython'],\n    py_modules=['xpython_launcher'],\n    install_requires=[\n        'pygments>=2.3.1,<3',\n        'xeus-python-shell[ipython]>=0.5,<0.6'\n    ],\n    setup_requires=setup_requires,\n    cmake_args=['-DCMAKE_INSTALL_LIBDIR=lib', '-DPYTHON_EXECUTABLE:FILEPATH=' + python_path, f'-DOPENSSL_CONFIG:INTERNAL={openssl_config}',\n         f'-DLIBSODIUM_CONFIG:INTERNAL=\"{libsodium_config}\"'],\n    cmake_process_manifest_hook=cmake_process_manifest_hook\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools\",\n  \"wheel\",\n  \"scikit-build>=0.11.0,<0.14\",\n  \"cmake>=3.4\",\n  \"ninja\",\n  \"packaging<22\"\n]\n"
  },
  "InsightSoftwareConsortium/ITKIsotropicWavelets": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-isotropicwavelets',\n    version='0.6.1',\n    author='Pablo Hernandez-Cerdan',\n    author_email='pablo.hernandez.cerdan@outlook.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKIsotropicWavelets',\n    description=r'Steerable Wavelet Pyramid with Isotropic Wavelets and Riesz Functions',\n    long_description='itk-isotropicwavelets provides a multiresolution analysis '\n                     '(MRA) framework using isotropic and steerable wavelets in the frequency '\n                     'domain.\\n'\n                     'This framework provides the backbone for state of the art filters '\n                     'for denoising, feature detection or phase analysis in N-dimensions. '\n                     'It focuses on reusability, and highly decoupled modules for easy extension '\n                     'and implementation of new filters.\\n'\n                     'Please refer to:'\n                     'P. Hernandez-Cerdan, \u201cIsotropic and Steerable Wavelets in N Dimensions.\\n'\n                     'A multiresolution analysis framework\u201d, Insight Journal, January-December 2016 '\n                     'https://hdl.handle.net/10380/3558.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit Wavelet Pyramid Steerable Riesz',\n    url=r'https://github.com/InsightSoftwareConsortium/ITKIsotropicWavelets',\n    install_requires=[\n        r'itk>=5.2.post3',\n    ]\n    )\n"
  },
  "maxbachmann/CyDifflib": {
    "setup.py": "from skbuild import setup\r\n\r\nwith open('README.md', 'rt', encoding=\"utf8\") as f:\r\n    readme = f.read()\r\n\r\nsetup(\r\n    name=\"cydifflib\",\r\n    version=\"1.0.1\",\r\n    url=\"https://github.com/maxbachmann/cydifflib\",\r\n    author=\"Max Bachmann\",\r\n    author_email=\"pypi@maxbachmann.de\",\r\n    description=\"Fast implementation of difflib's algorithms\",\r\n    long_description=readme,\r\n    long_description_content_type=\"text/markdown\",\r\n\r\n    license=\"MIT\",\r\n    classifiers=[\r\n        \"Programming Language :: Python :: 3\",\r\n        \"Programming Language :: Python :: 3.6\",\r\n        \"Programming Language :: Python :: 3.7\",\r\n        \"Programming Language :: Python :: 3.8\",\r\n        \"Programming Language :: Python :: 3.9\",\r\n        \"Programming Language :: Python :: 3.10\",\r\n        \"Programming Language :: Python :: 3.11\",\r\n        \"License :: OSI Approved :: MIT License\"\r\n    ],\r\n\r\n    packages=[\"cydifflib\"],\r\n    package_dir={'':'src'},\r\n    zip_safe=True,\r\n    include_package_data=True,\r\n    python_requires=\">=3.6\",\r\n)\r\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build>=0.13.0\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\",\n    \"Cython==3.0.0b02\"\n]\nbuild-backend = \"setuptools.build_meta\""
  },
  "Kitware/LookingGlassVTKModule": {
    "setup.py": "import os\nfrom pathlib import Path\nimport platform\nimport shutil\nimport subprocess\nimport sys\n\nfrom skbuild import setup\n\n\nvtk_looking_glass_module_source_dir = Path(__file__).parent.resolve()\n\n\ndef auto_download_vtk_wheel_sdk():\n    # Automatically download the VTK wheel SDK based upon the current platform\n    # and python version.\n    # If the download location changes, we may need to change the logic here.\n    # Returns the path to the unpacked SDK.\n\n    base_url = 'https://vtk.org/files/wheel-sdks/'\n    prefix = 'vtk-wheel-sdk'\n    default_sdk_version = '9.2.2'\n    # The user can set the sdk version via an environment variable\n    sdk_version = os.getenv('VTK_WHEEL_SDK_VERSION', default_sdk_version)\n    py_version_short = ''.join(map(str, sys.version_info[:2]))\n\n    py_version = f'cp{py_version_short}-cp{py_version_short}'\n    if sys.version_info[:2] < (3, 8):\n        # Need to add 'm' at the end\n        py_version += 'm'\n\n    platform_suffixes = {\n        'linux': 'manylinux_2_17_x86_64.manylinux2014_x86_64',\n        'darwin': 'macosx_10_10_x86_64',\n        'win32': 'win_amd64',\n    }\n\n    if sys.platform not in platform_suffixes:\n        raise NotImplementedError(sys.platform)\n\n    platform_suffix = platform_suffixes[sys.platform]\n\n    if sys.platform == 'darwin':\n        is_arm = (\n            platform.machine() == 'arm64' or\n            # ARCHFLAGS: see https://github.com/pypa/cibuildwheel/discussions/997\n            os.getenv('ARCHFLAGS') == '-arch arm64'\n        )\n        if is_arm:\n            # It's an arm64 build\n            platform_suffix = 'macosx_11_0_arm64'\n\n    dir_name = f'{prefix}-{sdk_version}-{py_version}-{platform_suffix}'\n    default_install_path = Path('.').resolve() / f'_deps/{dir_name}'\n    install_path = Path(os.getenv('VTK_WHEEL_SDK_INSTALL_PATH',\n                                  default_install_path))\n\n    if install_path.exists():\n        # It already exists, just return it\n        return install_path.as_posix()\n\n    # Need to download it\n    full_name = f'{prefix}-{sdk_version}-{py_version}-{platform_suffix}.tar.xz'\n    url = f'{base_url}{full_name}'\n\n    script_path = str(vtk_looking_glass_module_source_dir /\n                      'FetchFromUrl.cmake')\n\n    cmd = [\n        'cmake',\n        f'-DFETCH_FROM_URL_PROJECT_NAME={prefix}',\n        f'-DFETCH_FROM_URL_INSTALL_LOCATION={install_path.as_posix()}',\n        f'-DFETCH_FROM_URL_URL={url}',\n        '-P', script_path,\n    ]\n    subprocess.check_call(cmd)\n\n    return install_path.as_posix()\n\n\ndef auto_download_vtk_external_module():\n    # Automatically download the VTKExternalModule repository.\n    # Returns the path to the VTKExternalModule directory.\n\n    external_module_path = Path('.').resolve() / '_deps/VTKExternalModule'\n    if external_module_path.exists():\n        # It must have already been downloaded. Just return it.\n        return external_module_path.as_posix()\n\n    # Run the script to download it\n    script_path = str(vtk_looking_glass_module_source_dir /\n                      'FetchVTKExternalModule.cmake')\n    cmd = [\n        'cmake',\n        '-DFETCH_VTKExternalModule_INSTALL_LOCATION=' +\n        external_module_path.as_posix(),\n        '-P', script_path,\n    ]\n    subprocess.check_call(cmd)\n    return external_module_path.as_posix()\n\n\nvtk_wheel_sdk_path = os.getenv('VTK_WHEEL_SDK_PATH')\nif vtk_wheel_sdk_path is None:\n    vtk_wheel_sdk_path = auto_download_vtk_wheel_sdk()\n\n# Find the cmake dir\ncmake_glob = list(Path(vtk_wheel_sdk_path).glob('**/headers/cmake'))\nif len(cmake_glob) != 1:\n    raise Exception('Unable to find cmake directory')\n\nvtk_wheel_sdk_cmake_path = cmake_glob[0]\n\nvtk_external_module_path = os.getenv('VTK_EXTERNAL_MODULE_PATH')\nif vtk_external_module_path is None:\n    # If it was not provided, clone it into a temporary directory\n    # Since we are using pyproject.toml, it will get removed automatically\n    vtk_external_module_path = auto_download_vtk_external_module()\n\npython3_executable = os.getenv('Python3_EXECUTABLE')\nif python3_executable is None:\n    python3_executable = shutil.which('python')\n\nif python3_executable is None:\n    msg = 'Unable find python executable, please set Python3_EXECUTABLE'\n    raise Exception(msg)\n\ncmake_args = [\n    '-DVTK_MODULE_NAME:STRING=RenderingLookingGlass',\n    f'-DVTK_MODULE_SOURCE_DIR:PATH={vtk_looking_glass_module_source_dir}',\n    f'-DVTK_MODULE_CMAKE_MODULE_PATH:PATH={vtk_wheel_sdk_cmake_path}',\n    f'-DVTK_DIR:PATH={vtk_wheel_sdk_cmake_path}',\n    '-DCMAKE_INSTALL_LIBDIR:STRING=lib',\n    f'-DPython3_EXECUTABLE:FILEPATH={python3_executable}',\n    '-DVTK_WHEEL_BUILD:BOOL=ON',\n    '-S', vtk_external_module_path,\n]\n\nif sys.platform == 'linux':\n    # We currently have to add this for the render window to get compiled\n    cmake_args.append('-DVTK_USE_X:BOOL=ON')\n\n    if os.getenv('LINUX_VTK_LOOKING_GLASS_USE_COMPATIBLE_ABI') == '1':\n        # If building locally, it is necessary to set this in order to\n        # produce a wheel that can be used. Otherwise, the VTK symbols\n        # will not match those in the actual VTK wheel.\n        cmake_args.append('-DCMAKE_CXX_FLAGS=-D_GLIBCXX_USE_CXX11_ABI=0')\n\nelif sys.platform == 'darwin':\n    # We currently have to add this for the render window to get compiled\n    cmake_args.append('-DVTK_USE_COCOA:BOOL=ON')\n\n    if os.getenv('ARCHFLAGS') == '-arch arm64':\n        # We are cross-compiling and need to set CMAKE_SYSTEM_NAME as well.\n        # NOTE: we haven't actually succeeded in cross-compiling this module.\n        cmake_args.append('-DCMAKE_SYSTEM_NAME=Darwin')\n\nsetup(\n    name='vtk-lookingglass',\n    description='Looking Glass support for VTK Python.',\n    long_description='Looking Glass support for VTK Python.',\n    url='',\n    author='VTK developers',\n    license='MIT',\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3',\n    ],\n    keywords='',\n    packages=['vtkmodules'],\n    package_dir={'vtkmodules': 'lib/vtkmodules'},\n    cmake_args=cmake_args,\n    install_requires=['vtk==9.2.2'],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"cmake\",\n  \"ninja\",\n  \"scikit-build\",\n  \"setuptools>=42\",\n  \"wheel\",\n  \"setuptools_scm[toml]>=6.2\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\n"
  },
  "cms-nanoAOD/correctionlib": {
    "setup.py": "#!/usr/bin/env python\n# Copyright (c) 2021, Nick Smith\n#\n# Distributed under the 3-clause BSD license, see accompanying file LICENSE\n# or https://github.com/nsmith-/correctionlib for details.\n\nfrom setuptools import find_packages\nfrom setuptools_scm import get_version\nfrom skbuild import setup\n\nsetup(\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src\",\n    cmake_args=[f\"-DCORRECTIONLIB_VERSION:STRING={get_version()}\"],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"wheel\",\n    \"setuptools>=42\",\n    \"setuptools_scm[toml]>=3.4\",\n    \"pybind11>=2.6.1\",\n    \"scikit-build\",\n    \"cmake>=3.11.0\",\n    \"make\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"src/correctionlib/version.py\"\n\n[tool.cibuildwheel]\nskip = [\"pp*-*\", \"cp311-*\"]\ntest-extras = \"test\"\ntest-command = \"python -m pytest {package}/tests\"\n# update skip when numpy wheels become available\ntest-skip = [\"pp*-*\", \"*-musllinux_*\", \"cp310-win32\", \"cp310-manylinux_i686\"]\nmanylinux-x86_64-image = \"manylinux2014\"\nmanylinux-i686-image = \"manylinux2014\"\n\n[tool.cibuildwheel.environment]\n# this makes sure that we build only on platforms that have a corresponding numpy wheel\nPIP_ONLY_BINARY = \":all:\"\n",
    "setup.cfg": "[metadata]\nname = correctionlib\nauthor = Nick Smith\nauthor_email = nick.smith@cern.ch\nmaintainer = Nick Smith\nmaintainer_email = nick.smith@cern.ch\ndescription = A generic correction library\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nurl = https://github.com/cms-nanoAOD/correctionlib\nlicense = BSD 3-Clause License\n# keywords =\nplatforms =\n  Any\nclassifiers =\n  Topic :: Scientific/Engineering\n  Intended Audience :: Science/Research\n  Intended Audience :: Developers\n  Operating System :: OS Independent\n  License :: OSI Approved :: BSD License\n  Programming Language :: Python\n  Programming Language :: Python :: 3\n  Programming Language :: Python :: 3.6\n  Programming Language :: Python :: 3.7\n  Programming Language :: Python :: 3.8\n  Programming Language :: Python :: 3.9\n  Development Status :: 1 - Planning\n\n[options]\npython_requires = >=3.6\ninstall_requires =\n  numpy >=1.13.3\n  typing; python_version<\"3.5\"\n  typing-extensions;python_version<\"3.8\"\n  dataclasses;python_version<\"3.7\"\n  pydantic >=1.7.3\n  rich\n\n[options.extras_require]\ntest =\n  pytest >=4.6\n  scipy\ndev =\n  pytest >=4.6\n  pre-commit\n  mypy\n  uhi\ndocs =\n  recommonmark >=0.5.0\n  Sphinx >=3.0.0\n  sphinx_copybutton\n  sphinx_rtd_theme >=0.5.0\n  sphinx-jsonschema\n  myst-parser\n  nbsphinx\nconvert =\n  pandas\n  uproot >=4.0.4\n  requests\n  scipy\n\n[options.entry_points]\nconsole_scripts =\n    correction = correctionlib.cli:main\n\n[tool:pytest]\naddopts = -rs -s -Wd\ntestpaths =\n    tests\n\n[check-manifest]\nignore =\n  .github/**\n  docs/**\n  .pre-commit-config.yaml\n  .readthedocs.yml\n  src/*/version.py\n  data/**\n  Makefile\n  cpp-peglib/**\n  pybind11/**\n  rapidjson/**\n\n[flake8]\nignore = E203, E231, E501, E722, W503, B902, B905, B950\nselect = C,E,F,W,T,B,B9,I\nper-file-ignores =\n    tests/*: T\n\n[isort]\nmulti_line_output = 3\ninclude_trailing_comma = True\nforce_grid_wrap = 0\nuse_parentheses = True\nensure_newline_before_comments = True\nline_length = 88\n\n[mypy]\nfiles = src\npython_version = 3.6\nwarn_unused_configs = True\n\ndisallow_any_generics = True\n# otherwise need pydantic dataclasses\ndisallow_subclassing_any = False\ndisallow_untyped_calls = True\ndisallow_untyped_defs = True\ndisallow_incomplete_defs = True\ncheck_untyped_defs = True\ndisallow_untyped_decorators = True\nno_implicit_optional = True\nwarn_redundant_casts = True\nwarn_unused_ignores = True\nwarn_return_any = True\nno_implicit_reexport = True\nstrict_equality = True\n\n[mypy-numpy]\nignore_missing_imports = True\n\n[mypy-uproot]\nignore_missing_imports = True\n"
  },
  "NiftyPET/NIMPA": {
    "setup.py": "#!/usr/bin/env python3\n\"\"\"\nCompile CUDA source code and setup Python 3 package 'nimpa'\nfor namespace 'niftypet'.\n\"\"\"\nimport logging\nimport re\nimport sys\nfrom pathlib import Path\n\nfrom setuptools import find_packages, setup\nfrom setuptools_scm import get_version\n\nfrom niftypet.ninst import cudasetup as cs\nfrom niftypet.ninst import dinf\nfrom niftypet.ninst import install_tools as tls\n\n__version__ = get_version(root=\".\", relative_to=__file__)\n\nlogging.basicConfig(level=logging.INFO, format=tls.LOG_FORMAT)\nlog = logging.getLogger(\"nimpa.setup\")\n\ntls.check_platform()\next = tls.check_depends() # external dependencies\n\ncs.resources_setup(gpu=False) # install resources.py\ntry:\n    cs.dev_setup()            # update resources.py with a supported GPU device\nexcept Exception as exc:\n    log.error(\"could not set up CUDA:\\n%s\", exc)\n\n# get the local path to NiftyPET resources.py\npath_resources = cs.path_niftypet_local()\n# if exists, import the resources and get the constants\nresources = cs.get_resources()\n# get the current setup, if any\nCnt = resources.get_setup()\n\nbuild_ver = \".\".join(__version__.split('.')[:3]).split(\".dev\")[0]\nsetup_kwargs = {\n    \"use_scm_version\": True, \"packages\": find_packages(exclude=[\"tests\"]),\n    \"package_data\": {\"niftypet\": [\"nimpa/auxdata/*\"]}, \"install_requires\": [\n        'dipy>=1.3.0', 'miutil[nii]>=0.10.0', 'nibabel>=2.4.0', 'ninst>=0.12.0', 'numpy>=1.14',\n        'pydicom>=1.0.2', 'scipy', 'setuptools', 'spm12']}\n# 'SimpleITK>=1.2.0'\ncmake_args = [\n    f\"-DNIMPA_BUILD_VERSION={build_ver}\", f\"-DPython3_ROOT_DIR={sys.prefix}\",\n    f\"-DNIMPA_KERNEL_RADIUS={getattr(resources, 'RSZ_PSF_KRNL', 8)}\"]\n\ntry:\n    import cuvec as cu\n    from skbuild import setup as sksetup\n    assert cu.include_path.is_dir()\n    nvcc_arches = {\"{2:d}{3:d}\".format(*i) for i in dinf.gpuinfo() if i[2:4] >= (3, 5)}\n    if nvcc_arches:\n        cmake_args.append(\"-DCMAKE_CUDA_ARCHITECTURES=\" + \";\".join(sorted(nvcc_arches)))\nexcept Exception as exc:\n    log.warning(\"Import or CUDA device detection error:\\n%s\", exc)\n    setup(**setup_kwargs)\nelse:\n    setup_kwargs['install_requires'].extend([\"cuvec>=2.3.1\", \"numcu\"])\n    for i in (Path(__file__).resolve().parent / \"_skbuild\").rglob(\"CMakeCache.txt\"):\n        i.write_text(re.sub(\"^//.*$\\n^[^#].*pip-build-env.*$\", \"\", i.read_text(), flags=re.M))\n    sksetup(cmake_source_dir=\"niftypet\", cmake_languages=(\"C\", \"CXX\", \"CUDA\"),\n            cmake_minimum_required_version=\"3.18\", cmake_args=cmake_args, **setup_kwargs)\n",
    "pyproject.toml": "[build-system]\n# cuvec>=2.8.0\nrequires = [\"setuptools>=42\", \"wheel\", \"setuptools_scm[toml]>=3.4\",\n            \"ninst>=0.12.0\", \"cuvec-base\", \"miutil[cuda]>=0.4.0\",\n            \"scikit-build>=0.11.0\", \"cmake>=3.18\", \"ninja\"]\n\n[tool.setuptools_scm]\nwrite_to = \"niftypet/nimpa/_dist_ver.py\"\nwrite_to_template = \"__version__ = '{version}'\\n\"\n",
    "setup.cfg": "[metadata]\nname=nimpa\ndescription=CUDA-accelerated Python utilities for high-throughput neuroimage processing and analysis\nlong_description=file: README.rst\nlong_description_content_type=text/x-rst\nlicense=Apache 2.0\nlicense_file=LICENCE\nurl=https://github.com/NiftyPET/NIMPA\nproject_urls=\n    Changelog=https://github.com/NiftyPET/NIMPA/releases\n    Documentation=https://niftypet.readthedocs.io\nauthor=Pawel Markiewicz\nauthor_email=p.markiewicz@ucl.ac.uk\nmaintainer=Casper da Costa-Luis\nmaintainer_email=casper.dcl@physics.org\nkeywords=PET, MR, processing, analysis\nclassifiers=\n    Development Status :: 5 - Production/Stable\n    Environment :: GPU\n    Environment :: GPU :: NVIDIA CUDA\n    Intended Audience :: Education\n    Intended Audience :: Healthcare Industry\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: Apache Software License\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX :: Linux\n    Programming Language :: C\n    Programming Language :: C++\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3 :: Only\n    Topic :: Scientific/Engineering :: Medical Science Apps.\n[options]\nzip_safe=False\nsetup_requires=\n    setuptools>=42\n    wheel\n    setuptools_scm[toml]\n    ninst>=0.12.0\n    scikit-build>=0.11.0\n    cmake>=3.18\n    ninja\n    cuvec-base\n    miutil[cuda]>=0.4.0\npython_requires=>=3.6\n[options.extras_require]\ndev=\n    pre-commit\n    pytest\n    pytest-cov\n    pytest-timeout\n    pytest-xdist\nplot=miutil[plot]\ncuda=cuvec>=2.3.1; numcu\ndcm2niix=dcm2niix>=1.0.20220116\nniftyreg=niftyreg\n\n[flake8]\nmax_line_length=99\nextend-ignore=W504,E225,E228,E261,E701,P1\nexclude=.git,__pycache__,build,dist,.eggs\n\n[yapf]\nspaces_before_comment=15, 20\narithmetic_precedence_indication=true\nallow_split_before_dict_value=false\ncoalesce_brackets=True\ncolumn_limit=99\neach_dict_entry_on_separate_line=False\nspace_between_ending_comma_and_closing_bracket=False\nsplit_before_named_assigns=False\nsplit_before_closing_bracket=False\n\n[isort]\nprofile=black\nline_length=99\nknown_first_party=niftypet,tests\n\n[tool:pytest]\ntimeout=300\nlog_level=INFO\npython_files=tests/test_*.py\naddopts=-v --tb=short -rxs -W=error -n=auto --durations=0 --durations-min=2 --cov=niftypet --cov-report=term-missing --cov-report=xml\n"
  },
  "trep/opentrep": {
    "setup.py": "\nimport os, sys, setuptools\nfrom skbuild import setup\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup (\n    name='opentrep',\n    version='0.7.12',\n    author='Denis Arnaud',\n    author_email='denis.arnaud_pypi@m4x.org',\n    description=('''Simple Python wrapper for OpenTREP'''),\n    license='MIT',\n    keywords='api python trep opentrep package',\n    url='https://github.com/trep/opentrep',\n    packages=setuptools.find_packages(),\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    install_requires=[\n        'protobuf'\n    ],\n    cmake_args = [\n      '-DINSTALL_DOC:BOOL=OFF',\n      '-DRUN_GCOV:BOOL=OFF',\n      '-DLIB_SUFFIX='\n      ] + (\n      ['-DREADLINE_ROOT=/usr/local/opt/portable-readline',\n       '-DREADLINE_INCLUDE_DIR=/usr/local/opt/portable-readline/include',\n       '-DREADLINE_LIBRARY=/usr/local/opt/libedit/lib/libedit.dylib',\n       '-DICU_ROOT=/usr/local/opt/icu4c'] if sys.platform.startswith(\"darwin\") else []\n      )\n)\n\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n\n"
  },
  "cellml/libcellml": {
    "src/bindings/python/cibuildwheel.setup.py": "\"\"\" libCellML Library: A library for the parsing, printing, and manipulation\nof CellML 2.0 compliant models.\n\n\"\"\"\n\nclassifiers = \"\"\"\\\nDevelopment Status :: 5 - Production/Stable\nIntended Audience :: Developers\nIntended Audience :: Education\nIntended Audience :: Science/Research\nLicense :: OSI Approved :: Apache Software License\nProgramming Language :: Python\nOperating System :: Microsoft :: Windows\nOperating System :: Unix\nOperating System :: MacOS :: MacOS X\nTopic :: Software Development :: Libraries :: Python Modules\n\"\"\"\n\nimport os\nimport platform\n\nfrom skbuild import setup\n\ncmake_args = [\"-DUNIT_TESTS=OFF\", \"-DCOVERAGE=OFF\", \"-DMEMCHECK=OFF\", \"-DLLVM_COVERAGE=OFF\", \"-DCLANG_TIDY=OFF\"]\n\nif platform.system() == \"Windows\":\n    cmake_args.append(\"-DLibXml2_DIR=C:/Program Files (x86)/libxml2/libxml2-2.9.10/CMake/\")\n\ndoclines = __doc__.split(\"\\n\")\n\ntag = os.environ.get(\"LIBCELLML_VERSION_TAG\", \"v0.0.0\")\n\nsetup(\n    name=\"libcellml\",\n    version=tag[1:],\n    description=doclines[0],\n    author=\"libCellML contributors\",\n    url=\"https://libcellml.org\",\n    license=\"Apache 2.0\",\n    packages=[\"libcellml\"],\n    classifiers=classifiers.split(\"\\n\"),\n    long_description=open('README.rst').read(),\n    long_description_content_type='text/x-rst',\n    include_package_data=True,\n    cmake_source_dir=\"../../../\",\n    cmake_install_target=\"install-wheel\",\n    cmake_args=cmake_args,\n    exclude_package_data={\"\": [\"bin/*\", \"cmake/*\", \"include/*\", \"lib/*\"]},\n)\n",
    "src/bindings/python/pyproject.toml": "[build-system]\nrequires = [\n    'setuptools',\n    'wheel',\n    'scikit-build>=0.12',\n    'cmake',\n    'ninja',\n]\nbuild-backend = 'setuptools.build_meta'\n\n"
  },
  "OpenJij/cimod": {
    "setup.py": "# Copyright 2022 Jij Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    from setuptools import setup\n\nsetup_requires = [\n    \"numpy\",\n    \"pybind11 >=2.10.0, < 2.11.0\",\n    \"cmake > 3.20\",\n    \"scikit-build > 0.16.0\"\n]\n\nif any(arg in sys.argv for arg in (\"pytest\", \"test\")):\n    setup_requires.append(\"pytest-runner\")\n\nsetup(\n    setup_requires=setup_requires,\n    packages=[\n        \"cimod\",\n        \"cimod.utils\",\n        \"cimod.model\",\n        \"cimod.model.legacy\",\n    ],\n    cmake_install_dir=\"cimod\",\n    include_package_data=False,\n    zip_safe=False,\n)\n",
    "pyproject.toml": "# Copyright 2022 Jij Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nrequires = [\n   'setuptools_scm[toml]', \n   'setuptools',\n   'wheel',\n   'build',\n   'oldest-supported-numpy',\n   'pybind11',\n   'scikit-build',\n   ]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"cimod/_version.py\"\n\n[tool.pytest.ini_options]\naddopts = \"--doctest-modules --color=yes --code-highlight=yes --cov-context=test --cov --cov-append --cov-report term --randomly-seed=last -v --capture=no\"\ntestpaths = [\n    \"tests\",\n]\nspec_header_format = \"{module_path}:\"\nspec_test_format = \"{result} {name}\"\nlog_level = \"INFO\"\nconsole_output_style = \"count\"\nlog_auto_indent = true\njunit_logging = \"all\"\n\n[tool.flake8] \nshow-source = true\nstatistics = true\ndoctests = true\nmax-complexity = 10\nmax-line-length = 999 \n\n[tool.isort]\nprofile= \"black\"\nmulti_line_output = 3\nforce_grid_wrap = 0\ninclude_trailing_comma = false\nensure_newline_before_comments = true\nuse_parentheses = true \nbalanced_wrapping = false\nlines_between_types = 1\n#order_by_type = true \ncombine_as_imports = true\ncombine_star = true\ncombine_straight_imports = true\ngroup_by_package = true\nauto_identify_namespace_packages = true\nsrc_paths = [\"openjij\", \"tests\"]\n\n[tool.black]\ntarget-version = ['py39', 'py310']\n\n[tool.mypy]\nignore_missing_imports = true\n#show_traceback = true\nwarn_return_any = true\nwarn_unused_configs = true\nwarn_unreachable = true\nnamespace_packages = true\nexplicit_package_bases = true\n#show_error_context = true \n#show_column_numbers = true\n\n[tool.pyright]\npythonVersion = \"3.9\"\ntypeCheckingMode = \"basic\"\ninclude = [\n    \"cimod\", \n    \"tests\",\n  ]\nignore = [ \n  \"*.c\", \n  \"*.so\",\n]\nreportImportCycles = 'warning'\nreportUnusedImport = 'warning'\nreportUnusedVariable =  'warning'\nreportDuplicateImport = 'warning'\n\n[tool.cibuildwheel]\nskip = [\"cp36*\", \"cp311*\", \"*musllinux_x86_64\", \"*musllinux_aarch64\", \"pp*\"]\nbuild-verbosity = 1\ndependency-versions = \"latest\"\n\n[tool.cibuildwheel.linux]\narchs = [\"x86_64\", \"aarch64\"]\nbuild-frontend = \"build\"\n#environment = \"-CFLAGS='-march=haswell' -CXXFLAGS='-march=haswell' -FFLAGS='-march=haswell'\"\nmanylinux-x86_64-image =\"quay.io/pypa/manylinux_2_28_x86_64:latest\"\nmanylinux-aarch64-image = \"quay.io/pypa/manylinux_2_28_aarch64:latest\"\nrepair-wheel-command = \"auditwheel repair --lib-sdir . -w {dest_dir} {wheel}\"\n\n[tool.cibuildwheel.macos]\narchs = [\"x86_64\", \"arm64\"]\nbuild-frontend = \"build\"\nbefore-build = [ \n    \"pip install --upgrade pip wheel build pybind11 cmake ninja\", \n]\n\n[tool.cibuildwheel.windows]\narchs = [\"AMD64\"]\n#\"vcpkg --triplet x64-windows-static install openblas[threads] --recurse\", \n#\"vcpkg --triplet x64-windows-static install clapack --recurse\", \nbefore-build = [ \n    \"pip install --upgrade pip wheel build cmake pybind11 delvewheel\", \n]\nrepair-wheel-command = \"delvewheel repair -w {dest_dir} {wheel}\"\n",
    "setup.cfg": "# Copyright 2022 Jij Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[install_lib]\noptimize = 1\ncompile = 1\n\n[aliases]\ntest=pytest\n\n[metadata]\nname=jij_cimod\nurl = https://www.openjij.org\nauthor = Jij Inc.\nauthor_email = info@openjij.org\ndescription = C++ library for a binary (and polynomial) quadratic model.\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nlicense_files = LICENSE\nlicense = Apache License 2.0\nclassifiers =\n    License :: OSI Approved :: Apache Software License\n    Intended Audience :: Science/Research\n    Programming Language :: Python\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3 :: Only\n    Programming Language :: Python :: Implementation :: CPython\n    Operating System :: Microsoft :: Windows\n    Operating System :: POSIX\n    Operating System :: Unix\n    Operating System :: MacOS\nproject_urls =\n    Source=https://github.com/OpenJij/cimod\n    Documentation=http://openjij.github.io/Cimod-Documentation/\n    PythonDocumentation=https://openjij.github.io/cimod/\n  \n\n[options]\npython_requires = >=3.7, <3.11\ninstall_requires =\n    numpy >=1.17.3, < 1.25.0\n    dimod < 0.13.0\n    scipy >= 1.7.3, < 1.11.0\ntests_require =\n    pytest\n    pytest-mock\n    pytest-cov\n    pytest-runner\n    pytest-randomly\n    pytest-spec\n    coverage\n"
  },
  "epiqc/PartialCompilation": {
    "qiskit-aer/setup.py": "import os\ntry:\n    from skbuild import setup\n    dummy_install = False\nexcept:\n    print(\"\"\" WARNING\n              =======\n              scikit-build package is needed to build Aer sources.\n              Please, install scikit-build and reinstall Aer:\n              pip install -I qiskit-aer \"\"\")\n    from setuptools import setup\n    dummy_install = True\nfrom setuptools import find_packages\n\nrequirements = [\n    \"numpy>=1.13\"\n]\n\nVERSION_PATH = os.path.join(os.path.dirname(__file__),\n                            \"qiskit\", \"providers\", \"aer\", \"VERSION.txt\")\nwith open(VERSION_PATH, \"r\") as version_file:\n    VERSION = version_file.read().strip()\n\n\ndef find_qiskit_aer_packages():\n    location = 'qiskit/providers'\n    prefix = 'qiskit.providers'\n    aer_packages = find_packages(where=location)\n    pkg_list = list(\n        map(lambda package_name: '{}.{}'.format(prefix, package_name),\n            aer_packages)\n    )\n    return pkg_list\n\n\nsetup(\n    name='qiskit-aer',\n    version=VERSION,\n    packages=find_qiskit_aer_packages() if not dummy_install else [],\n    cmake_source_dir='.',\n    description=\"Qiskit Aer - High performance simulators for Qiskit\",\n    url=\"https://github.com/Qiskit/qiskit-aer\",\n    author=\"AER Development Team\",\n    author_email=\"qiskit@us.ibm.com\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Environment :: Console\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3.5\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Topic :: Scientific/Engineering\",\n    ],\n    install_requires=requirements,\n    include_package_data=True,\n    keywords=\"qiskit aer simulator quantum addon backend\"\n)\n",
    "qiskit-aer/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]"
  },
  "RangamaniLabUCSD/Mem3DG": {
    "setup.py": "# Membrane Dynamics in 3D using Discrete Differential Geometry (Mem3DG)\n# \n# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n# \n# Copyright (c) 2020:\n#     Laboratory for Computational Cellular Mechanobiology\n#     Cuncheng Zhu (cuzhu@eng.ucsd.edu)\n#     Christopher T. Lee (ctlee@ucsd.edu)\n#     Ravi Ramamoorthi (ravir@cs.ucsd.edu)\n#     Padmini Rangamani (prangamani@eng.ucsd.edu)\n# \n\n\"\"\"PyMem3DG: Membrane Dynamics in 3D using Discrete Differential Geometry\n\nPyMem3DG performs membrane simulations.\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport re\n\n\ndef git_version():\n    \"\"\"Get the version from git describe\n\n    Returns:\n        string: version string or None if invalid\n    \"\"\"\n    def _minimal_ext_cmd(cmd):\n        # construct minimal environment\n        env = {}\n        for k in [\"SYSTEMROOT\", \"PATH\", \"HOME\"]:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        # LANGUAGE is used on win32\n        env[\"LANGUAGE\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n        env[\"LC_ALL\"] = \"C\"\n        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, env=env)\n        return out\n\n    try:\n        out = _minimal_ext_cmd([\"git\", \"describe\", \"--tags\", \"--dirty\", \"--always\"])\n        GIT_REVISION = out.strip().decode(\"ascii\")\n    except (subprocess.SubprocessError, OSError):\n        GIT_REVISION = None\n\n    return GIT_REVISION\n\ndef standardize_version(version_string):\n    \"\"\"Standardize the version string\n    \n    Args:\n        version_string (str): input version string \n    Returns:\n        str: standardized version\n    \"\"\"\n    VERSION_PATTERN = r\"\"\"\n        v?\n        (?:\n            (?:(?P<epoch>[0-9]+)!)?                           # epoch\n            (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n            (?P<pre>                                          # pre-release\n                [-_\\.]?\n                (?P<pre_l>(alpha|beta|a|b|c|rc))\n                (?P<pre_n>[0-9]+)?\n            )?\n            (?P<dev>                                          # dev release\n                [-_\\.]?\n                (?P<dev_l>dev)\n                [-_\\.]?\n                (?P<dev_n>[0-9]+)?\n            )?\n            (?P<meta>\n                [-_\\.]?\n                (?P<commits_since>[0-9]+)?\n                [-_\\.]?\n                (?P<sha>[a-z0-9]*)?\n                [-_\\.]? \n                (?P<dirty>dirty)?\n            )?\n        )\n    \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    match = _regex.match(version_string)\n    if match:\n        if match.group(\"release\"):\n            version = match.group(\"release\")\n            if match.group(\"pre_l\"):\n                version += match.group(\"pre_l\")\n                if match.group(\"pre_n\"):\n                    version += match.group(\"pre_n\")\n                else:\n                    version += \"0\"\n            if match.group(\"dev\"):\n                version += \"dev\"\n                if match.group(\"dev_n\"):\n                    version += match.group(\"dev_n\")\n                else:\n                    version += \"0\"\n    else:\n        version = \"0.0.0\"\n    return version\n\nversion = git_version()\nif version is None:\n    # Git describe failed... read version from file\n    with open(\"VERSION\", \"r\") as f:\n        version = f.readline()\n    version = standardize_version(version)\nelse:\n    version = standardize_version(version)\n\n\ncmake_args=['-DBUILD_PYMEM3DG=ON', '-DSUITESPARSE=OFF']\n\nif('CONDA_PREFIX' in os.environ):\n    print(\"Setting library search path (CMAKE_PREFIX_PATH): %s\"%(os.environ['CONDA_PREFIX']))\n    cmake_args.append('-DCMAKE_PREFIX_PATH=%s'%(os.environ['CONDA_PREFIX']))\n\nDOCLINES = __doc__.split(\"\\n\")\n\nCLASSIFIERS = \"\"\"\\\nDevelopment Status :: 3 - Alpha\nEnvironment :: Console\nIntended Audience :: Science/Research\nLicense :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)\nNatural Language :: English\nOperating System :: OS Independent\nProgramming Language :: C++\nProgramming Language :: Python :: 3 :: Only\nProgramming Language :: Python :: Implementation :: CPython\nTopic :: Scientific/Engineering :: Chemistry\nTopic :: Scientific/Engineering :: Mathematics\nTopic :: Scientific/Engineering :: Physics\nTopic :: Scientific/Engineering :: Visualization\n\"\"\"\n\n# If building on readthedocs.io build with unix makefiles\n_on_rtd = os.environ.get(\"READTHEDOCS\", None) == \"True\"\nif _on_rtd:\n    sys.argv.extend([\"-G\", \"Unix Makefiles\"])\n    cmake_args.append(\"-DBUILD_MEM3DG_DOCS=ON\")\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('\\nERROR: scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build\\n', file=sys.stderr)\n    print('  -- or --\\n', file=sys.stderr)\n    print('  conda install scikit-build', file=sys.stderr)\n    sys.exit(1)\n\ntests_require = [\"pytest\"]\n\nfrom setuptools import find_packages\n\nsetup(\n    name=\"pymem3dg\",\n    version=version,\n    maintainer=\"Cuncheng Zhu and Christopher T. Lee\",\n    maintainer_email=\"cuzhu@ucsd.edu, ctlee@ucsd.edu\",\n    author=\"The Mem3DG Team\",\n    author_email=\"cuzhu@ucsd.edu, ctlee@ucsd.edu\",\n    url=\"https://github.com/RangamaniLabUCSD/Mem3DG\",\n    packages=find_packages(where=\"python_src\"),\n    package_dir={\"\": \"python_src\"},\n    cmake_install_dir=\"python_src/pymem3dg\",    \n    include_package_data=True,\n    extras_require={\"test\": [\"pytest\"]},\n\n    description=DOCLINES[0],\n    long_description=open(\"README.md\", encoding=\"utf8\").read(),\n    long_description_content_type=\"text/markdown\",\n    platforms=[\"Windows\", \"Linux\", \"Mac OS-X\", \"Unix\"],\n    classifiers=[c for c in CLASSIFIERS.split(\"\\n\") if c],\n    keywords=\"meshing membrane mechanics\",\n    cmake_args=cmake_args,\n    zip_safe=False,\n)",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"pybind11\"]\n",
    "setup.cfg": "[aliases]\ntest=pytest\n\n[tool:pytest]\naddopts = --verbose\npython_files = tests/python/*\nnorecursedirs = build _skbuild cmake docs include libraries src .git .github\n"
  },
  "Narasimha1997/py-smartreply": {
    "setup.py": "from skbuild import setup\n\nlong_description = open('README.md').read()\n\nsetup(\n    name=\"py_smartreply\",\n    version=\"0.0.1\",\n    author=\"Narasimha Prasanna HN\",\n    author_email=\"narasimhaprasannahn@gmail.com\",\n    description=\"Python bindings for Tensorflow Lite Smart-Reply Runtime.\",\n    url=\"https://github.com/Narasimha1997/py_cpu.git\",\n    license=\"Apache 2.0 License\",\n    has_package_data=False,\n    package_dir={\"\": \"src\"},\n    packages = [\"smartreply\"],\n    cmake_install_dir = \"src/smartreply\",\n    package_data = {\"smartreply\" : ['*.tflite']},\n    classifiers=[\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Developers',\n        'Topic :: System :: Hardware',\n        'License :: OSI Approved :: Apache Software License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.2',\n        'Programming Language :: Python :: 3.4',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.9',      \n    ],\n    python_requires='>=3',\n    long_description = long_description,\n    long_description_content_type = 'text/markdown'\n)"
  },
  "dfm/kepler.py": {
    "setup.py": "from setuptools import find_packages\nfrom skbuild import setup\n\nsetup(\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/kepler\",\n    include_package_data=True,\n)\n",
    "pyproject.toml": "[project]\nname = \"kepler.py\"\ndescription = \"Fast and stable solver for Kepler's equation in Python\"\nauthors = [{ name = \"Dan Foreman-Mackey\", email = \"foreman.mackey@gmail.com\" }]\nreadme = \"README.md\"\nrequires-python = \">=3.7\"\nlicense = { file = \"LICENSE\" }\nclassifiers = [\n    \"Operating System :: OS Independent\",\n    \"Programming Language :: Python :: 3\",\n    \"Development Status :: 4 - Beta\",\n    \"License :: OSI Approved :: MIT License\",\n]\ndynamic = [\"version\"]\ndependencies = [\"numpy\"]\n\n[project.urls]\n\"Homepage\" = \"https://github.com/dfm/kepler.py\"\n\"Source\" = \"https://github.com/dfm/kepler.py\"\n\"Bug Tracker\" = \"https://github.com/dfm/kepler.py/issues\"\n\n[project.optional-dependencies]\ntest = [\"pytest\"]\ndocs = []\n\n[build-system]\nrequires = [\n    \"setuptools>=61.0\",\n    \"wheel\",\n    \"setuptools_scm\",\n    \"pybind11>=2.6\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"src/kepler/version.py\"\n\n[tool.black]\nline-length = 79\n\n[tool.isort]\nskip_glob = []\nline_length = 79\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nknown_first_party = [\"kepler\"]\n\n[tool.coverage.run]\nparallel = true\nbranch = true\nsource = [\"kepler\"]\nomit = [\"docs/*\", \"tests/*\", \"*/kepler/kepler_version.py\"]\n\n[tool.coverage.paths]\nsource = [\"src\", \"*/site-packages\"]\n\n[tool.coverage.report]\nshow_missing = true\n"
  },
  "reticula-network/reticula-python": {
    "setup.py": "import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml\"\n        \" yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom skbuild.cmaker import get_cmake_version\nfrom setuptools import find_packages\n\nsetup(\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/reticula\",\n    include_package_data=True,\n)\n",
    "pyproject.toml": "[project]\nname = \"reticula\"\nversion = \"0.9.0\"\ndescription=\"Analyse temporal network and hypergraphs efficiently.\"\nauthors = [{name=\"Arash Badie-Modiri\", email=\"arashbm@gmail.com\"}]\nrequires-python = \">=3.8\"\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nkeywords = [\n    \"Complex Networks\", \"Networks\", \"network\",\n    \"Graphs\", \"Graph Theory\", \"graph\",\n    \"Temporal Networks\", \"temporal network\",\n    \"Hypergraphs\", \"hypergraph\", \"hyper-graph\"\n]\n\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Education\",\n    \"Intended Audience :: Science/Research\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: POSIX :: Linux\",\n    \"Programming Language :: C++\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Topic :: Scientific/Engineering\",\n    \"Topic :: Scientific/Engineering :: Physics\",\n    \"Topic :: Scientific/Engineering :: Mathematics\",\n    \"Topic :: Scientific/Engineering :: Information Analysis\"\n]\n\n[project.urls]\nhomepage = \"https://reticula.network/\"\ndocumentation = \"https://docs.reticula.network/\"\nrepository = \"https://github.com/reticula-network/reticula-python\"\nbug-tracker= \"https://github.com/reticula-network/reticula-python/issues\"\n\n[project.optional-dependencies]\ntest = [\"pytest\", \"hypothesis\", \"pytest-xdist\", \"scipy\"]\n\n[build-system]\nrequires = [\n    \"setuptools>=67\",\n    \"wheel\",\n    \"cmake>=3.26\",\n    \"scikit-build>=0.17\",\n    \"ninja\",\n    \"nanobind @ git+https://github.com/wjakob/nanobind@74235fabbcdfbb2fa8533c52b9c4797d3570e712\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nskip = \"pp38*\"\nbuild-verbosity = 3\n\n[tool.cibuildwheel.linux]\narchs = [\"x86_64\"]\nrepair-wheel-command = \"auditwheel repair -w {dest_dir} {wheel}\"\n\n[tool.cibuildwheel.macos]\narchs = [\"universal2\"]\nrepair-wheel-command = \"delocate-wheel --require-archs {delocate_archs} -w {dest_dir} -v {wheel}\"\n\n[tool.cibuildwheel.windows]\narchs = [\"AMD64\"]\nbefore-build = \"pip install delvewheel\"\nrepair-wheel-command = \"delvewheel repair -w {dest_dir} {wheel}\"\n"
  },
  "lewiswolf/kac_drumset": {
    "setup.py": "'''\nCustom build script used to import this package's metadata from both the readme and Pipfile.\n'''\n\n# core\nimport codecs\nimport os\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\nthis = os.path.abspath(os.path.dirname(__file__))\nname = 'kac_drumset'\nversion = '1.2.0'\nshort_description = 'Analysis tools and a dataset generator for arbitrarily shaped drums.'\n\n# import long description from readme.md\nwith codecs.open(os.path.join(this, 'readme.md'), encoding='utf-8') as readme:\n\tlong_description = '\\n' + readme.read()\n\n# import packages from Pipfile\nwith codecs.open(os.path.join(this, 'Pipfile'), encoding='utf-8') as raw_pipfile:\n\tpackages = []\n\t# read the Pipfile\n\tpipfile = raw_pipfile.readlines(1)\n\traw_pipfile.close()\n\t# loop over the file\n\tis_pkg = False\n\tfor line in pipfile:\n\t\tline = line.replace('\\n', '')\n\t\tif not line:\n\t\t\tcontinue\n\t\t# find [packages]\n\t\tif line[0] == '[':\n\t\t\tif line == '[packages]':\n\t\t\t\tis_pkg = True\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tis_pkg = False\n\t\t\t\tcontinue\n\t\t# append package names with required version\n\t\tif is_pkg:\n\t\t\tpkg_name, _, *spec = line.split()\n\t\t\tpackages.append(pkg_name if spec[0] == '\"*\"' else f'{pkg_name}{spec[0][1:-1]}')\n\nsetup(\n\tauthor='Lewis Wolstanholme',\n\tauthor_email='lewiswolstanholme@gmail.com',\n\tclassifiers=[\n\t\t'Operating System :: MacOS :: MacOS X',\n\t\t'Operating System :: Microsoft :: Windows',\n\t\t'Operating System :: Unix',\n\t\t'Programming Language :: Python :: 3',\n\t\t'Programming Language :: Python :: 3 :: Only',\n\t\t'Programming Language :: Python :: 3.9',\n\t\t'Programming Language :: Python :: 3.10',\n\t\t'Typing :: Typed',\n\t],\n\tcmake_install_dir=\"kac_drumset/externals\",\n\tdescription=short_description,\n\tlong_description=long_description,\n\tinclude_package_data=True,\n\tinstall_requires=packages,\n\tkeywords=['kac_drumset'],\n\tlong_description_content_type='text/markdown',\n\tname=name,\n\tpackages=find_packages(),\n\tpackage_data={'kac_drumset': ['py.typed']},\n\tversion=version,\n)\n",
    "pyproject.toml": "[build-system]\nbuild-backend = \"setuptools.build_meta\"\nrequires = [\n    \"cmake>=3.22\",\n    \"pybind11>=2.9.0\",\n    \"scikit-build>=0.13\",\n\t\"setuptools\",\n\t\"wheel\",\t\n]"
  },
  "uuosio/gscdk": {
    "setup.py": "\nimport os\nimport shutil\nimport setuptools\n# from skbuild import setup\nfrom distutils.core import setup\n\nfrom distutils.sysconfig import get_python_lib\nimport glob\n\nrelease_files = []\nfor d in [\"pysrc/tinygo\", \"pysrc/templates\", 'pysrc/binaryen-version_109']:\n    for root, dirs, files in os.walk(d):\n        for f in files:\n            release_files.append(os.path.join(root.replace('pysrc/', ''), f))\n\nsetup(\n    name=\"gscdk\",\n    version=\"0.7.9\",\n    description=\"Go Smart Contract Development Kit\",\n    author='The UUOSIO Team',\n    license=\"BSD-3-Clause\",\n    url=\"https://github.com/uuosio/uuosio.gscdk\",\n    packages=['gscdk'],\n    package_dir={'gscdk': 'pysrc'},\n    package_data={\n#        \"\": [\"*\"],\n        'gscdk': release_files,\n    },\n    setup_requires=['wheel']\n    # scripts=['compiler/build/release/tinygo/bin/eosio-go'],\n    # install_requires=[\n    # ],\n    # include_package_data=True\n)\n",
    "setup.cfg": "[metadata]\nlong_description = file:README.md\nlong_description_content_type = text/markdown\n\n[options.entry_points]\nconsole_scripts =\n    eosio-go = gscdk:run_tinygo\n    go-contract = gscdk:run_tinygo\n    tinygo-dlltool = gscdk:run_dlltool\n    tinygo-ranlib = gscdk:run_ranlib\n    tinygo-lib = gscdk:run_lib\n    tinygo-ar = gscdk:run_ar\n    tinygo-clang = gscdk:run_clang\n    tinygo-wasm-ld = gscdk:run_wasm_ld\n    tinygo-lld = gscdk:run_ld_lld\n"
  },
  "IntelPython/dpbench": {
    "setup.py": "# Copyright 2022 Intel Corporation\n#\n# SPDX-License-Identifier: Apache 2.0\n\n#!/usr/bin/env python\n\nimport dpctl\nfrom setuptools import find_packages\nfrom skbuild import setup\n\ndpctl_include_dir = dpctl.get_include()\n\nsetup(\n    name=\"dpbench\",\n    version=\"0.0.1\",\n    url=\"https://https://github.com/IntelPython/dpbench\",\n    author=\"Intel Corp.\",\n    author_email=\"diptorup.deb@intel.com\",\n    description=\"dpBench\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: Apache 2.0 License\",\n        \"Operating System :: Linux\",\n    ],\n    packages=(\n        find_packages(include=[\"*\"])\n        + find_packages(where=\"./dpbench/benchmarks/*/*\")\n    ),\n    python_requires=\">=3.8\",\n    include_package_data=True,\n    install_requires=[\n        \"numpy\",\n        \"numba\",\n    ],\n    cmake_args=[\"-DDpctl_INCLUDE_DIRS=\" + dpctl_include_dir],\n    entry_points={\n        \"console_scripts\": [\"dpbench=dpbench.console.entry:main\"],\n    },\n)\n",
    "pyproject.toml": "# SPDX-FileCopyrightText: 2022 - 2023 Intel Corporation\n#\n# SPDX-License-Identifier: Apache-2.0\n\n[tool.black]\nexclude = \"versioneer.py|dpbench/_version.py\"\nline-length = 80\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nensure_newline_before_comments = true\nline_length = 80\nskip = [\"versioneer.py\", \"dpbench/_version.py\"]\n"
  },
  "InsightSoftwareConsortium/ITKAnisotropicDiffusionLBR": {
    "setup.py": "from __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-anisotropicdiffusionlbr',\n    version='1.2.1',\n    author='Insight Software Consortium',\n    author_email='community@itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKAnisotropicDiffusionLBR',\n    description=r'Smooth images while preserving edges or coherent structures.',\n    long_description='ITK is an open-source, cross-platform library that '\n                     'provides developers with an extensive suite of software '\n                     'tools for image analysis. This package implements anisotropic diffusion '\n                     'using Lattice Basis Reduction. For more information, see  '\n                     'Mirebeau J., Fehrenbach J., Risser L., Tobji S. '\n                     '\"Anisotropic Diffusion in ITK\" '\n                     'https://insight-journal.org/browse/publication/953 '\n                     'https://hdl.handle.net/10380/3505 ',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.2.0.post2'\n    ]\n    )\n"
  },
  "kjelljorner/libconeangle": {
    "setup.py": "from skbuild import setup\n\nURL = \"https://github.com/kjelljorner/libconeangle\"\nDESCRIPTION = \"Python library for libconeangle\"\nLONG_DESCRIPTION = f\"\"\"\\\n{DESCRIPTION}. For more information, see the [project repository]({URL}).\n\"\"\"\n\nsetup(\n    name=\"libconeangle\",\n    version=\"0.1.2\",\n    author=\"Kjell Jorner\",\n    author_email=\"kjell.jorner@gmail.com\",\n    description=DESCRIPTION,\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/markdown\",\n    url=URL,\n    packages=[\"libconeangle\"],\n    python_requires=\">=3.8\",\n    install_requires=[\"numpy>=1.20\"],\n    include_package_data=True,\n    cmake_args=[\"-DSKBUILD=ON\"],\n    license=\"MIT\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"fypp\", \"ninja; platform_system!='Windows'\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.coverage.run]\nbranch = true\nomit = [\"*/site-packages/*\"]\n\n[tool.coverage.report]\nshow_missing = true\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\nforce_sort_within_sections = true\norder_by_type = false\ngroup_by_package = true\nlexicographical = true\n\n[tool.mypy]\ndisallow_any_explicit = false\ndisallow_any_generics = false\nallow_redefinition = true\ncheck_untyped_defs = true\ndisallow_untyped_calls = true\ndisallow_subclassing_any = true\nfollow_imports = \"silent\"\nignore_errors = false\nignore_missing_imports = true\nimplicit_reexport = false\nstrict_optional = true\nstrict_equality = true\nno_implicit_optional = true\nlocal_partial_types = true\nwarn_no_return = true\nwarn_unused_ignores = true\nwarn_redundant_casts = true\nwarn_return_any = true\nwarn_unused_configs = true\nwarn_unreachable = true\nshow_traceback = true\n[[tool.mypy.overrides]]\nmodule = \"numpy.*\"\nallow_untyped_calls = true"
  },
  "RUrlus/diptest": {
    "setup.py": "\"\"\"Project: Diptest\n\nCreated: 2021/09/24\n\nDescription:\n    setup script to install diptest package.\n\nAuthors:\n    Ralph Urlus [rurlus.dev@gmail.com]\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted according to the terms listed in the file\nLICENSE.\n\"\"\"\n\nimport os\nimport pybind11\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nNAME = 'diptest'\n\nMAJOR = 0\nREVISION = 5\nPATCH = 2\nDEV = False\n\nVERSION = '{major}.{revision}.{patch}'.format(major=MAJOR, revision=REVISION, patch=PATCH)\nFULL_VERSION = VERSION\nif DEV:\n    FULL_VERSION += '.dev'\n\n# read the contents of readme file\nwith open(\"README.md\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\n\ndef write_version_py(filename: str = 'diptest/version.py') -> None:\n    \"\"\"Write package version to version.py.\n\n    This will ensure that the version in version.py is in sync with us.\n\n    Parameters\n    ----------\n    filename : str\n        the path the file to write the version.py\n\n    \"\"\"\n    # Do not modify the indentation of version_str!\n    version_str = \"\"\"\\\"\\\"\\\"THIS FILE IS AUTO-GENERATED BY diptest SETUP.PY.\\\"\\\"\\\"\n\nname = '{name!s}'\nversion = '{version!s}'\nfull_version = '{full_version!s}'\nrelease = {is_release!s}\n\"\"\"\n\n    with open(filename, 'w') as version_file:\n        version_file.write(\n            version_str.format(name=NAME.lower(), version=VERSION, full_version=FULL_VERSION, is_release=not DEV)\n        )\n\n\nif __name__ == '__main__':\n    write_version_py()\n    if 'DIPTEST_MANUAL_BUILD' in os.environ:\n        from setuptools import setup\n        print('Diptest: running pip install without extension')\n\n    setup(\n        name=NAME,\n        packages=find_packages(),\n        version=FULL_VERSION,\n        cmake_args=[\n            f\"-DDIPTEST_VERSION_INFO:STRING={VERSION}\",\n            f\"-Dpybind11_DIR:STRING={pybind11.get_cmake_dir()}\",\n            \"-DDIPTEST_ENABLE_ARCH_FLAGS:BOOL=ON\",\n        ]\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build>=0.14.1\",\n    \"ninja; platform_system!='Windows'\",\n    \"cmake>=3.16\",\n    \"pybind11>=2.8.1\",\n]\nbuild-backend = \"setuptools.build_meta\"\n",
    "setup.cfg": "[metadata]\nname = diptest\ndescription = Hartigan's diptest.\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nauthor = Ralph Urlus\nauthor_email = rurlus.dev@gmail.com\nlicense = GPLv2+\nplatforms = any\nurl = https://github.com/RUrlus/diptest\nproject_urls =\n    Source  = https://github.com/RUrlus/diptest\n    Tracker = https://github.com/RUrlus/diptest/issues\nkeywords = diptest hartigan statistics modality\nclassifiers =\n\n[options]\nzip_safe = False\npython_requires = >=3.7\ninstall_requires =\n    psutil\n    numpy>=1.18\n\n[options.extras_require]\ntest =\n    pytest\nall =\n    %(test)s\n\n[tool:pytest]\naddopts = -rsxX -v\ntestpaths = tests\n"
  },
  "mephi42/memtrace": {
    "setup.py": "import os\n\nimport skbuild\n\nimport memtrace\n\nuname = os.uname()\nmemtrace_dir = os.path.join(os.path.dirname(__file__), 'memtrace')\ntracer_dir = os.path.join(\n    memtrace_dir, 'tracer', f'{uname.sysname}-{uname.machine}')\nmemtrace_data = [\n    'memtrace.ipynb',\n]\nfor dirpath, dirnames, filenames in os.walk(tracer_dir):\n    dirpath = os.path.relpath(dirpath, memtrace_dir)\n    memtrace_data.extend(\n        os.path.join(dirpath, filename) for filename in filenames)\nskbuild.setup(\n    name='memtrace',\n    version=memtrace.__version__,\n    author='mephi42',\n    author_email='mephi42@gmail.com',\n    description='Valgrind tool for tracing memory accesses',\n    url='https://github.com/mephi42/memtrace',\n    packages=[\n        'memtrace',\n        'memtrace_ext',\n    ],\n    classifiers=[\n        'Programming Language :: Python :: 3',\n        'License :: OSI Approved :: GNU General Public License v2 (GPLv2)',\n        'Operating System :: OS Independent',\n    ],\n    python_requires='>=3.6',\n    install_requires=[\n        'click',\n        'dataclasses; python_version < \\'3.7\\'',\n        'sortedcontainers',\n    ],\n    package_data={\n        'memtrace': memtrace_data,\n    },\n    entry_points={\n        'console_scripts': [\n            'memtrace=memtrace.cli:main',\n            'memtrace-analyze=memtrace.analysis:main',\n            'memtrace-index=memtrace.index:main',\n            'memtrace-stats=memtrace.stats:main',\n            'memtrace-ud=memtrace.ud:main',\n        ],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n"
  },
  "DeepLearnPhysics/larcv3": {
    "setup.py": "from skbuild import setup  # This line replaces 'from setuptools import setup'\nimport argparse\n\nimport io\nimport sys, os\nthis_directory = os.path.abspath(os.path.dirname(__file__))\nwith io.open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nimport re\nVERSIONFILE=\"larcv/_version.py\"\nverstrline = open(VERSIONFILE, \"rt\").read()\nVSRE = r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\"\nmo = re.search(VSRE, verstrline, re.M)\nif mo:\n    verstr = mo.group(1)\nelse:\n    raise RuntimeError(\"Unable to find version string in %s.\" % (VERSIONFILE,))\n\n\n\nv = sys.version_info\npy_version = \".\".join([str(v.major), str(v.minor), str(v.micro)])\nprint(py_version)\n\n\n# Several environment variables control special build features:\nif 'LARCV_WITH_MPI' in os.environ and os.environ['LARCV_WITH_MPI']:\n    mpi_value='ON'\nelse:\n    mpi_value='OFF'\n\nif 'LARCV_WITH_OPENMP' in os.environ and os.environ['LARCV_WITH_OPENMP']:\n    openmp_value='ON'\nelse:\n    openmp_value='OFF'\n\nif 'LARCV_WITHOUT_PYBIND' in os.environ and os.environ['LARCV_WITHOUT_PYBIND']:\n    pybind_value='OFF'\nelse:\n    pybind_value='ON'\n\n\n# Speed up the build if not directly set:    \nif 'MAKEFLAGS' not in os.environ: \n    os.environ['MAKEFLAGS'] = \"-j 1\" # This lets builds on CI work better.\n    \nsetup(\n    name=\"larcv\",\n    version=verstr,\n    cmake_source_dir='src/',\n    include_package_data=True,\n    cmake_args=[\n        '-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9',\n        '-DCMAKE_PYTHON_BINDINGS={}'.format(pybind_value),\n        # '-DMPI_CXX_COMPILER={}'.format(mpicxx),\n        # '-DMPI_C_COMPILER={}'.format(mpicc),\n        '-DMPI:BOOL={}'.format(mpi_value),\n        '-DOPENMP:BOOL={}'.format(openmp_value),\n        f'-DCMAKE_PYVERSION={py_version}'\n    ],\n    author=['Corey Adams', 'Kazuhiro Terao', 'Taritree Wongjirad', 'Marco del Tutto'],\n    author_email='corey.adams@anl.gov',\n    description='C++ IO and Preprocessing package for sparse neutrino data, with H5 for IO and python bindings.',\n    license='MIT',\n    keywords='larcv larcv3 neutrinos hdf5 h5 deep learning IO sparse',\n    project_urls={\n        'Source Code': 'https://github.com/DeepLearnPhysics/larcv3'\n    },\n    url='https://github.com/DeepLearnPhysics/larcv3',\n    scripts=['bin/merge_larcv3_files.py', 'bin/run_processor.py'],\n    packages=['larcv','src/pybind11'],\n    install_requires=[\n        \"numpy\",\n        \"scikit-build\",\n        \"h5py\",\n        \"cmake\",\n    ],\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n)\n",
    "pyproject.toml": "\n[build-system]\nrequires = [\"numpy\", \"scikit-build\", \"h5py\", \"cmake\"]\n"
  },
  "InsightSoftwareConsortium/ITKIOOpenSlide": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-ioopenslide',\n    version='0.1.0',\n    author='Matthew McCormick',\n    author_email='matt.mccormick@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKIOOpenSlide',\n    description=r\"ImageIO for the OpenSlide library supported file formats.\",\n    long_description='itk-ioopenslide provides an ImageIO for the OpenSlide '\n                     'library supported file formats. These are generally '\n                     'TIFF-based microscopy formats.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit OpenSlide OpenSlide-Python Microscopy',\n    url=r'https://github.com/InsightSoftwareConsortium/ITKIOOpenSlide',\n    install_requires=[\n        r'itk'\n    ]\n    )\n"
  },
  "InsightSoftwareConsortium/LesionSizingToolkit": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='lesionsizingtoolkit',\n    version='0.0.1',\n    author='Xiao Xiao Liu',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/LesionSizingToolkit',\n    description=r'A generic and extensible ITK module for lesion segmentation',\n    long_description='lesionsizingtoolkit provides a generic, modular, and '\n                     'extensible architecture for lesion sizing algorithms '\n                     'in medical images as well as a reference algorithm for '\n                     'lung solid lesion segmentation in CT images.\\n'\n                     'Please refer to:\\n'\n                     'Liu X., Helba B., Krishnan K., Reynolds P., McCormick M., Turner W., Ib\u00e1\u00f1ez L., Yankelevitz D., Avila R., '\n                     '\"Fostering Open Science in Lung Cancer Lesion Sizing with ITK module LSTK\", '\n                     'Insight Journal, January-December 2012, https://hdl.handle.net/10380/3369.',\n    classifiers=[\n        \"License :: OSI Approved :: BSD 2-Clause \\\"Simplified\\\" License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='BSD',\n    keywords='ITK InsightToolkit',\n    url=r'https://github.com/InsightSoftwareConsortium/LesionSizingToolkit',\n    install_requires=[\n        r'itk'\n    ]\n    )\n"
  },
  "mivade/IonMD": {
    "setup.py": "from skbuild import setup\n\n\nsetup(\n    name=\"ionmd\",\n    version=\"2.0.dev\",\n    author=\"Michael V. DePalatis\",\n    author_email=\"mike@depalatis.net\",\n    url=\"https://github.com/mivade/IonMD\",\n    description=\"Ion trap molecular dynamics simulation toolkit\",\n    # long_description='',\n    cmake_args=[\"-DBUILD_PY=ON\"],\n    zip_safe=False,\n)\n"
  },
  "InsightSoftwareConsortium/ITKTotalVariation": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-totalvariation',\n    version='0.2.2',\n    author='Pablo Hernandez-Cerdan',\n    author_email='pablo.hernandez.cerdan@outlook.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKTotalVariation',\n    description=r'TotalVariation algorithms, providing a wrap for the external project: https://github.com/albarji/proxTV',\n    long_description='ITK is an open-source, cross-platform library that provides developers with an extensive suite of software tools for image analysis. Developed through extreme programming methodologies, ITK employs leading-edge algorithms for registering and segmenting multidimensional scientific images.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.2.0.post2'\n    ]\n    )\n"
  },
  "Nicholaswogan/skbuild-f2py-examples": {
    "hello-fortran-numba-callbacks/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"hello\",\n    version=\"1.2.3\",\n    description=\"a minimal example package (fortran version)\",\n    license=\"MIT\",\n    packages=['hello'],\n    cmake_args=['-DSKBUILD=ON']\n)\n",
    "hello-fortran-numba-callbacks/pyproject.toml": "[project]\nrequires-python = \">=3.7\"\n\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\", \"numpy>=1.21\"]\n",
    "hello-fortran/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"hello\",\n    version=\"1.2.3\",\n    description=\"a minimal example package (fortran version)\",\n    license=\"MIT\",\n    packages=['hello'],\n    cmake_args=['-DSKBUILD=ON']\n)\n",
    "hello-fortran/pyproject.toml": "[project]\nrequires-python = \">=3.7\"\n\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\", \"numpy>=1.21\"]\n",
    "hello-fortran-cmaker/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"hello\",\n    version=\"1.2.3\",\n    description=\"a minimal example package (fortran version)\",\n    license=\"MIT\",\n    packages=['hello'],\n    cmake_args=['-DSKBUILD=ON']\n)\n",
    "hello-fortran-cmaker/pyproject.toml": "[project]\nrequires-python = \">=3.7\"\n\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\", \"numpy>=1.21\"]\n",
    "hello-fortran-dependency/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"hello\",\n    version=\"1.2.3\",\n    description=\"a minimal example package (fortran version)\",\n    license=\"MIT\",\n    packages=['hello'],\n    cmake_args=['-DSKBUILD=ON']\n)\n",
    "hello-fortran-dependency/pyproject.toml": "[project]\nrequires-python = \">=3.7\"\n\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.18\", \"ninja\", \"numpy>=1.21\"]\n"
  },
  "tcsantini/eyerec-python": {
    "setup.py": "from skbuild import setup\n\nsetup(\n    author=\"Thiago C. Santini\",\n    author_email='',\n    install_requires=[\"numpy\"],\n    name=\"eyerec\",\n    packages=[\"eyerec\"],\n    version=\"0.0.0\",\n    classifiers=[\n        \"Development Status :: 2 - Pre-Alpha\"\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja\",\n    \"cython\",\n    \"numpy\",\n]\n\n"
  },
  "lyckantropen/psnr_hvsm": {
    "setup.py": "import sys\n\nimport skbuild.platform_specifics.windows\nfrom skbuild import setup\n\n\n# using patched scikit-build for VS2019 courtesy of https://github.com/YannickJadoul/scikit-build\ndef patched_WindowsPlatform_init(self):\n    import textwrap\n\n    from skbuild.platform_specifics.windows import (\n        CMakeVisualStudioCommandLineGenerator, CMakeVisualStudioIDEGenerator,\n        WindowsPlatform)\n\n    super(WindowsPlatform, self).__init__()\n\n    self._vs_help = textwrap.dedent(\"\"\"\n\t\tBuilding Windows wheels for requires Microsoft Visual Studio 2017 or 2019:\n\t\t  https://visualstudio.microsoft.com/vs/\n\t\t\"\"\").strip()\n\n    supported_vs_years = [(\"2019\", \"v141\"), (\"2017\", \"v141\")]\n    for vs_year, vs_toolset in supported_vs_years:\n        self.default_generators.extend([\n            CMakeVisualStudioCommandLineGenerator(\"Ninja\", vs_year, vs_toolset),\n            CMakeVisualStudioIDEGenerator(vs_year, vs_toolset),\n            CMakeVisualStudioCommandLineGenerator(\"NMake Makefiles\", vs_year, vs_toolset),\n            CMakeVisualStudioCommandLineGenerator(\"NMake Makefiles JOM\", vs_year, vs_toolset)\n        ])\n\n\nskbuild.platform_specifics.windows.WindowsPlatform.__init__ = patched_WindowsPlatform_init\n\n\nsetup(\n    cmake_args=[\"-DPython3_EXECUTABLE=\" + sys.executable],  # scikit-build doesn't detect Python properly on its own\n                                                            # in GitHub windows-2019 image using cibuildwheel\n    packages=['psnr_hvsm']\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"cmake>=3.18\",\n    \"scikit_build @ git+https://github.com/YannickJadoul/scikit-build@vs2019\",\n    \"numpy >= 1.18.0\"\n]\n\nbuild-backend = \"setuptools.build_meta\"",
    "setup.cfg": "[metadata]\nname = psnr_hvsm\nversion = 0.1.0\nurl = https://github.com/lyckantropen/psnr_hvsm\nauthor = Karol Trojanowski\nauthor_email = trojanowski.ifuj@gmail.com\ndescription = Accelerated implementations of the PSNR-HVS, PSNR-HVS-M, PSNR-HA and PSNR-HMA image metrics\nlicense = MIT\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nkeywords = psnr hvs video image metric\nclassifiers =\n    Development Status :: 4 - Beta\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: C++\n    Operating System :: POSIX :: Linux\n    Operating System :: Microsoft :: Windows\n    License :: OSI Approved :: GNU General Public License v3 (GPLv3)\n    Intended Audience :: Science/Research\n    Topic :: Scientific/Engineering :: Image Processing\n\n[options]\npython_requires = >= 3.6, <4\ninstall_requires =\n    numpy >= 1.18\n    msvc-runtime >= 14; platform_system == \"Windows\"\n\n[options.extras_require]\ntests =\n    pytest\n    scipy\n    imageio\ncommand_line =\n    imageio\n\n[tool:pytest]\ntestpaths = tests\n\n[flake8]\nmax_line_length=160"
  },
  "rathaumons/pyppbox": {
    "setup.py": "\"\"\"\n    pyppbox: Toolbox for people detecting, tracking, and re-identifying.\n    Copyright (C) 2022 UMONS-Numediart\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\"\"\"\n\n\nimport os\nimport os.path\nfrom setuptools import setup\n\n\ndef main():\n\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n\n    package_name = \"pyppbox\"\n    package_version = get_version_info()\n    long_description = \"Pure Python toolbox for people detecting, tracking, and re-identifying...\"\n\n    packages = [\n        \"pyppbox\", \"pyppbox.cfg\", \"pyppbox.dt_yolocv\", \"pyppbox.dt_yolopt\", \"pyppbox.gui\", \n        \"pyppbox.ri_deepreid\", \"pyppbox.ri_deepreid.classifier\", \"pyppbox.ri_deepreid.data\", \n        \"pyppbox.ri_deepreid.pretrained\", \"pyppbox.ri_deepreid.pretrained.base\", \n        \"pyppbox.ri_deepreid.pretrained.torchreid\", \"pyppbox.ri_facenet\", \n        \"pyppbox.ri_facenet.classifier\", \"pyppbox.ri_facenet.data\", \"pyppbox.ri_facenet.models\", \n        \"pyppbox.ri_facenet.models.20180402-114759\", \"pyppbox.ri_facenet.models.det\", \n        \"pyppbox.tk_centroid\", \"pyppbox.tk_deepsort\", \"pyppbox.tk_sort\", \"pyppbox.tmp\", \n        \"pyppbox.tmp.demo\", \"pyppbox.tmp.gt\", \"pyppbox.tmp.res\", \"pyppbox.utils\"\n    ]\n\n    package_data = {\n        \"pyppbox\": [\"*\"], \n        \"pyppbox.cfg\": [\"*\"], \n        \"pyppbox.dt_yolocv\": [\"*\"], \n        \"pyppbox.dt_yolopt\": [\"*\"], \n        \"pyppbox.gui\": [\"*\"], \n        \"pyppbox.ri_deepreid\": [\"*\"], \n        \"pyppbox.ri_deepreid.classifier\": [\"*\"], \n        \"pyppbox.ri_deepreid.data\": [\"*\"], \n        \"pyppbox.ri_deepreid.pretrained\": [\"*\"], \n        \"pyppbox.ri_deepreid.pretrained.base\": [\"*\"], \n        \"pyppbox.ri_deepreid.pretrained.torchreid\": [\"*\"], \n        \"pyppbox.ri_facenet\": [\"*\"], \n        \"pyppbox.ri_facenet.classifier\": [\"*\"], \n        \"pyppbox.ri_facenet.data\": [\"*\"], \n        \"pyppbox.ri_facenet.models\": [\"*\"], \n        \"pyppbox.ri_facenet.models.20180402-114759\": [\"*\"], \n        \"pyppbox.ri_facenet.models.det\": [\"*\"], \n        \"pyppbox.tk_centroid\": [\"*\"], \n        \"pyppbox.tk_deepsort\": [\"*\"], \n        \"pyppbox.tk_sort\": [\"*\"], \n        \"pyppbox.tmp\": [\"*\"], \n        \"pyppbox.tmp.demo\": [\"*\"], \n        \"pyppbox.tmp.gt\": [\"*\"], \n        \"pyppbox.tmp.res\": [\"*\"], \n        \"pyppbox.utils\": [\"*\"]\n    }\n\n    setup(\n        name=package_name,\n        version=package_version,\n        url=\"https://github.com/rathaumons/pyppbox\",\n        license=\"GPLv3+\",\n        description=\"Toolbox for people detecting, tracking, and re-identifying\",\n        long_description=long_description,\n        long_description_content_type=\"text/markdown\",\n        packages=packages,\n        package_data=package_data,\n        maintainer=\"rathaROG\",\n        install_requires=None,\n        python_requires=\">=3.9\",\n        classifiers=[\n            \"Development Status :: 4 - Beta\",\n            \"Environment :: Console\",\n            \"Intended Audience :: Developers\",\n            \"Intended Audience :: Education\",\n            \"Intended Audience :: Information Technology\",\n            \"Intended Audience :: Science/Research\",\n            \"License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\",\n            \"Operating System :: Microsoft :: Windows\",\n            \"Programming Language :: Python\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: 3 :: Only\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n            \"Programming Language :: Python :: Implementation :: CPython\",\n            \"Topic :: Scientific/Engineering\",\n            \"Topic :: Scientific/Engineering :: Image Recognition\",\n            \"Topic :: Software Development\",\n        ],\n\n    )\n\n\ndef get_version_info():\n    version_py = \"pyppbox/__init__.py\"\n    with open(version_py) as version_file:\n        exec(compile(version_file.read(), version_py, 'exec'))\n    return locals()['__version__']\n\ndef force_tags(force=True):\n    if force:\n        import sys\n        sys.argv.extend(['--plat-name', 'win_amd64'])\n\n\nif __name__ == \"__main__\":\n    force_tags()\n    main()\n",
    "setup.cfg": "[bdist_wheel]\npython-tag=py3\n"
  },
  "KitwareMedical/ITKIOScanco": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-ioscanco',\n    version='0.10.0',\n    author='Matt McCormick',\n    author_email='matt.mccormick@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/KitwareMedical/ITKIOScanco',\n    description=r'An ITK module to read and write Scanco microCT .isq files.',\n    long_description='ITK is an open-source, cross-platform library that provides developers with an extensive suite of software tools for image analysis. Developed through extreme programming methodologies, ITK employs leading-edge algorithms for registering and segmenting multidimensional scientific images.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk-io>=v5.3.0'\n    ]\n    )\n"
  },
  "panda-official/WaveletBuffer": {
    "setup.py": "import os\nfrom string import Template\n\ntry:\n    from skbuild import setup  # This line replaces 'from setuptools import setup'\nexcept ModuleNotFoundError:\n    # use classical setuptools to build sdist\n    from setuptools import setup\n\nfrom pathlib import Path\n\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\nMAJOR_VERSION = 0\nMINOR_VERSION = 6\nPATCH_VERSION = 0\n\nPACKAGE_NAME = \"wavelet-buffer\"\n\nVERSION_SUFFIX = os.getenv(\"VERSION_SUFFIX\")\n\n\ndef update_package_version(path: Path, version: str, protoc_version: str):\n    \"\"\"Overwrite/create __init__.py file and fill __version__\"\"\"\n    template = (path / \"__init__.py.in\").read_text(encoding=\"utf-8\")\n    init_content = Template(template).substitute(\n        version=version, protoc_version=protoc_version\n    )\n    with open(path / \"__init__.py\", \"w\") as f:\n        f.write(init_content)\n\n\ndef build_version():\n    \"\"\"Build dynamic version and update version in package\"\"\"\n    version = f\"{MAJOR_VERSION}.{MINOR_VERSION}.{PATCH_VERSION}\"\n    if VERSION_SUFFIX:\n        version += f\"dev.{VERSION_SUFFIX}\"\n\n    return version\n\n\nsetup(\n    name=PACKAGE_NAME,\n    version=build_version(),\n    packages=[\"wavelet_buffer\", \"wavelet_buffer.img\"],\n    package_dir={\"\": \"python/src\"},\n    cmake_install_dir=\"python/src/wavelet_buffer\",\n    cmake_source_dir=\"python\",\n    author=\"PANDA, GmbH\",\n    author_email=\"info@panda.technology\",\n    description=\"A universal C++ compression library based on wavelet transformation\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/panda-official/WaveletBuffer\",\n    python_requires=\">=3.8\",\n    license=\"MPL-2.0\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)\",\n        \"Operating System :: Unix\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Topic :: Software Development\",\n        \"Topic :: Scientific/Engineering\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools >= 42\",\n    \"scikit-build\",\n    \"pybind11 >= 2.9.2\",\n    \"cmake\",\n    \"conan == 1.58.0\",\n    \"ninja\"\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\narchs = [\"auto64\"]\nbuild = [\"*38*\", \"*39*\", \"*310*\", \"*311*\"]\nskip = [\"*musllinux*\", \"pp*\"]\ntest-command = \"pip install -r {project}/python/requirements/test.txt && pytest {project}/python/tests\"\nbuild-verbosity = '3'\n\n[tool.cibuildwheel.linux]\narchs = \"x86_64\"\nenvironment-pass = [\"VERSION_SUFFIX\"]\n"
  },
  "HiroIshida/voxbloxpy": {
    "setup.py": "from skbuild import setup\n\ninstall_requires = [\n    \"numpy\",\n    \"plotly\",\n    \"scipy\"\n]\n\nsetup(\n    name=\"voxbloxpy\",\n    version=\"0.0.3\",\n    description=\"standalone voxblox python\",\n    author=\"Hirokazu Ishida\",\n    license=\"MIT\",\n    packages=[\"voxbloxpy\"],\n    package_dir={\"\": \"python\"},\n    cmake_install_dir=\"python/voxbloxpy/\",\n    install_requires=install_requires,\n    extra_requires = {\"test\": [\"scikit-robot\"]},\n    package_data={\"voxbloxpy\": [\"py.typed\"]},\n)\n"
  },
  "GrammaTech/mc-asm": {
    "setup.py": "import sys\n\nfrom setuptools import find_namespace_packages\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater, or you need to install\"\n        \" the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nversion = {}\nwith open(\"src/mcasm/version.py\") as fp:\n    exec(fp.read(), version)\n\nwith open(\"README.md\", \"r\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"mcasm\",\n    author=\"GrammaTech, Inc.\",\n    author_email=\"gtirb@grammatech.com\",\n    version=version[\"__version__\"],\n    description=\"Assemble code to bytes using LLVM's MC layer\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Programming Language :: Python :: 3\",\n    ],\n    python_requires=\">=3.6\",\n    install_requires=[],\n    dependency_links=[],\n    license=\"MIT\",\n    packages=find_namespace_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/mcasm\",\n    include_package_data=True,\n    extras_require={\"test\": [\"pytest\"], \"cli\": [\"rich~=12.0\"]},\n    long_description=long_description,\n    package_data={\n        \"mcasm\": [\"py.typed\", \"_core/__init__.pyi\", \"_core/mc/__init__.pyi\"]\n    },\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/grammatech/mc-asm\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"pybind11>=2.9.2\",\n    \"cmake>=3.22\",\n    \"scikit-build>=0.14.1\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "patmjen/pygorpho": {
    "setup.py": "from skbuild import setup\r\n\r\nwith open('README.md') as readme:\r\n    long_description = readme.read()\r\n\r\nsetup(\r\n    name='pygorpho',\r\n    version='1.0.0',\r\n    description='Python bindings for gorpho',\r\n    url='https://pygorpho.readthedocs.io/',\r\n    project_urls={\r\n        'Documentation':\r\n            'https://pygorpho.readthedocs.io/en/latest/api-doc.html',\r\n        'PyPI': 'https://pypi.org/project/pygorpho/',\r\n        'Source': 'https://github.com/patmjen/pygorpho',\r\n    },\r\n    long_description=long_description,\r\n    long_description_content_type='text/markdown',\r\n    license='MIT',\r\n    author='Patrick M. Jensen',\r\n    author_email='patmjen@gmail.com',\r\n    package_dir={'': 'src'},\r\n    packages=[\"pygorpho\"],\r\n    setup_requires=['numpy', 'scikit-build>=0.7.0'],\r\n    install_requires=['numpy', 'scikit-build>=0.7.0'],\r\n    cmake_languages=('CUDA',),\r\n    cmake_minimum_required_version='3.10',\r\n    classifiers=[\r\n        'Programming Language :: Python :: 3.5',\r\n        'Programming Language :: Python :: 3.6',\r\n        'Programming Language :: Python :: 3.7',\r\n        'Programming Language :: Python :: 3.8'\r\n    ]\r\n)\r\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"numpy\"]"
  },
  "inlab-geo/espresso": {
    "setup.py": "########################## LIBRARY IMPORT #############################################\nimport io\nimport sys\nimport pathlib\nimport setuptools\nimport versioningit\n\ntry:\n    import skbuild\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\n\n_ROOT = pathlib.Path(__file__).resolve().parent\n\n########################## VERSION ####################################################\n# generate\nversioningit_config = {\n    \"format\": {\n        \"distance\": \"{base_version}+{distance}.{vcs}{rev}.core\",\n        \"dirty\": \"{base_version}+{distance}.{vcs}{rev}.dirty.core\",\n        \"distance-dirty\": \"{base_version}+{distance}.{vcs}{rev}.dirty.core\",\n    },\n    \"write\": {\n        \"file\": \"src/espresso/_version.py\"\n    },\n    \"tag2version\": {\n        \"rmprefix\": \"v\",\n        \"rmsuffix\": \"\",\n    }\n}\ntry:            # generate _version.py when building the core package\n    versioningit.get_version(_ROOT, versioningit_config, True)\nexcept:\n    pass        # VCS not found, there should be a version file to read\n\n# read from _version.py\nwith open(str(_ROOT / \"src\" / \"espresso\" / \"_version.py\")) as f:\n    for line in f:\n        if line.startswith(\"__version__ = \"):\n            _, _, version = line.partition(\"=\")\n            VERSION = version.strip(\" \\n'\\\"\")\n            break\n    else:\n        raise RuntimeError(\"unable to read the version from src/espresso/_version.py\")\n\n\n########################## LONG DESCRIPTION ###########################################\nLONG_DESCRIPTION = (_ROOT / \"README.md\").read_text()\nCONTENT_TYPE = \"text/markdown\"\n\n\n########################## CLEAN CACHE ################################################\nfrom shutil import rmtree\n_skbuild_dir = _ROOT / \"_skbuild\"\nif _skbuild_dir.exists() and _skbuild_dir.is_dir():\n    rmtree(_skbuild_dir)\n\n\n########################## OTHER METADATA #############################################\nPACKAGE_NAME = \"geo-espresso\"\nAUTHOR = f\"InLab, Espresso development team\"\nDESCRIPTION = \"Earth Science PRoblems for the Evaluation of Strategies, Solvers and Optimizers\"\nKEYWORDS = [\"inversion\", \"inference\", \"python package\", \"geoscience\", \"geophysics\"]\nCLASSIFIERS = [\n    \"Development Status :: 2 - Pre-Alpha\",\n    \"Intended Audience :: Education\",\n    \"Intended Audience :: Science/Research\",\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.6\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: C\",\n    \"Programming Language :: Fortran\",\n    \"Topic :: Scientific/Engineering :: Physics\",\n    \"License :: OSI Approved :: BSD License\",\n    \"License :: Other/Proprietary License\",\n]\nPACKAGE_DIR = {\"\": \"src\"}\nPACKAGES = setuptools.find_namespace_packages(where='src')\nCMAKE_INSTALL_DIR = f\"src/espresso\"\nCMAKE_ARGS = ['-DSKBUILD=ON']\nPYTHON_REQUIRES = \">=3.7\"\nINSTALL_REQUIRES = [\n    \"numpy>=1.18\",\n    \"scipy>=1.0.0\",\n    \"matplotlib>=3.1\",\n    \"tqdm>=4.0\",\n    \"mpmath>=1.2.0\",\n]\n\n\n########################## SETUP ######################################################\nclass NullIO(io.StringIO):\n    def write(self, txt):\n       pass\nsys.stdout = NullIO()\nsys.tracebacklimit = 0\n\ntry:\n    skbuild.setup(\n        name=PACKAGE_NAME,\n        version=VERSION,\n        author=AUTHOR,\n        description=DESCRIPTION,\n        long_description=LONG_DESCRIPTION,\n        long_description_content_type=CONTENT_TYPE,\n        keywords=KEYWORDS,\n        classifiers=CLASSIFIERS,\n        package_dir=PACKAGE_DIR,\n        packages=PACKAGES,\n        include_package_data=True,\n        cmake_install_dir=CMAKE_INSTALL_DIR,\n        cmake_args=CMAKE_ARGS,\n        python_requires=PYTHON_REQUIRES,\n        install_requires=INSTALL_REQUIRES,\n    )\nexcept SystemExit as e:\n    skbuild_error : skbuild.exceptions.SKBuildError = e.args[0]\n    error_message = skbuild_error.args[0]\n    error_message += \"\\n\\nHint: search 'error' in current terminal session to find out the details. \"\n    # error_message += f\"Here are some possible reasons that cause failure in building `{PACKAGE_NAME}`:\"\n    # error_message += \"\\n\\t1. no Fortran compiler found -> install a Fortran compiler and ensure it's included in the path\"\n    error_message += \"\\n\\n\"\n    # error_message += \"If the error is not due to above reasons, \"\n    # error_message += \"please feel free to lodge an issue \" \\\n                    #  f\"at https://github.com/inlab-geo/{PACKAGE_NAME}/issues for help\\n\"\n    skbuild_error.args = (error_message,)\n    sys.exit(skbuild_error)",
    "pyproject.toml": "# --------------------------- BEGIN NOTES ---------------------------\n\n####### TO INSTALL #######\n# pip install .                           # core only, or\n# python espresso_machine/build_package/build.py     # with contributions\n\n####### TO TEST #######\n# python espresso_machine/build_package/validate.py --pre\n# python espresso_machine/build_package/validate.py --post\n\n####### TO FORMAT #######\n# black --check src/espresso\n# black src/espresso\n\n####### PYLINT #######\n# pylint src/espresso\n\n# --------------------------- END NOTES -----------------------------\n\n[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"scikit-build>=0.13,<0.17.3\",\n    \"cmake>=3.18\",\n    \"ninja\",\n    \"versioningit\",\n    \"numpy>=1.18\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 88\ntarget_version = ['py38']\nexperimental_string_processing = true\nexclude = '''\n(\n  /(\n    \\.git\n    | \\.mypy_cache\n    | \\.vscode\n    | build\n    | lib.*\n    | dist\n    | _skbuild\n  )/\n  | tests\n)\n'''\n"
  },
  "fmozafari/angel": {
    "libs/tweedledum/setup.py": "#-------------------------------------------------------------------------------\n# Part of Tweedledum Project.  This file is distributed under the MIT License.\n# See accompanying file /LICENSE for details.\n#-------------------------------------------------------------------------------\nimport os\nimport sys\nimport setuptools\nimport time\nfrom pathlib import Path\n\nbuild_dev_version = os.environ.get('TWEEDLEDUM_DEV_VERSION', False)\n\ntry:\n    import skbuild\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nREADME_PATH = os.path.join(os.path.abspath(os.path.dirname(__file__)),\n                           'README.md')\nwith open(README_PATH) as readme_file:\n    README = readme_file.read()\n\ndef get_name():\n    if build_dev_version:\n        return \"tweedledum-dev\"\n    else:\n        return \"tweedledum\"\n\ndef get_version():\n    if build_dev_version:\n        return \"1.1.0.dev\" + str(build_dev_version)\n    else:\n        return \"1.0.0\"\n\nskbuild.setup(\n    name=get_name(),\n    version=get_version(),\n    description=\"A library for synthesizing and manipulating quantum circuits\",\n    long_description=README,\n    long_description_content_type='text/markdown',\n    url=\"https://github.com/boschmitt/tweedledum\",\n    author='Bruno Schmitt',\n    author_email='bruno.schmitt@epfl.ch',\n    license=\"MIT\",\n    package_dir={'': 'python'},\n    packages=setuptools.find_packages(where='python', include=['tweedledum', 'tweedledum.*']),\n    include_package_data=True,\n    zip_safe=False,\n    python_requires=\">=3.6\",\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\"\n    ],\n    cmake_install_dir='python'\n)\n\n# /!\\ This is a 'gambiarra':\n# For whatever reason, whenever I try to install `tweedledum` in development \n# mode, i.e., `pip install -e .`, the easy_path and egg-link are wrong! Hence, \n# I basically fix them by hand because I couldn't figure out a better way of \n# doing it!\nif len(sys.argv) > 1 and sys.argv[1] == \"develop\":\n    import fileinput\n    import shutil\n    import site\n    easy_install = Path(site.getsitepackages()[0]) / 'easy-install.pth'\n    egg_link = Path(site.getsitepackages()[0])  / 'tweedledum.egg-link'\n    for line in fileinput.input([easy_install, egg_link], inplace=True):\n        print(line.replace(\"tweedledum\", \"tweedledum/python\"),  end=\"\")\n    shutil.rmtree('tweedledum.egg-info', ignore_errors=True)\n",
    "libs/tweedledum/pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n"
  },
  "astro-informatics/s2let": {
    "setup.py": "from pathlib import Path\n\nfrom skbuild import setup\n\ncmake_args = [\n    \"-DBUILD_TESTING:BOOL=OFF\",\n    \"-Dconan_deps:BOOL=ON\",\n    \"-Dcfitsio:BOOL=ON\",\n    \"-DCMAKE_POSITION_INDEPENDENT_CODE=ON\",\n]\n\nbuild_requirements = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake>=3.12\",\n    \"ninja\",\n    \"cython\",\n    \"conan\",\n    \"pip!=20.0.0,!=20.0.1\",\n]\n\nsetup(\n    name=\"pys2let\",\n    version=\"2.2.5\",\n    author=[\"Boris Leistedt\", \"Martin B\u00fcttner\", \"Jennifer Chan\", \"Jason McEwen\"],\n    install_requires=[\"numpy\"],\n    extras_require={\n        \"dev\": build_requirements + [\"pytest\", \"black\"],\n        \"plots\": [\"scipy\", \"healpy\"],\n    },\n    description=\"Fast spin spherical transforms\",\n    url=\"http://astro-informatics.github.io/s2let/\",\n    package_dir={\"pys2let\": \"src/main/pys2let\"},\n    cmake_args=cmake_args,\n    cmake_languages=(\"C\",),\n    license=\"GPL-2\",\n    packages=[\"pys2let\"],\n    long_description=Path(__file__).with_name(\"README.md\").read_text(),\n    long_description_content_type=\"text/markdown\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\", \"wheel\", \"scikit-build\", \"cmake>=3.12\", \"ninja\", \"cython\",\n    \"numpy\", \"conan<2\"\n]\n[tool.black]\nline-length = 88\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nensure_newline_before_comments = true\nline_length = 88\n\n[tool.pylint.format]\nmax-line-length = 88\n",
    "setup.cfg": "[bumpversion]\ncurrent_version = 2.2.5\ncommit = False\ntag = False\n\n[bumpversion:file:src/doxygen.config]\n\n[bumpversion:file:setup.py]\n\n[bumpversion:file:makefile]\n\n[bumpversion:file:CMakelists.txt]\n\n[bumpversion:file:.github/workflows/python.yml]\n\n[flake8]\nmax-line-length = 88\nextend-ignore = E203, W503\nexclude = \n\t.tox,\n\t.git,\n\tbuild,\n\t__pycache__,\n\tdocs/,\n\n[pycodestyle]\ncount = False\nmax-line-length = 88\nstatistics = True\n"
  },
  "keichi/kEDM": {
    "setup.py": "import platform\n\nfrom skbuild import setup\nimport versioneer\n\nwith open(\"README.md\", \"r\") as f:\n    readme = f.read()\n\ncmake_args = [\"-DKEDM_ENABLE_PYTHON=ON\",\n              \"-DKEDM_ENABLE_TESTS=OFF\",\n              \"-DKEDM_ENABLE_EXECUTABLES=OFF\",\n              \"-DKEDM_ENABLE_CPU=ON\"]\n\nif platform.system() == \"Darwin\":\n    if platform.processor() == \"arm\":\n        cmake_args += [\n            \"-DCMAKE_CXX_FLAGS=-I/opt/homebrew/opt/libomp/include -Xpreprocessor -fopenmp\",\n            \"-DCMAKE_EXE_LINKER_FLAGS=-L/opt/homebrew/opt/libomp/lib -lomp\",\n            \"-DCMAKE_MODULE_LINKER_FLAGS=-L/opt/homebrew/opt/libomp/lib -lomp\"\n        ]\n    elif platform.processor() == \"i386\":\n        cmake_args += [\n            \"-DCMAKE_CXX_FLAGS=-I/usr/local/include -Xpreprocessor -fopenmp\",\n            \"-DCMAKE_MODULE_LINKER_FLAGS=-L/usr/local/lib -rpath /usr/local/lib -lomp\"\n        ]\n\nsetup(\n    name=\"kedm\",\n\n    version=versioneer.get_version(),\n    cmdclass=versioneer.get_cmdclass(),\n\n    author=\"Keichi Takahashi\",\n    author_email=\"hello@keichi.dev\",\n\n    packages=[\"kedm\"],\n    package_dir={\"kedm\": \"python/kedm\"},\n\n    cmake_args=cmake_args,\n\n    url=\"https://github.com/keichi/kEDM\",\n    project_urls={\n        \"Documentation\": \"https://kedm.readthedocs.io/\",\n        \"Source Code\": \"https://github.com/keichi/kEDM\",\n        \"Bug Tracker\": \"https://github.com/keichi/kEDM/issues\",\n    },\n\n    description=\"A high-performance implementation of the Empirical Dynamic\"\n                \" Modeling (EDM) framework\",\n\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n\n    classifiers=[\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering :: Mathematics\",\n    ],\n\n    license=\"MIT\",\n\n    install_requires=[\"numpy>=1.7.0\"],\n    extras_require={\n        \"test\": [\"pytest>=6.2.0\"],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"tomli\"]\n\n[tool.versioneer]\nVCS = \"git\"\nstyle = \"pep440\"\nversionfile_source = \"python/kedm/_version.py\"\nversionfile_build = \"kedm/_version.py\"\ntag_prefix = \"v\"\n"
  },
  "KitwareMedical/ITKStrain": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-strain',\n    version='0.4.0',\n    author='Matthew M. McCormick',\n    author_email='matt.mccormick@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKStrain',\n    description=r'ITK filters to estimate a strain tensor field from a displacement field or a spatial transformation',\n    long_description='itk-strain provides N-dimensional computational '\n                     'framework of strain tensor images in the Insight '\n                     'Toolkit. The filters provided can compute a strain '\n                     'tensor image from a displacement field image and a '\n                     'strain tensor image from a general spatial transform. '\n                     'In both cases, infinitesimal, Green-Lagrangian, or '\n                     'Eulerian-Almansi strain can be generated.\\n'\n                     'Please refer to:\\n'\n                     'M. McCormick, \"N-Dimensional Computation of Strain Tensor Images in the Insight Toolkit.\", '\n                     'Insight Journal, January-December 2017, https://hdl.handle.net/10380/3573',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK Strain Tensor Displacement Field',\n    url=r'https://github.com/InsightSoftwareConsortium/ITKStrain',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "synthizer/synthizer-python": {
    "setup.py": "import os\nimport os.path\nimport shutil\nimport stat\nimport subprocess\n\nfrom setuptools import Extension, setup\nfrom Cython.Build import cythonize\nfrom Cython.Compiler import Options\n\nVERSION = \"0.12.5\"\n\n# A helper for rmtree. On Windows, read-only files can't be deleted by rmtree, so we make them not readonly.\ndef handle_remove_readonly(func, path, exc):\n    os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)  # 0777\n    func(path)\n\nextension_args = {}\nOptions.language_level = 3\n\n# scikit-build isn't always present.\nfrom skbuild import cmaker\n\n# we can go via scikit-build to try to run CMake. This is reliable enough on Linux and Mac, but will probably\n# give people trouble on Windows, thus us publishing wheels.\n# Find this file:\nroot_dir = os.path.split(os.path.abspath(__file__))[0]\nvendored_dir = os.path.join(root_dir, \"synthizer-vendored\")\nos.chdir(root_dir)\n\nsynthizer_lib_dir = \"\"\nif 'CI_SDIST' not in os.environ:\n    # Configure and build Synthizer itself.\n    cmake = cmaker.CMaker()\n    # Force Ninja on all platforms. This lets us work on Windows reliably if run\n    # from an MSVC shell, where reliably means fail noisily and obviously at the\n    # beginning if the world is insane.\n    cmake.configure(\n        cmake_source_dir=vendored_dir,\n        generator_name=\"Ninja\",\n        clargs=[\n            \"-DCMAKE_BUILD_TYPE=Release\",\n            \"-DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded\",\n            \"-DCMAKE_POSITION_INDEPENDENT_CODE=TRUE\",\n            \"-DSYZ_INTEGRATING=ON\",\n        ],\n    )\n    cmake.make()\n    # what actually happens here is that Synthizer only installs one path. It is\n    # unfortunately the case that skbuild is making architecture specific\n    # directories so, instead of guessing, just grab it.\n    synthizer_lib_dir = os.path.split(os.path.abspath(cmake.install()[0]))[0]\nextension_args = {\n    \"include_dirs\": [os.path.join(vendored_dir, \"include\")],\n    \"library_dirs\": [synthizer_lib_dir],\n    \"libraries\": [\"synthizer\"],\n}\n\nextensions = [\n    Extension(\"synthizer.synthizer\", [\"synthizer/synthizer.pyx\"], **extension_args),\n]\n\nsetup(\n    name=\"synthizer\",\n    version=VERSION,\n    author=\"Synthizer Developers\",\n    author_email=\"ahicks@ahicks.io\",\n    url=\"https://synthizer.github.io\",\n    ext_modules=cythonize(extensions, language_level=3),\n    zip_safe=False,\n    include_package_data=True,\n    packages=[\"synthizer\"],\n    package_data={\n        \"synthizer\": [\"*.pyx\", \"*.pxd\", \"*.pyi\", \"py.typed\"],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"Cython\", \"scikit-build\", \"ninja\", \"cmake\"]"
  },
  "PolasekT/ICTree": {
    "PerceptualMetric/cython/setup.py": "import sys\n\nfrom skbuild import setup\n\n\nsetup(\n    name=\"treeio\",\n    version=\"0.0.1\",\n    description=\"TreeIO C++ binding\",\n    author=\"Tomas Polasek\",\n    license=\"MIT\",\n    packages=[\"treeio\"],\n    install_requires=[\"cython\"],\n)\n"
  },
  "astro-informatics/ssht": {
    "setup.py": "from pathlib import Path\n\nfrom skbuild import setup\n\ncmake_args = [\n    \"-DBUILD_TESTING:BOOL=OFF\",\n    \"-Dconan_deps=ON\",\n    \"-DCMAKE_POSITION_INDEPENDENT_CODE=ON\",\n]\n\ndev_requirements = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake>=3.12\",\n    \"ninja\",\n    \"cython\",\n    \"conan\",\n    \"pip!=20.0.0,!=20.0.1\",\n    \"pytest\",\n    \"ducc0>=0.18\",\n]\n\nlong_description = (\n    Path(__file__).parent / \"src\" / \"pyssht\" / \"SSHT_Python_Documentation.md\"\n).read_text()\n\nsetup(\n    name=\"pyssht\",\n    version=\"1.5.2\",\n    author=[\n        \"J. D. McEwen\",\n        \"C. R. G. Wallis\",\n        \"M. Buttner\",\n        \"B. Leistedt\",\n        \"Y. Wiaux\",\n    ],\n    install_requires=[\"numpy\", \"scipy\"],\n    extras_require={\"dev\": dev_requirements, \"ducc0\": [\"ducc0>=0.18\"]},\n    description=\"Fast spin spherical transforms\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"http://astro-informatics.github.io/ssht/\",\n    package_dir={\"pyssht\": \"src/pyssht\"},\n    package_data={\"pyssht\": [\"SSHT_Python_Documentation.md\"]},\n    cmake_args=cmake_args,\n    cmake_languages=(\"C\",),\n    license=\"GPL-3\",\n    packages=[\"pyssht\"],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\", \"wheel\", \"scikit-build\", \"cmake>=3.12\", \"ninja\", \"cython\",\n    \"oldest-supported-numpy\", \"conan<2\"\n]\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nensure_newline_before_comments = true\nline_length = 88\n\n[tool.pylint.messages_control]\ndisable = \"C0330, C0326\"\n\n[tool.pylint.format]\nmax-line-length = \"88\"\n",
    "setup.cfg": "[bumpversion]\ncurrent_version = 1.5.2\ncommit = False\ntag = False\nparse = (?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)(rc(?P<rc>\\d+))?\nserialize = \n\t{major}.{minor}.{patch}rc{rc}\n\t{major}.{minor}.{patch}\n\n[bumpversion:file:setup.py]\n\n[bumpversion:file:makefile]\n\n[bumpversion:file:CMakelists.txt]\n\n[bumpversion:file:.github/workflows/python.yml]\n\n[flake8]\nmax-line-length = 88\nextend-ignore = E203, W503\nexclude = \n\t.tox,\n\t.git,\n\tbuild,\n\t__pycache__,\n\tdocs/,\n\n[pycodestyle]\nmax-line-length = 88\nignore = E203\n"
  },
  "nightlark/swig-pypi": {
    "setup.py": "import os\nimport sys\nfrom distutils.text_file import TextFile\nfrom wheel.bdist_wheel import bdist_wheel as _bdist_wheel\nfrom skbuild import setup\n\n# may be needed in some cases to get version correctly during builds\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\nfrom setuptools_scm import get_version  # noqa: E402\n\n\nclass genericpy_bdist_wheel(_bdist_wheel):\n    def finalize_options(self):\n        _bdist_wheel.finalize_options(self)\n        self.root_is_pure = False\n\n    def get_tag(self):\n        python, abi, plat = _bdist_wheel.get_tag(self)\n        python, abi = \"py2.py3\", \"none\"\n        return python, abi, plat\n\n\nwith open(\"README.md\", \"r\") as fp:\n    readme = fp.read()\n\ncmdclass = {\"bdist_wheel\": genericpy_bdist_wheel}\n\nsetup(\n    name=\"swig\",\n    version=get_version(),\n    cmdclass=cmdclass,\n    package_dir={\"\": \"src\"},\n    packages=[\"swig\"],\n    cmake_install_dir=\"src/swig/data\",\n    entry_points={\"console_scripts\": [\"swig=swig:swig\"]},\n    url=\"http://www.swig.org/\",\n    download_url=\"http://www.swig.org/download.html\",\n    project_urls={\n        \"Source Code\": \"https://github.com/nightlark/swig-pypi\",\n        \"Bug Tracker\": \"https://github.com/nightlark/swig-pypi/issues\",\n    },\n    description=\"SWIG is a software development tool that connects \"\n    \"programs written in C and C++ with a variety of \"\n    \"high-level programming languages.\",\n    long_description=readme,\n    long_description_content_type=\"text/markdown\",\n    classifiers=[\n        \"License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\",\n        \"License :: Other/Proprietary License\",\n        \"Programming Language :: C\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python\",\n        \"Operating System :: OS Independent\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: Software Development :: Build Tools\",\n    ],\n    license=\"https://github.com/swig/swig/blob/master/LICENSE\",\n    keywords=\"swig build c c++\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=45\", \"wheel\", \"scikit-build\", \"setuptools_scm>=6.2\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild = \"cp39-*\"\nbefore-all = [\n    \"pipx install -f cmake==3.21.4\",\n    \"cmake --version\",\n    \"pipx install -f ninja==1.10.2.2\",\n    \"ninja --version\",\n]\ntest-command = [\n  \"swig -version\",\n  \"swig -pcreversion\",\n  \"swig -help\",\n]\n\n[tool.cibuildwheel.linux]\nmanylinux-x86_64-image = \"manylinux1\"\nmanylinux-i686-image = \"manylinux1\"\n\n[tool.setuptools_scm]\nwrite_to = \"src/swig/_version.py\"\n",
    "setup.cfg": "[flake8]\nignore = E203, E266, E501, W503, F403, F401\nmax-line-length = 88\nmax-complexity = 18\nselect = B,C,E,F,W,T4,B9\n"
  },
  "Learning-and-Intelligent-Systems/open-world-tamp": {
    "vision_utils/AtlasNet/auxiliary/sampling_and_meshing/O-CNN/virtual_scanner/setup.py": "from skbuild import setup\n\nsetup(\n    name=\"ocnn.virtualscanner\",\n    version=\"18.09.05\",\n    description=\"Virtual scanner utilities\",\n    author='Microsoft',\n    author_email=\"dapisani@microsoft.com\",\n    packages=['ocnn', 'ocnn.virtualscanner'],\n    zip_safe=False,\n    install_requires=['Cython', 'pyyaml'],\n    package_dir={'': 'python'},\n    package_data={'ocnn.virtualscanner': ['*.pxd']}\n)\n"
  },
  "dfm/copier-python": {
    "template/setup.py.jinja": "{% if enable_pybind11 -%}\nfrom skbuild import setup\nfrom setuptools import find_packages\n\nsetup(\n    name=\"{{ python_package_distribution_name }}\",\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/{{ python_package_import_name }}\",\n    include_package_data=True,\n)\n{%- else -%}\nfrom setuptools import find_packages, setup\n\nsetup(\n    name=\"{{ python_package_distribution_name }}\",\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n)\n{%- endif %}\n"
  },
  "tomography/tomocupy": {
    "setup.py": "from skbuild import setup\nfrom setuptools import find_packages\n\nsetup(\n    name='tomocupy',\n    version=open('VERSION').read().strip(),\n    author='Viktor Nikitin',\n    package_dir={\"\": \"src\"},\n    scripts=['bin/tomocupy_cli.py'],  \n    entry_points={'console_scripts':['tomocupy = tomocupy_cli:main'],},\n    packages=find_packages('src'),\n    zip_safe=False,\n)\n"
  },
  "wjakob/ek_python_test": {
    "setup.py": "import setuptools\n\ntry:\n    from skbuild import setup\n    import pybind11\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nsetup(\n    name=\"ek_python_test\",\n    version=\"0.0.1\",\n    author=\"Author name\",\n    author_email=\"user@domain.org\",\n    description=\"A brief description\",\n    url=\"https://github.com/...\",\n    long_description=\"A longer description\",\n    long_description_content_type='text/markdown',\n    cmake_args=[\n        # List of commands that should be specified to CMake\n        '-DSOME_FLAGS=1234'\n    ],\n    packages=['ek_python_test']\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"scikit-build\", \"cmake\", \"ninja\", \"pybind11\", \"enoki\"]\n"
  },
  "dune-project/dune-istl": {
    "setup.py": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\nimport os, sys\ntry:\n    from dune.packagemetadata import metaData\nexcept ImportError:\n    from packagemetadata import metaData\nfrom skbuild import setup\nsetup(**metaData()[1])\n",
    "pyproject.toml": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\n[build-system]\nrequires = ['dune-common@git+https://gitlab.dune-project.org/core/dune-common.git', 'numpy', 'pip', 'setuptools', 'wheel', 'scikit-build', 'cmake', 'ninja', 'requests']\nbuild-backend = 'setuptools.build_meta'\n"
  },
  "dune-project/dune-geometry": {
    "setup.py": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\nimport os, sys\ntry:\n    from dune.packagemetadata import metaData\nexcept ImportError:\n    from packagemetadata import metaData\nfrom skbuild import setup\nsetup(**metaData()[1])\n",
    "pyproject.toml": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\n[build-system]\nrequires = ['dune-common@git+https://gitlab.dune-project.org/core/dune-common.git', 'pip', 'setuptools', 'wheel', 'scikit-build', 'cmake', 'ninja', 'requests']\nbuild-backend = 'setuptools.build_meta'\n"
  },
  "segevfiner/cyminhook": {
    "setup.py": "import re\nfrom skbuild import setup\nfrom setuptools import find_packages\n\n\nwith open(\"cyminhook/__init__.py\", \"r\", encoding=\"utf-8\") as f:\n    version = re.search(r'(?m)^__version__ = \"([a-zA-Z0-9.-]+)\"', f.read()).group(1)\n\nwith open(\"README.rst\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\n\nsetup(\n    name=\"cyminhook\",\n    version=version,\n    author=\"Segev Finer\",\n    author_email=\"segev208@gmail.com\",\n    description=\"Hook functions on Windows using MinHook\",\n    long_description=long_description,\n    long_description_content_type=\"text/x-rst\",\n    url=\"https://github.com/segevfiner/cyminhook\",\n    project_urls={\n        \"Documentation\": \"https://segevfiner.github.io/cyminhook/\",\n        \"Issue Tracker\": \"https://github.com/segevfiner/cyminhook/issues\",\n    },\n    license=\"MIT\",\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Environment :: Win32 (MS Windows)\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: Security\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Programming Language :: Cython\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    keywords=\"MinHook\",\n    zip_safe=False,\n    packages=find_packages(),\n    python_requires='>=3.6',\n    extras_require={\n        \"dev\": [\n            \"sphinx==5.*\",\n        ],\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build>=0.13.1\", \"cmake\", \"ninja; sys_platform != 'win32'\", \"cython\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "robocin/rSim": {
    "setup.py": "import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('Please update pip, you need pip 10 or greater,\\n'\n          ' or you need to install the PEP 518 requirements in pyproject.toml yourself', file=sys.stderr)\n    raise\n\nsetup(\n    name=\"rc-robosim\",\n    url=\"https://github.com/robocin/rSim\",\n    description=\"SSL and VSS robot soccer simulator\",\n    author='Felipe Martins',\n    author_email=\"fbm2@cin.ufpe.br\",\n    packages=['robosim'],\n    package_dir={'': 'src'},\n    cmake_install_dir='src/robosim'\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"setuptools_scm>=6.2\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\n"
  },
  "kjelljorner/libdlfind": {
    "setup.py": "#  Copyright 2021 Kjell Jorner\n#\n#  This file is part of libdlfind.\n#\n#  libdlfind is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU Lesser General Public License as\n#  published by the Free Software Foundation, either version 3 of the\n#  License, or (at your option) any later version.\n#\n#  libdlfind is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU Lesser General Public License for more details.\n#\n#  You should have received a copy of the GNU Lesser General Public\n#  License along with libdlfind.  If not, see\n#  <http://www.gnu.org/licenses/>.\n\nfrom skbuild import setup\n\nURL = \"https://github.com/kjelljorner/libdlfind\"\nDESCRIPTION = \"Python library for DL-FIND\"\nLONG_DESCRIPTION = f\"\"\"\\\n{DESCRIPTION}. For more information, see the [project repository]({URL}).\n\"\"\"\n\nsetup(\n    name=\"libdlfind\",\n    version=\"0.0.3\",\n    author=\"Kjell Jorner\",\n    author_email=\"kjell.jorner@gmail.com\",\n    description=DESCRIPTION,\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/markdown\",\n    url=URL,\n    packages=[\"libdlfind\"],\n    python_requires=\">=3.8\",\n    install_requires=[\"numpy\"],\n    include_package_data=True,\n    cmake_args=[\"-DSKBUILD=ON\"],\n    license=\"LGPLv3\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)\",\n        \"Operating System :: OS Independent\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja; platform_system!='Windows'\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[metadata]\nlicense_files = [\"COPYING\", \"COPYING.LESSER\", \"LICENSE_bundled.txt\"]\n\n[tool.coverage.run]\nbranch = true\nomit = [\"*/site-packages/*\"]\n\n[tool.coverage.report]\nshow_missing = true\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\nforce_sort_within_sections = true\norder_by_type = false\ngroup_by_package = true\nlexicographical = true\n\n[tool.mypy]\ndisallow_any_explicit = false\ndisallow_any_generics = false\nallow_redefinition = true\ncheck_untyped_defs = true\ndisallow_untyped_calls = true\ndisallow_subclassing_any = true\nfollow_imports = \"silent\"\nignore_errors = false\nignore_missing_imports = true\nimplicit_reexport = false\nstrict_optional = true\nstrict_equality = true\nno_implicit_optional = true\nlocal_partial_types = true\nwarn_no_return = true\nwarn_unused_ignores = true\nwarn_redundant_casts = true\nwarn_return_any = true\nwarn_unused_configs = true\nwarn_unreachable = true\nshow_traceback = true\n\n[[tool.mypy.overrides]]\nmodule = \"numpy.*\"\nallow_untyped_calls = true"
  },
  "Budapest-Quantum-Computing-Group/piquassoboost": {
    "setup.py": "#\n# Copyright 2021-2022 Budapest Quantum Computing Group\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom skbuild import setup\nfrom setuptools import find_packages\n\n\nsetup(\n    name=\"piquassoboost\",\n    packages=find_packages(\n        exclude=(\n            \"tests\", \"tests.*\",\n            \"ctests\", \"ctests.*\",\n            \"performance_tests\", \"performance_tests.*\",\n            \"piquasso\", \"piquasso.*\",\n        )\n    ),\n    version='0.2.0',\n    url=\"https://gitlab.inf.elte.hu/wigner-rcp-quantum-computing-and-information-group/piquassoboost\",  # noqa: E501\n    maintainer=\"The Piquasso team\",\n    maintainer_email=\"kolarovszki@inf.elte.hu\",\n    include_package_data=True,\n    install_requires=[\n        \"numpy>=1.19.4\",\n        \"piquasso==2.0.0\",\n    ],\n    tests_require=[\"pytest\"],\n    description='The C++ binding for the Piquasso project',\n    long_description=open(\"./README.md\", 'r').read(),\n    long_description_content_type=\"text/markdown\",\n    keywords=\"test, cmake, extension\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: \"\n        \"Apache License 2.0.\",\n        \"Natural Language :: English\",\n        \"Programming Language :: C\",\n        \"Programming Language :: C++\"\n    ],\n    license='Apache License 2.0.',\n    scripts=[\n        \"cmake/check_AVX.cmake\",\n        \"cmake/FindBLASEXT.cmake\",\n        \"cmake/FindCBLAS.cmake\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja\",\n    \"numpy\",\n    \"tbb-devel\",\n]\n"
  },
  "lioujheyu/gevo": {
    "setup.py": "#!/usr/bin/env python\n\nimport sys\nimport os\nimport codecs\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\ndef read(rel_path):\n    here = os.path.abspath(os.path.dirname(__file__))\n    with codecs.open(os.path.join(here, rel_path), 'r') as fp:\n        return fp.read()\n\ndef get_version(rel_path):\n    for line in read(rel_path).splitlines():\n        if line.startswith('__version__'):\n            delim = '\"' if '\"' in line else \"'\"\n            return line.split(delim)[1]\n    else:\n        raise RuntimeError(\"Unable to find version string.\")\n\nsetup(\n    name='gevo',\n    version=get_version(\"gevo/__init__.py\"),\n    python_requires='>=3.6.1',\n    description='Optimize CUDA kernel code using Evolutionary Computation',\n    author='Jhe-Yu Liou',\n    author_email='lioujheyu@gmail.com',\n    url='https://github.com/lioujheyu/gevo',\n    install_requires=[\n        'deap>=1.2',\n        'matplotlib>=2.1',\n        'python-pptx>=0.6',\n        'psutil',\n        'rich>=9.11',\n        'pandas',\n        'pycuda',\n        'argcomplete'\n    ],\n    packages=['gevo', 'cuprof', 'fuzzycompare', 'variancecalc', 'llvm-mutate'],\n    scripts=[\n        'bin/gevo-evolve',\n        'bin/gevo-analyze',\n        'bin/gevo-evaluate',\n        'bin/gevo-stage-analyze',\n        'bin/gevo-explore',\n        'bin/llvm-mutate',\n        'bin/cuprof'\n    ],\n    zip_safe=False,\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'Intended Audience :: Science/Research',\n        'Topic :: Software Development :: Code Generators',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: C++',\n    ],\n    cmake_install_dir=\"gevo\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"pybind11\", \"lit\", \"filecheck\"]\n"
  },
  "Zhaoyilunnn/q-gpu": {
    "setup.py": "# pylint: disable=invalid-name\n\n\"\"\"\nMain setup file for qiskit-aer\n\"\"\"\nimport distutils.util\nimport importlib\nimport inspect\nimport os\nimport setuptools\nimport subprocess\nimport sys\n\n\nPACKAGE_NAME = os.getenv('QISKIT_AER_PACKAGE_NAME', 'qiskit-aer')\n_DISABLE_CONAN = distutils.util.strtobool(os.getenv(\"DISABLE_CONAN\", \"OFF\").lower())\n\nif not _DISABLE_CONAN:\n    try:\n        from conans import client\n    except ImportError:\n        subprocess.call([sys.executable, '-m', 'pip', 'install', 'conan>=1.31.2'])\n        from conans import client\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    subprocess.call([sys.executable, '-m', 'pip', 'install', 'scikit-build'])\n    from skbuild import setup\ntry:\n    import pybind11\nexcept ImportError:\n    subprocess.call([sys.executable, '-m', 'pip', 'install', 'pybind11>=2.6'])\n\ntry:\n    from numpy import array\nexcept ImportError:\n    subprocess.call([sys.executable, '-m', 'pip', 'install', 'numpy>=1.16.3'])\n\nfrom skbuild import setup\n\n\n# These are requirements that are both runtime/install dependencies and\n# also build time/setup requirements and will be added to both lists\n# of requirements\ncommon_requirements = [\n    'numpy>=1.16.3',\n    'scipy>=1.0',\n    'pybind11>=2.6'  # This isn't really an install requirement,\n                     # Pybind11 is required to be pre-installed for\n                     # CMake to successfully find header files.\n                     # This should be fixed in the CMake build files.\n]\n\nsetup_requirements = common_requirements + [\n    'scikit-build',\n    'cmake!=3.17,!=3.17.0',\n]\nif not _DISABLE_CONAN:\n    setup_requirements.append('conan>=1.22.2')\n\nrequirements = common_requirements + ['qiskit-terra>=0.16.0']\n\nif not hasattr(setuptools,\n               'find_namespace_packages') or not inspect.ismethod(\n                    setuptools.find_namespace_packages):\n    print(\"Your setuptools version:'{}' does not support PEP 420 \"\n          \"(find_namespace_packages). Upgrade it to version >='40.1.0' and \"\n          \"repeat install.\".format(setuptools.__version__))\n    sys.exit(1)\n\nVERSION_PATH = os.path.join(os.path.dirname(__file__),\n                            \"qiskit\", \"providers\", \"aer\", \"VERSION.txt\")\nwith open(VERSION_PATH, \"r\") as version_file:\n    VERSION = version_file.read().strip()\n\nREADME_PATH = os.path.join(os.path.abspath(os.path.dirname(__file__)),\n                           'README.md')\nwith open(README_PATH) as readme_file:\n    README = readme_file.read()\n\nsetup(\n    name=PACKAGE_NAME,\n    version=VERSION,\n    packages=setuptools.find_namespace_packages(include=['qiskit.*']),\n    cmake_source_dir='.',\n    description=\"Qiskit Aer - High performance simulators for Qiskit\",\n    long_description=README,\n    long_description_content_type='text/markdown',\n    url=\"https://github.com/Qiskit/qiskit-aer\",\n    author=\"AER Development Team\",\n    author_email=\"hello@qiskit.org\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Environment :: Console\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Topic :: Scientific/Engineering\",\n    ],\n    python_requires=\">=3.6\",\n    install_requires=requirements,\n    setup_requires=setup_requirements,\n    include_package_data=True,\n    cmake_args=[\"-DCMAKE_OSX_DEPLOYMENT_TARGET:STRING=10.9\"],\n    keywords=\"qiskit aer simulator quantum addon backend\",\n    zip_safe=False\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"conan>=1.31.2\", \"scikit-build\",\n  \"cmake!=3.17.1,!=3.17.0\", \"ninja\", \"pybind11>2.6\", \"numpy>1.16.3\"]\n"
  },
  "GERSL/pycold": {
    "setup.py": "\"\"\"\nPyCOLD setup script\n\"\"\"\n\n__notes__ = \"\"\"\n# Check contents of wheel\nrm -rf _skbuild/ dist/ tool/python/pycold.egg-info/\npython setup.py bdist_wheel && unzip -l dist/pycold-0.1.0-cp38-cp38-linux_x86_64.whl\n\npip install dist/pycold-0.1.0-cp38-cp38-linux_x86_64.whl\npython -c \"import pycold\"\n\"\"\"\nimport sys\nimport os\nfrom setuptools import find_packages\n\n# Allow disabling of C-extensions to debug pure-python code\nPYCOLD_DISABLE_C_EXTENSIONS = os.environ.get('PYCOLD_DISABLE_C_EXTENSIONS', '')\nif PYCOLD_DISABLE_C_EXTENSIONS == '1':\n    from setuptools import setup\nelse:\n    from skbuild import setup\n\n\ndef parse_version(fpath):\n    \"\"\"\n    Statically parse the version number from a python file\n    \"\"\"\n    import ast\n    from os.path import exists\n    if not exists(fpath):\n        raise ValueError('fpath={!r} does not exist'.format(fpath))\n    with open(fpath, 'r') as file_:\n        sourcecode = file_.read()\n    pt = ast.parse(sourcecode)\n    class VersionVisitor(ast.NodeVisitor):\n        def visit_Assign(self, node):\n            for target in node.targets:\n                if getattr(target, 'id', None) == '__version__':\n                    self.version = node.value.s\n    visitor = VersionVisitor()\n    visitor.visit(pt)\n    return visitor.version\n\n\ndef parse_requirements(fname='requirements.txt', versions=False):\n    \"\"\"\n    Parse the package dependencies listed in a requirements file but strips\n    specific versioning information.\n\n    Args:\n        fname (str): path to requirements file\n        versions (bool | str, default=False):\n            If true include version specs.\n            If strict, then pin to the minimum version.\n\n    Returns:\n        List[str]: list of requirements items\n    \"\"\"\n    from os.path import exists, dirname, join\n    import re\n    require_fpath = fname\n\n    def parse_line(line, dpath=''):\n        \"\"\"\n        Parse information from a line in a requirements text file\n\n        line = 'git+https://a.com/somedep@sometag#egg=SomeDep'\n        line = '-e git+https://a.com/somedep@sometag#egg=SomeDep'\n        \"\"\"\n        # Remove inline comments\n        comment_pos = line.find(' #')\n        if comment_pos > -1:\n            line = line[:comment_pos]\n\n        if line.startswith('-r '):\n            # Allow specifying requirements in other files\n            target = join(dpath, line.split(' ')[1])\n            for info in parse_require_file(target):\n                yield info\n        else:\n            # See: https://www.python.org/dev/peps/pep-0508/\n            info = {'line': line}\n            if line.startswith('-e '):\n                info['package'] = line.split('#egg=')[1]\n            else:\n                if ';' in line:\n                    pkgpart, platpart = line.split(';')\n                    # Handle platform specific dependencies\n                    # setuptools.readthedocs.io/en/latest/setuptools.html\n                    # #declaring-platform-specific-dependencies\n                    plat_deps = platpart.strip()\n                    info['platform_deps'] = plat_deps\n                else:\n                    pkgpart = line\n                    platpart = None\n\n                # Remove versioning from the package\n                pat = '(' + '|'.join(['>=', '==', '>']) + ')'\n                parts = re.split(pat, pkgpart, maxsplit=1)\n                parts = [p.strip() for p in parts]\n\n                info['package'] = parts[0]\n                if len(parts) > 1:\n                    op, rest = parts[1:]\n                    version = rest  # NOQA\n                    info['version'] = (op, version)\n            yield info\n\n    def parse_require_file(fpath):\n        dpath = dirname(fpath)\n        with open(fpath, 'r') as f:\n            for line in f.readlines():\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    for info in parse_line(line, dpath=dpath):\n                        yield info\n\n    def gen_packages_items():\n        if exists(require_fpath):\n            for info in parse_require_file(require_fpath):\n                parts = [info['package']]\n                if versions and 'version' in info:\n                    if versions == 'strict':\n                        # In strict mode, we pin to the minimum version\n                        if info['version']:\n                            # Only replace the first >= instance\n                            verstr = ''.join(info['version']).replace('>=', '==', 1)\n                            parts.append(verstr)\n                    else:\n                        parts.extend(info['version'])\n                if not sys.version.startswith('3.4'):\n                    # apparently package_deps are broken in 3.4\n                    plat_deps = info.get('platform_deps')\n                    if plat_deps is not None:\n                        parts.append(';' + plat_deps)\n                item = ''.join(parts)\n                yield item\n\n    packages = list(gen_packages_items())\n    return packages\n\n\ndef parse_description():\n    \"\"\"\n    Parse the description in the README file\n    \"\"\"\n    from os.path import dirname, join, exists\n    readme_fpath = join(dirname(__file__), 'README.rst')\n    # This breaks on pip install, so check that it exists.\n    if exists(readme_fpath):\n        with open(readme_fpath, 'r') as f:\n            text = f.read()\n        return text\n    return ''\n\n\nVERSION = parse_version('src/python/pycold/__init__.py')  # needs to be a global var for git tags\n\nif __name__ == '__main__':\n\n    # References:\n    # https://stackoverflow.com/questions/19602582/pip-install-editable-links-to-wrong-path\n    packages = find_packages('./src/python')\n\n    setupkw = {}\n    setupkw[\"classifiers\"] = [\n        # List of classifiers available at:\n        # https://pypi.python.org/pypi?%3Aaction=list_classifiers\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Topic :: Utilities\",\n        # 'Operating System :: Microsoft :: Windows',  # TODO\n        # 'Operating System :: MacOS',  # TODO\n        'Operating System :: POSIX :: Linux',\n        'License :: OSI Approved :: Apache Software License',\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n    ]\n    setupkw['license'] = 'Apache 2',\n\n    setup(\n        package_dir={\n            '': 'src/python',\n        },\n        name='pycold',\n        url='https://github.com/GERSL/pycold',\n        version=VERSION,\n        description='python implementation of COntinuous monitoring of Land disturbances algorithm',\n        install_requires=parse_requirements('requirements/runtime.txt'),\n        long_description=parse_description(),\n        long_description_content_type='text/x-rst',\n        extras_require={\n            'all': parse_requirements('requirements.txt'),\n            'tests': parse_requirements('requirements/tests.txt'),\n            'build': parse_requirements('requirements/build.txt'),\n            'optional': parse_requirements('requirements/optional.txt'),\n            'headless': parse_requirements('requirements/headless.txt'),\n            'graphics': parse_requirements('requirements/graphics.txt'),\n        },\n        author='Su Ye',\n        author_email='remotesensingsuy@gmail.com',\n        packages=packages,\n        include_package_data=True,\n        package_data={\n            'pycold': [\n                'ob_parameters.yaml',\n                'constants.yaml',\n            ],\n            'pycold.imagetool': [\n                'config.yaml',\n                'singlepath_landsat_conus.tif',\n            ],\n        },\n        python_requires='>=3.8',\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=41.0.1\", \"scikit-build>=0.11.1\", \"numpy\", \"ninja>=1.10.2\", \"cmake>=3.21.2\", \"cython>=0.29.24\",]\n\n[tool.xcookie]\nurl = 'https://github.com/GERSL/pycold'\ntags = [ \"github\", \"binpy\", \"cv2\", \"gdal\"]\nmod_name = \"pycold\"\nrepo_name = \"pycold\"\nrel_mod_parent_dpath = \"src/python\"\nos = [ \"osx\", \"linux\", \"win\", \"all\"]\nmin_python = 3.8\nauthor = \"Su Ye\"\nenable_gpg = false\ndefaultbranch = \"devel\"\nauthor_email = \"remotesensingsuy@gmail.com\"\ndescription = \"python implementation of COntinuous monitoring of Land disturbances algorithm\"\ndev_status = \"alpha\"\nlicense = \"Apache 2\"\n\n\n[tool.cibuildwheel]\nbuild = \"cp38-* cp39-* cp310-*\"\n#build = \"cp310-manylinux_x86_64\"\nbuild-frontend = \"build\"\nskip = \"pp* *-musllinux_*\"\n#archs = [\"x86_64\"]\n#archs = [\"i686\"]\nbuild-verbosity = 1\ntest-requires = [\"-r requirements/tests.txt\", \"-r requirements/headless.txt\", \"-r requirements/gdal.txt\"]\ntest-command = \"python {project}/run_tests.py\"\n\n# Use custom manylinux images to get precompiled build-time deps\nmanylinux-x86_64-image = \"quay.io/erotemic/manylinux2014_x86_64_for:zlib-build-fortran-gsl\"\nmanylinux-i686-image = \"quay.io/erotemic/manylinux2014_i686_for:zlib-build-fortran-gsl\"\n\n#[tool.cibuildwheel.linux]\n# Uncomment to work with official manylinux images  \n#before-build = \"yum install gcc gcc-c++ make zlib-devel gcc-gfortran libgomp blas-devel -y && curl https://ftp.gnu.org/gnu/gsl/gsl-2.7.1.tar.gz  > gsl.tar.gz && tar xfv gsl.tar.gz && cd gsl-2.7.1 && ./configure --prefix=/usr --disable-static && make && make install\"\n#before-build = \"yum install libgomp blas-devel -y\"\n\n[tool.mypy]\nignore_missing_imports = true\n\n[tool.pytest.ini_options]\naddopts = \"-p no:doctest --xdoctest --xdoctest-style=google --ignore-glob=setup.py --ignore-glob=dev\"\nnorecursedirs = \".git ignore build __pycache__ dev _skbuild\"\nfilterwarnings = [\n    \"default\",\n    \"ignore:.*No cfgstr given in Cacher constructor or call.*:Warning\", \n    \"ignore:.*Define the __nice__ method for.*:Warning\", \"ignore:.*private pytest class or function.*:Warning\",\n]\n\n[tool.coverage.run]\nbranch = true\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n     \".*  # pragma: no cover\",\n     \".*  # nocover\", \n    \"def __repr__\",\n     \"raise AssertionError\",\n     \"raise NotImplementedError\",\n     \"if 0:\",\n     \"^ *raise\",\n     \"^ *pass *$\",\n     \"if __name__ == .__main__.:\",\n]\nomit = [\"*/setup.py\",]\n",
    "dev/mwe/setup.py": "\"\"\"\nThis is a script to build a MWE of a build issue I'm having getting\nscikit-build to properly install PyCold in development mode.\n\nUsage:\n    python setup.py mwe generate\n    pip install -e .\n    python setup.py mwe analyize\n    pip uninstall pkg_mwe\n\n    rm -rf _skbuild\n\n    python setup.py mwe generate with_cxx && pip install -e . --verbose && python -c \"from pkg_mwe.myalgo_cython import call_myalgo; print(call_myalgo())\"\n\n    python setup.py mwe analyize\n\n    python ~/code/pycold/dev/mwe/setup.py mwe analyize --mod_name=pycold --repo_dpath=$HOME/code/pycold\n\"\"\"\nimport sys\n\n\nclass ProjectStructure():\n    def __init__(self, repo_dpath='.', mod_name='pkg_mwe'):\n        import ubelt as ub\n        self.root = ub.Path(repo_dpath)\n        self.mod_name = mod_name\n        self.cxx_path    = (self.root / 'src' / 'cxx')\n        self.python_path = (self.root / 'src' / 'python')\n        self.mod_dpath = (self.python_path / self.mod_name)\n\n    def generate(self, with_cxx=0):\n        self.python_path.delete().ensuredir()\n        self.cxx_path.delete()\n        (self.root / 'CMakeLists.txt').delete()\n        self.mod_dpath.ensuredir()\n        (self.mod_dpath / '__init__.py').write_text('__version__ = \"1.0.0\"')\n\n        # Give the MWE a CXX extension\n        WITH_CXX = with_cxx\n        if WITH_CXX:\n            self.cxx_path.ensuredir()\n            import ubelt as ub\n\n            (self.root / 'CMakeLists.txt').write_text(ub.codeblock(\n                r'''\n                cmake_minimum_required(VERSION 3.13.0)\n                project(pkg_mwe LANGUAGES C Fortran)\n\n\n                find_package(PythonInterp REQUIRED)\n                find_package(PythonLibs REQUIRED)\n\n                ###\n                # Private helper function to execute `python -c \"<cmd>\"`\n                #\n                # Runs a python command and populates an outvar with the result of stdout.\n                # Be careful of indentation if `cmd` is multiline.\n                #\n                function(pycmd outvar cmd)\n                  execute_process(\n                    COMMAND \"${PYTHON_EXECUTABLE}\" -c \"${cmd}\"\n                    RESULT_VARIABLE _exitcode\n                    OUTPUT_VARIABLE _output)\n                  if(NOT ${_exitcode} EQUAL 0)\n                    message(ERROR \"Failed when running python code: \\\"\\\"\\\"\n                ${cmd}\\\"\\\"\\\"\")\n                    message(FATAL_ERROR \"Python command failed with error code: ${_exitcode}\")\n                  endif()\n                  # Remove supurflous newlines (artifacts of print)\n                  string(STRIP \"${_output}\" _output)\n                  set(${outvar} \"${_output}\" PARENT_SCOPE)\n                endfunction()\n\n                ###\n                # Find scikit-build and include its cmake resource scripts\n                #\n                if (NOT SKBUILD)\n                  pycmd(skbuild_location \"import os, skbuild; print(os.path.dirname(skbuild.__file__))\")\n                  set(skbuild_cmake_dir \"${skbuild_location}/resources/cmake\")\n                  # If skbuild is not the driver, then we need to include its utilities in our CMAKE_MODULE_PATH\n                  list(APPEND CMAKE_MODULE_PATH ${skbuild_cmake_dir})\n                endif()\n\n                find_package(PythonExtensions REQUIRED)\n                find_package(Cython REQUIRED)\n                find_package(NumPy REQUIRED)\n\n                # Backend C library\n                add_subdirectory(\"src/cxx\")\n\n                # Cython library\n                add_subdirectory(\"src/python/pkg_mwe\")\n                '''))\n\n            (self.cxx_path / 'myalgo.h').write_text(ub.codeblock(\n                '''\n                #ifndef MYALGO_H\n                #define MYALGO_H\n                int myalgo(long *arr1, long *arr2, size_t num);\n                #endif MYALGO_H\n                '''))\n            (self.cxx_path / 'myalgo.c').write_text(ub.codeblock(\n                r'''\n                #include <string.h>\n                long myalgo(long *arr1, long *arr2, size_t num)\n                {\n                    for (int i = 0 ; i < num ; i++ )\n                    {\n                        arr2[i] = arr1[i] + arr2[i];\n                    }\n                    return 1;\n                }\n                '''))\n            cmake_list_cxx = self.cxx_path / 'CMakeLists.txt'\n            cmake_list_cxx.write_text(ub.codeblock(\n                '''\n                set(MYALGO_MODULE_NAME \"myalgo\")\n                list(APPEND MYALGO_SOURCES \"myalgo.h\" \"myalgo.c\")\n                add_library(${MYALGO_MODULE_NAME} STATIC ${MYALGO_SOURCES})\n                '''))\n\n            (self.mod_dpath / 'myalgo_cython.pyx').write_text(ub.codeblock(\n                '''\n                import numpy as np\n                cimport numpy as np\n                cdef extern from \"../../cxx/myalgo.h\":\n                    cdef int myalgo(long *arr1, long *arr2, size_t num);\n\n                def call_myalgo():\n                    \"\"\"\n                    This is a docstring\n                    \"\"\"\n                    cdef int result;\n                    cdef np.ndarray[np.int64_t, ndim=1] arr1\n                    cdef np.ndarray[np.int64_t, ndim=1] arr2\n                    arr1 = np.array([1, 2, 3], dtype=np.int64)\n                    arr2 = np.array([4, 6, 9], dtype=np.int64)\n                    cdef long [:] arr1_view = arr1\n                    cdef long [:] arr2_view = arr2\n                    cdef size_t num = len(arr1)\n                    print(f'arr1={arr1}')\n                    print(f'arr2={arr2}')\n                    print('calling my algo')\n                    result = myalgo(&arr1_view[0], &arr2_view[0], num)\n                    print(f'arr1={arr1}')\n                    print(f'arr2={arr2}')\n                    return result\n                '''))\n\n            (self.mod_dpath / 'CMakeLists.txt').write_text(ub.codeblock(\n                '''\n                set(cython_source \"myalgo_cython.pyx\")\n                set(PYMYALGO_MODULE_NAME \"myalgo_cython\")\n\n                # Translate Cython into C/C++\n                add_cython_target(${PYMYALGO_MODULE_NAME} \"${cython_source}\" C OUTPUT_VAR sources)\n\n                # Add other C sources\n                list(APPEND sources )\n\n                # Create C++ library. Specify include dirs and link libs as normal\n                add_library(${PYMYALGO_MODULE_NAME} MODULE ${sources})\n                target_include_directories(\n                    ${PYMYALGO_MODULE_NAME}\n                    PUBLIC\n                    ${NumPy_INCLUDE_DIRS}\n                    ${PYTHON_INCLUDE_DIR}\n                    ${CMAKE_CURRENT_SOURCE_DIR}\n                )\n\n                # TODO: not sure why this isn't set in the global scope?\n                # Hack around it: just hard code the module name\n                set(MYALGO_MODULE_NAME \"myalgo\")\n\n                # TODO: linking to the MYALGO shared object isn't working 100% yet.\n                target_link_libraries(${PYMYALGO_MODULE_NAME} ${MYALGO_MODULE_NAME})\n\n                target_compile_definitions(${PYMYALGO_MODULE_NAME} PUBLIC\n                    \"NPY_NO_DEPRECATED_API\"\n                    #\"NPY_1_7_API_VERSION=0x00000007\"\n                )\n\n                # Transform the C++ library into an importable python module\n                python_extension_module(${PYMYALGO_MODULE_NAME})\n\n                # Install the C++ module to the correct relative location\n                # (this will be an inplace build if you use `pip install -e`)\n                #file(RELATIVE_PATH pymyalgo_install_dest \"${CMAKE_SOURCE_DIR}\" \"${CMAKE_CURRENT_SOURCE_DIR}\")\n\n                # My \"normal\" method of setting install targets does not seem to work here. Hacking it.\n                # NOTE: skbuild *seems* to place libraries in a data dir *unless* the install destination\n                # corresponds exactly to the <package_dir>/<package_name> specified implicitly in setup.py\n                set(pymyalgo_install_dest \"src/python/pkg_mwe\")\n                #install(TARGETS ${MYALGO_MODULE_NAME} LIBRARY DESTINATION \"${pymyalgo_install_dest}\")\n                install(TARGETS ${PYMYALGO_MODULE_NAME} LIBRARY DESTINATION \"${pymyalgo_install_dest}\")\n                '''\n            ))\n\n    def analyize(self):\n        from rich.console import Console\n        from rich.panel import Panel\n        from rich.syntax import Syntax\n        from rich.table import Table\n        import distutils.sysconfig\n        import ubelt as ub\n        import xdev\n\n        console = Console()\n\n        def rich_file_content(fpath, lexer='bash'):\n            import os\n            text = fpath.read_text()\n            return Panel(Syntax(text, lexer), title=os.fspath(fpath))\n\n        def print_egg_path_content(egg_info_dpath, color='blue'):\n            blocklist = {'requires.txt'}\n            fpaths = egg_info_dpath.ls()\n            table = Table(f'[{color}]' + str(egg_info_dpath))\n            for fpath in fpaths:\n                if fpath.name not in blocklist:\n                    panel = rich_file_content(fpath)\n                    table.add_row(panel)\n            console.print(table)\n\n        print('\\n')\n        print('Repo Structure:')\n        directory_blocklist = ['.*', '.git', 'dist', '_skbuild', 'dev']\n        xdev.tree_repr(self.root, max_files=None, dirblocklist=directory_blocklist)\n\n        print('\\n')\n        print('Content of the EGG Link:')\n        site_dpath = ub.Path(distutils.sysconfig.get_python_lib())\n        egg_link_fpaths = list(site_dpath.glob(self.mod_name.replace('_', '*') + '*.egg-link'))\n        assert len(egg_link_fpaths) == 1\n        egg_link_fpath = egg_link_fpaths[0]\n        console.print(rich_file_content(egg_link_fpath))\n\n        # Note: (recently 2022-08-ish) python switched to a new type of\n        # This is not present in setuptools==63.2.0 but is in 65.3.0\n        # editable install. TODO: incomporate this.\n        # editable_fpaths = list(site_dpath.glob('__editable__*' + self.mod_name.replace('_', '*') + '*'))\n\n        print('\\n')\n        print('Check easy-install.pth')\n        easy_install_fpath = site_dpath / 'easy-install.pth'\n        assert easy_install_fpath.exists()\n        easy_install_text = easy_install_fpath.read_text()\n        abs_path = self.mod_dpath.absolute().parent\n        print(f'abs_path={abs_path}')\n        if str(abs_path)  in easy_install_text:\n            console.print('[green] Easy install dpath is good')\n        else:\n            console.print('[red] Easy install dpath is bad')\n            console.print(rich_file_content(easy_install_fpath))\n\n        expected_egg_info_dpath = self.root / f'src/python/{self.mod_name}.egg-info'\n        all_egg_infos = [ub.Path(e).resolve() for e in xdev.find('*.egg-info', dirblocklist=directory_blocklist)]\n        other_egg_infos = set(all_egg_infos) - {expected_egg_info_dpath.resolve()}\n        print('expected_egg_info_dpath = {}'.format(ub.repr2(expected_egg_info_dpath, nl=1)))\n        if expected_egg_info_dpath.exists():\n            console.print('[green] Egg info exists in expected location')\n            egg_info_dpath = expected_egg_info_dpath\n            print_egg_path_content(egg_info_dpath, color='green')\n        else:\n            console.print('[red] Egg info exists in expected location')\n            print(f'other_egg_infos={other_egg_infos}')\n\n        if other_egg_infos:\n            console.print('[red] THERE ARE UNEXEPCTED EGG INFOS')\n            for egg_info_dpath in other_egg_infos:\n                print_egg_path_content(egg_info_dpath, color='red')\n\n        print('\\n')\n        print('Test to ensure we can import the module')\n        command = f'python -c \"import {self.mod_name}; print({self.mod_name})\"'\n        info = ub.cmd(command, verbose=3)\n        if info['ret'] != 0:\n            raise Exception('failed to import')\n        assert str(self.mod_dpath) in info['out']\n\n\ndef mwe_cli():\n    import scriptconfig as scfg\n    class AnalyizeConfig(scfg.DataConfig):\n        mod_name = 'pkg_mwe'\n        repo_dpath = '.'\n    config = AnalyizeConfig.cli()\n    self = ProjectStructure(**config)\n    if 'generate' in sys.argv:\n        self.generate(with_cxx='with_cxx' in sys.argv)\n    if 'analyize' in sys.argv:\n        self.analyize()\n\n\nif __name__ == '__main__':\n    if 'mwe' in sys.argv:\n        mwe_cli()\n        sys.exit(0)\n\n    import os\n    DISABLE_C_EXTENSIONS = os.environ.get('DISABLE_C_EXTENSIONS', '')\n    if DISABLE_C_EXTENSIONS == '1':\n        from setuptools import setup\n    else:\n        from skbuild import setup\n    from setuptools import find_packages\n\n    packages = find_packages('./src/python')\n    setup(\n        package_dir={\n            '': 'src/python',\n        },\n        install_requires=['packaging', 'ubelt'],\n        name='pkg_mwe',\n        version=\"1.0.0\",\n        description='MWE of build issue',\n        packages=packages,\n        include_package_data=True,\n    )\n"
  },
  "dlech/bleak-winrt": {
    "setup.py": "from setuptools import find_namespace_packages\n\nfrom skbuild import setup\n\nwith open(\"README.md\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"bleak-winrt\",\n    version = \"1.2.0\",\n    description=\"Python WinRT bindings for Bleak\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    license=\"MIT\",\n    author='Microsoft Corporation',\n    url=\"https://github.com/dlech/bleak-winrt\",\n    classifiers=[\n            'Development Status :: 4 - Beta',\n            'Environment :: Win32 (MS Windows)',\n            'License :: OSI Approved :: MIT License',\n            'Operating System :: Microsoft :: Windows :: Windows 10',\n            'Programming Language :: Python :: 3.7',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: Implementation :: CPython',\n            'Topic :: System :: Operating System',\n        ],\n    packages=find_namespace_packages(where=(\"pywinrt\")),\n    package_dir={\"\": \"pywinrt\"}, \n    cmake_args=['-DCMAKE_BUILD_TYPE=Release', '-DCMAKE_C_COMPILER=cl', '-DCMAKE_CXX_COMPILER=cl'],\n    # recursive glob (**) doesn't seem to work here\n    package_data={\"bleak_winrt\": [\"py.typed\", \"*.pyi\", \"*/*.pyi\", \"*/*/*.pyi\", \"*/*/*/*.pyi\", \"*/*/*/*/*.pyi\"]},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "InsightSoftwareConsortium/ITKBoneMorphometry": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-bonemorphometry',\n    version='1.4.0',\n    author='Jean-Baptiste Vimort',\n    author_email='jb.vimort@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKBoneMorphometry',\n    description=r'An ITK module to compute bone morphometry features and feature maps',\n    long_description='ITKBoneMorphometry provides bone analysis filters that '\n                     'compute features from N-dimensional images that '\n                     'represent the internal architecture of bone.\\n'\n                     'Please refer to:'\n                     'Vimort J., McCormick M., Paniagua B.,'\n                     '\u201cComputing Bone Morphometric Feature Maps from 3-Dimensional Images\u201d, '\n                     'Insight Journal, January-December 2017, https://hdl.handle.net/10380/3588.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit bones morphometry',\n    url=r'https://github.com/InsightSoftwareConsortium/ITKBoneMorphometry',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "InsightSoftwareConsortium/ITKIOOMEZarrNGFF": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-ioomezarrngff',\n    version='0.1.2',\n    author='Insight Software Consortium',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKIOOMEZarrNGFF',\n    description=r'IO for images stored in zarr format.',\n    long_description='ITK remote module for IO of images stored in zarr file format.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "RUrlus/ModelMetricUncertainty": {
    "setup.py": "\"\"\"Project: ModelMetricUncertainty\n\nCreated: 2021/09/24\n\nDescription:\n    setup script to install ModelMetricUncertainty package.\n\nAuthors:\n    Ralph Urlus [rurlus.dev@gmail.com]\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted according to the terms listed in the file\nLICENSE.\n\"\"\"\n\nimport sys\nimport pybind11\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n# NOTE: also update:\n# CMakeLists.txt\n# docs/source/conf.py\n\nMAJOR = 0\nREVISION = 1\nPATCH = 2\n# dev should be the dev version number (typically 0) or None if not dev version\nDEV = None\n# rc should be the release candidate version (typically 0) or None if not rc\nRC = None\n\nFULL_VERSION = VERSION = f\"{MAJOR}.{REVISION}.{PATCH}\"\nIS_RELEASE = False\nif DEV is not None:\n    FULL_VERSION += f\".dev{int(DEV)}\"\nelif RC is not None:\n    FULL_VERSION += f\".rc{int(RC)}\"\nelse:\n    IS_RELEASE = True\n\n\ndef write_version_py(filename: str = \"mmu/version.py\") -> None:\n    \"\"\"Write package version to version.py.\n\n    This will ensure that the version in version.py is in sync with us.\n\n    Parameters\n    ----------\n    filename : str\n        the path the file to write the version.py\n\n    \"\"\"\n    # Do not modify the indentation of version_str!\n    version_str = (\n        '\"\"\"THIS FILE IS AUTO-GENERATED BY ModelMetricUncertainty SETUP.PY.\"\"\"\\n\\n'\n        \"name = 'mmu'\\n\"\n        f\"version = '{VERSION}'\\n\"\n        f\"full_version = '{FULL_VERSION}'\\n\"\n        f\"release = {IS_RELEASE}\"\n    )\n    with open(filename, \"w\") as version_file:\n        version_file.write(version_str)\n\n\nif __name__ == \"__main__\":\n    write_version_py()\n    cmake_args = [\n        f\"-DMMU_VERSION_INFO:STRING={VERSION}\",\n        f\"-DPython3_EXECUTABLE:STRING={sys.executable}\",\n        f\"-Dpybind11_DIR:STRING={pybind11.get_cmake_dir()}\",\n        \"-DMMU_ENABLE_ARCH_FLAGS:BOOL=ON\",\n    ]\n    if DEV is not None:\n        cmake_args += [\n            \"-DMMU_DEV_MODE=ON\",\n            \"-DMMU_ENABLE_INTERNAL_TESTS=ON\",\n            \"-DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=ON\",\n        ]\n\n    setup(\n        name=\"mmu\",\n        packages=find_packages(),\n        version=FULL_VERSION,\n        cmake_args=cmake_args,\n    )\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"wheel\",\n    \"scikit-build>=0.14.1\",\n    \"ninja; platform_system!='Windows'\",\n    \"cmake>=3.16\",\n    \"numpy>=1.18\",\n    \"pybind11>=2.8.1\",\n]\nbuild-backend = \"setuptools.build_meta\"\n",
    "setup.cfg": "[metadata]\nname = mmu\ndescription = Compute uncertainties on classification model metrics.\nlong_description = file: README.rst\nlong_description_content_type = text/x-rst\nauthor = Ralph Urlus\nauthor_email = rurlus.dev@gmail.com\nlicense = Apache-2\nplatforms = any\nurl = https://github.com/RUrlus/ModelMetricUncertainty\nproject_urls =\n    Source  = https://github.com/RUrlus/ModelMetricUncertainty\n    Tracker = https://github.com/RUrlus/ModelMetricUncertainty/issues\nkeywords = uncertainty classification metrics\nclassifiers =\n\n[options]\nzip_safe = False\npython_requires = >=3.7\ninstall_requires =\n    numpy>=1.18\n    scipy>=1.5.2\n    pandas>=0.25.1\n    matplotlib>=2.2.3\n    scikit-learn>=1.0\n\n[options.extras_require]\ntest =\n    pytest\nall =\n    %(test)s\n\n[tool:pytest]\naddopts = -rsxX -v\ntestpaths = tests\n"
  },
  "lukasberbuer/rt-vamp-plugin-sdk": {
    "setup.py": "from pathlib import Path\nfrom setuptools import find_packages\nfrom subprocess import run\nfrom tempfile import TemporaryDirectory\n\nfrom skbuild import setup\n\nHERE = Path(__file__).parent\n\nLONG_DESCRIPTION = (HERE / \"python\" / \"README.md\").read_text(encoding=\"utf-8\")\n\nINSTALL_REQUIRES = [\n    \"numpy\",\n    \"dataclasses>=0.6; python_version<'3.7'\",\n]\n\nEXTRAS_REQUIRE = {\n    \"docs\": [\n        \"sphinx>=5\",\n        \"sphinx-gallery\",\n        \"myst-parser\",\n        \"furo\",\n        # for examples\n        \"librosa\",\n        \"matplotlib\",\n    ],\n    \"tests\": [\n        \"pytest>=6\",  # pyproject.toml support\n    ],\n    \"tools\": [\n        \"black\",\n        \"isort\",\n        \"mypy>=0.9\",  # pyproject.toml support\n        \"pylint>=2.5\",  # pyproject.toml support\n        \"tox>=3.4\",  # pyproject.toml support\n    ],\n}\n\nEXTRAS_REQUIRE[\"dev\"] = EXTRAS_REQUIRE[\"docs\"] + EXTRAS_REQUIRE[\"tests\"] + EXTRAS_REQUIRE[\"tools\"]\n\n\ndef get_variable_from_cmake(variable: str) -> str:\n    \"\"\"Read CMake variables from temporary generated CMakeCache.txt.\"\"\"\n    try:\n        with TemporaryDirectory() as tempdir:\n            run([\"cmake\", \"-S\", str(HERE), \"-B\", tempdir], check=True)\n            with open(Path(tempdir) / \"CMakeCache.txt\", encoding=\"utf-8\") as f:\n                for line in f:\n                    if line.startswith(f\"{variable}:\"):\n                        *_, version = line.strip().partition(\"=\")\n                        return version\n            raise RuntimeError(f\"{variable} not found in CMakeCache.txt\")\n    except Exception as e:\n        raise RuntimeError(f\"Could not fetch variable from CMake: {e}\") from e\n\n\nsetup(\n    name=\"rtvamp\",\n    version=get_variable_from_cmake(\"CMAKE_PROJECT_VERSION\"),\n    description=\"Vamp plugin host for real-time audio feature analysis\",\n    long_description=LONG_DESCRIPTION,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/lukasberbuer/rt-vamp-plugin-sdk\",\n    author=\"Lukas Berbuer\",\n    author_email=\"lukas.berbuer@gmail.com\",\n    license=\"MIT\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Multimedia :: Sound/Audio\",\n        \"Topic :: Multimedia :: Sound/Audio :: Analysis\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Operating System :: OS Independent\",\n    ],\n    keywords=[\n        \"Vamp\",\n        \"plugin\",\n        \"audio\",\n        \"sound\",\n        \"music\",\n        \"analysis\",\n        \"feature extraction\",\n        \"real-time\",\n    ],\n    packages=find_packages(where=\"python/src\"),\n    package_dir={\"\": \"python/src\"},\n    python_requires=\">=3.6\",\n    install_requires=INSTALL_REQUIRES,\n    extras_require=EXTRAS_REQUIRE,\n    cmake_args=[\n        \"-DRTVAMP_BUILD_EXAMPLES=ON\",  # to test with example plugins\n        \"-DRTVAMP_BUILD_PYTHON_BINDINGS=ON\",\n        \"-DRTVAMP_VALIDATE=ON\",\n    ],\n    cmake_install_dir=\"python/src/rtvamp\",\n    include_package_data=False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"pybind11~=2.10\",\n    \"cmake>=3.22\",\n    \"scikit-build>=0.15.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.black]\nline-length = 100\n\n[tool.isort]\nline_length = 100\nmulti_line_output = 3\ninclude_trailing_comma = true\nuse_parentheses = true\n\n[tool.mypy]\nignore_missing_imports = true\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\naddopts = \"-ra -v\"\ntestpaths = [\"python/tests\"]\n"
  },
  "nasa/upsp-processing": {
    "setup.py": "from skbuild import setup\nfrom setuptools import find_packages\n\nsetup(\n    packages=find_packages(where=\"python\"),\n    package_dir={\"\": \"python\"},\n    include_package_data=True,\n    package_data={\"upsp.processing\": [\"templates/*.template\"]},\n)\n",
    "pyproject.toml": "[project]\nname = \"upsp\"\ndescription = \"NASA uPSP data processing applications and utilities\"\nauthors = [{name = \"NASA uPSP developers\"}]\nlicense = {file = \"LICENSE.txt\"}\ndynamic = [\"version\"]\ndependencies = [\n    \"matplotlib\",\n    \"numpy\",\n    \"opencv-python-headless==4.5.2.54\",\n    \"pandas\",\n    \"scipy\",\n]\n\n[build-system]\nrequires = [\n    \"setuptools>=61\",\n    \"setuptools_scm[toml]>=6.2\",\n    \"pybind11\",\n    \"cmake>=3.22\",\n    \"scikit-build>=0.15.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\"\n\n[tool.setuptools_scm]\nwrite_to = \"python/upsp/_version.py\"\n"
  },
  "barbagroup/geoclaw-landspill": {
    "setup.py": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \u00a9 2018-2021 Pi-Yueh Chuang and Lorena A. Barba.\n#\n# Distributed under terms of the BSD 3-Clause license.\n\n\"\"\"Build geoclaw-landspull package as a Python package.\n\"\"\"\nimport re\nimport pathlib\nimport skbuild\n\n# the absolute path to the root directory\nrootdir = pathlib.Path(__file__).resolve().parent\n\n# basic package information\nmeta = dict(\n    name=\"geoclaw-landspill\",\n    author=\"Pi-Yueh Chuang\",\n    author_email=\"pychuang@gwu.edu\",\n    url=\"https://github.com/barbagroup/geoclaw-landspill\",\n    keywords=[\"landspill\", \"overland flow\", \"pipeline\", \"geoclaw\", \"clawpack\"],\n    license=\"BSD 3-Clause License\",\n)\n\n# classifiers for categorizing; see https://pypi.org/classifiers/\nmeta[\"classifiers\"] = [\n    \"Development Status :: 1 - Planning\",\n    \"Environment :: Console\",\n    \"Intended Audience :: Science/Research\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Operating System :: Unix\",\n    \"Programming Language :: Fortran\",\n    \"Programming Language :: Python :: 3\",\n    \"Topic :: Scientific/Engineering\"\n]\n\n# license files\nmeta[\"license_files\"] = [\n    \"LICENSE\",\n    \"third-party/amrclaw/LICENSE\",\n    \"third-party/geoclaw/LICENSE\",\n    \"third-party/pyclaw/LICENSE\",\n    \"third-party/clawutil/LICENSE\"\n]\n\n# version and short sescription (read from __init__.py)\nwith open(rootdir.joinpath(\"gclandspill\", \"__init__.py\"), 'r') as fileobj:\n    content = fileobj.read()\n    # version\n    meta[\"version\"] = re.search(\n        r\"__version__\\s*?=\\s*?(?P<version>\\S+?)$\", content, re.MULTILINE\n    ).group(\"version\").strip(\"\\\"\\'\")\n    # one line description\n    meta[\"description\"] = re.search(\n        r\"^\\\"\\\"\\\"(?P<desc>\\S.*?)$\", content, re.MULTILINE\n    ).group(\"desc\")\n\n# long  description (read from README.md)\nwith open(rootdir.joinpath(\"README.md\"), 'r') as fileobj:\n    meta[\"long_description\"] = fileobj.read()\n    meta[\"long_description_content_type\"] = \"text/markdown\"\n\n# dependencies\nwith open(rootdir.joinpath(\"requirements.txt\"), \"r\") as fileobj:\n    deps = fileobj.readlines()\n    meta[\"python_requires\"] = \">=3.7\"\n    meta[\"install_requires\"] = [line.strip() for line in deps]\n\n# packages to be installed\nmeta[\"packages\"] = [\"gclandspill\"]\nmeta[\"package_dir\"] = {\"gclandspill\": \"gclandspill\"}\n\n# executable\nmeta[\"entry_points\"] = {\"console_scripts\": [\"geoclaw-landspill = gclandspill.__main__:main\"]}\n\n# scikit-build specific\nmeta[\"cmake_with_sdist\"] = False\nmeta[\"cmake_languages\"] = [\"Fortran\"]\nmeta[\"cmake_minimum_required_version\"] = \"3.14\"\n\nif __name__ == \"__main__\":\n    skbuild.setup(**meta)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=51.0\", \"wheel>=0.36\", \"scikit-build>=0.11.1\", \"cmake>=3.18.4\", \"ninja>=1.10\"]\n"
  },
  "nikitinvv/lprec": {
    "setup.py": "\"\"\"This is the main entry point for building lrpec.\nThe setup process for ptychocg is very much like any python module except\nthat the compilation of the the extension module(s) is driven by CMake through\nscikit-build. Scikit-build defines a custom Extension class which calls CMake\nand provides some common (for Python) CMake package finders.\nYou can pass build options to CMake using the normal -DBUILD_OPTION=something\nsyntax, but these options must separated from the setuptools options with two\ndashes (--). For example, we can pass the EXTENSION_WRAPPER option as follows:\n$ python setup.py build -- -DEXTENSION_WRAPPER=swig\nFor skbuild >= 0.10.0, the two dashes will not be required. See the top-level\nCMakeLists.txt for the curent list of build options.\n\"\"\"\nfrom skbuild import setup\nfrom setuptools import find_packages\n\nsetup(\n    name='lprec',\n    author='Viktor Nikitin',\n    version='0.3.0',\n    package_dir={\"\": \"src\"},\n    packages=find_packages('src'),\n    zip_safe=False,\n)"
  },
  "nv-legate/legate.sparse": {
    "setup.py": "#!/usr/bin/env python3\n\n# Copyright 2021-2022 NVIDIA Corporation\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\nfrom setuptools import find_packages\nfrom skbuild import setup\n\nimport versioneer\n\nsetup(\n    name=\"legate_sparse\",\n    version=versioneer.get_version(),\n    description=\"An Aspiring Drop-In Replacement for Scipy.Sparse at Scale\",\n    url=\"https://github.com/nv-legate/legate-sparse\",\n    author=\"NVIDIA Corporation\",\n    license=\"Apache 2.0\",\n    classifiers=[\n        \"Intended Audience :: Developers\",\n        \"Topic :: Database\",\n        \"Topic :: Scientific/Engineering\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n    ],\n    packages=find_packages(\n        where=\".\",\n        include=[\"sparse*\"],\n    ),\n    include_package_data=True,\n    cmdclass=versioneer.get_cmdclass(),\n    install_requires=[\"numpy>=1.22\"],\n    zip_safe=False,\n)\n",
    "pyproject.toml": "# Copyright (c) 2022, NVIDIA CORPORATION.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n[build-system]\nrequires = [\n    \"wheel\",\n    \"ninja\",\n    \"setuptools\",\n    \"scikit-build>=0.13.1\",\n    \"cmake>=3.22.1,!=3.23.0\",\n]\n\n[tool.pytest.ini_options]\naddopts = \"--capture=sys\"\n\n\n[tool.black]\nline-length = 79\ntarget-version = [\"py36\"]\ninclude = '\\.py?$'\nexclude = '''\n/(\n    \\.eggs |\n    \\.git |\n    \\.mypy_cache |\n    \\.tox |\n    \\.venv |\n    _build |\n    buck-out |\n    build |\n    dist\n)/\n'''\n",
    "setup.cfg": "# Copyright (c) 2021-2022, NVIDIA CORPORATION.\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = sparse/_version.py\nversionfile_build = sparse/_version.py\ntag_prefix = v\nparentdir_prefix = legate-sparse-\n\n[flake8]\nexclude = __init__.py\nignore =\n    # line break before binary operator\n    W503\n    # whitespace before :\n    E203\n    # undefined, or defined from star imports\n    F405\n\n[isort]\nline_length=79\nmulti_line_output=3\ninclude_trailing_comma=True\nforce_grid_wrap=0\ncombine_as_imports=True\norder_by_type=True\nknown_third_party=\n    numpy\nknown_legion=\n    legion_cffi\n    legion_top\nknown_first_party=\n    sparse\ndefault_section=THIRDPARTY\nsections=FUTURE,STDLIB,THIRDPARTY,LEGION,FIRSTPARTY,LOCALFOLDER\nskip=\n    .eggs\n    .git\n    .mypy_cache\n    .tox\n    .venv\n    _build\n    build\n    dist\n    legion\n    __init__.py\n\n[options]\npackages = find:\ninstall_requires =\n    numpy>=1.22\n    # TODO: Add rest of install dependencies\npython_requires = >=3.8\n"
  },
  "MDAnalysis/distopia": {
    "setup.py": "\nfrom skbuild import setup\nimport versioneer\nimport os\n\ndescription = \"Fast distance calculations using explicitly vectorised SIMD\"\ntry:\n    readme_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"README.md\")\n    with open(readme_file) as f:\n        long_description = f.read()\nexcept ImportError:\n    long_description = description\n\nsetup(\n    name=\"distopia\",\n    version=versioneer.get_version(),\n    cmdclass=versioneer.get_cmdclass(),\n    long_description_content_type = \"text/markdown\",\n    description=description,\n    long_description=long_description,\n    author=['Hugo MacDermott-Opeskin', \"Richard Gowers\"],\n    license=\"MIT\",\n    packages=['distopia'],\n    python_requires=\">=3.8\",\n    keywords=(\n        \"molecular dynamics distances simulation SIMD\"\n    ),\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Cython\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        'Topic :: Scientific/Engineering',\n        'Topic :: Scientific/Engineering :: Bio-Informatics',\n        'Topic :: Scientific/Engineering :: Chemistry',\n    ],\n    url=\"https://github.com/MDAnalysis/distopia\",\n    download_url=\"https://pypi.org/project/distopia/\",\n    project_urls={\n        \"Homepage\": \"https://github.com/MDAnalysis/distopia\",\n        \"Documentation\": \"https://www.mdanalysis.org/distopia/\",\n        \"Source Code\": \"https://github.com/MDAnalysis/distopia\",\n        \"Issue Tracker\": \"https://github.com/MDAnalysis/distopia/issues\",\n    },\n    install_requires=[\n        \"numpy>=1.20.0\"\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools>=42\",\n  \"wheel\",\n  # declaring numpy versions specifically to x86_64\n  # lowest NumPy we can use for a given Python,\n  # except for more exotic platform (Mac Arm flavors)\n  # Also don't allow PyPy builds\n  \"numpy==1.20.0; python_version=='3.8' and platform_machine=='x86_64' and platform_python_implementation != 'PyPy'\",\n  \"numpy==1.20.0; python_version=='3.9' and platform_machine=='x86_64' and platform_python_implementation != 'PyPy'\",\n  # As per https://github.com/scipy/oldest-supported-numpy/blob/main/setup.cfg\n  # safest to build at 1.21.6 for all platforms\n  \"numpy==1.21.6; python_version=='3.10' and platform_machine=='x86_64' and platform_python_implementation != 'PyPy'\",\n  \"numpy==1.23.2; python_version=='3.11' and platform_machine=='x86_64' and platform_python_implementation != 'PyPy'\",\n  # default to just numpy for unknown versions of Python\n  \"numpy; python_version>='3.12'\",\n  \"scikit-build\",\n  \"cmake\",\n  \"cython>=0.28,<3.0\",\n  \"versioneer[toml]==0.26\",\n  \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.versioneer]\nVCS = \"git\"\nstyle = \"pep440\"\nversionfile_source = \"distopia/_version.py\"\nversionfile_build = \"distopia/_version.py\"\ntag_prefix = \"\"\nparentdir_prefix = \"distopia-\"\n",
    "setup.cfg": "[options]\n# cross compilation for dispatch is the default\n# comment this out to enable other command line cmake flags to be specified\ndispatch = True\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = distopia/_version.py\nversionfile_build = distopia/_version.py\ntag_prefix = \"\"\nparentdir_prefix = distopia\n"
  },
  "VowpalWabbit/py-vowpal-wabbit-next": {
    "setup.py": "import sys\nimport pathlib\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\n\nwith open(pathlib.Path(__file__).parent.resolve() / \"README.md\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nwith open(pathlib.Path(__file__).parent.resolve() / \"version.txt\", \"r\", encoding=\"utf-8\") as version_file:\n    version = version_file.read().strip()\n\n\nsetup(\n    name=\"vowpal-wabbit-next\",\n    version=version,\n    description=\"Experimental python bindings for VowpalWabbit\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    author=\"VowpalWabbit\",\n    license=\"BSD-3-Clause\",\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    package_data={\"vowpal_wabbit_next\": [\"py.typed\", \"_core.pyi\"]},\n    cmake_install_dir=\"src/vowpal_wabbit_next\",\n    install_requires=[\"numpy\", \"typing_extensions; python_version=='3.7'\", ],\n    python_requires=\">=3.7\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"ninja\",\n    \"cmake>=3.12\",\n    \"scikit-build>=0.15.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\"\n\n[tool.black]\nextend-exclude = \"_core.pyi\"\n\n[tool.cibuildwheel]\ntest-requires = \"pytest\"\ntest-command = \"pytest {project}/tests\"\ntest-extras = [\"test\"]\ntest-skip = [\"*-macosx_arm64\"]\n# Skip 32-bit builds and musl\nskip = [\"*-win32\", \"*_i686\", \"*-musllinux_*\"]\nbuild-verbosity = 3\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\ntestpaths = [\"tests\"]\n\n[tool.mypy]\nfiles = \"src/**/*.py\"\npython_version = \"3.8\"\nstrict = true\nshow_error_codes = true\nenable_error_code = [\"ignore-without-code\", \"redundant-expr\", \"truthy-bool\"]\nwarn_unreachable = true\n\n[[tool.mypy.overrides]]\nmodule = \"vowpal_wabbit_next._core\"\nignore_errors = true\n\n[tool.pydocstyle]\nconvention = \"google\"\n# Choosing to ignore module level docs, class level docs (document __init__\n# instead), magic functions (__enter__), ignore blank line requirement between\n# summary and content\n# D107 has to be skipped since there is a false positive when using @overload\n# https://github.com/PyCQA/pydocstyle/issues/525\nadd_ignore = \"D100,D101,D104,D105,D107,D205\"\n"
  },
  "uuosio/UUOSKit": {
    "setup.py": "from skbuild import setup\nfrom distutils.sysconfig import get_python_lib\nimport glob\n\nsetup(\n    name=\"uuoskit\",\n    version=\"1.0.4\",\n    description=\"Python Toolkit for EOSIO\",\n    author='The UUOSIO Team',\n    license=\"MIT\",\n    url=\"https://github.com/uuosio/uuoskit\",\n    packages=['uuoskit'],\n    # The extra '/' was *only* added to check that scikit-build can handle it.\n    package_dir={'uuoskit': 'pysrc'},\n    package_data={'uuoskit': [\n        'data/*',\n        'contracts/eosio.bios/*',\n        'contracts/eosio.msig/*',\n        'contracts/eosio.system/*',\n        'contracts/eosio.token/*',\n        'contracts/eosio.wrap/*',\n        'contracts/micropython/*',\n        'test_template.py',\n        ]\n    },\n\n    install_requires=[\n        'urllib3>=1.21.1',\n        'certifi>=2021.10.8',\n        'toolz>=0.11.1',\n        'funcy>=1.16',\n        'prettytable>=2.2.1',\n        'requests_unixsocket>=0.2.0',\n        'httpx>=0.19.0'\n    ],\n    include_package_data=True\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n\n",
    "setup.cfg": "[metadata]\nlong_description = file:README.md\nlong_description_content_type = text/markdown\n"
  },
  "BRGM/ComPASS": {
    "setup.py": "# dirty workaround around sysconfig.get_platform bug on MacOSX\nimport os\nimport sysconfig\n\nplatform_tag = sysconfig.get_platform()\nif platform_tag.startswith(\"macosx\"):\n    assert all(platform_tag.split(\"-\")), \"Cannot use platform information!\"\n    os.environ[\"_PYTHON_HOST_PLATFORM\"] = platform_tag\n\n# Generate info about package compilation\nimport setuptools_scm as scm\nfrom pathlib import Path\nimport platform\nfrom datetime import datetime\n\npackage_name = \"ComPASS\"\nbuild_info_file = \"version_info\"\n\nwith Path(f\"./{package_name}/{build_info_file}\").open(\"w\") as f:\n    print(\n        f\"{package_name} {scm.get_version()}\",\n        file=f,\n    )\n    print(f\"built {datetime.now().isoformat()}\", file=f)\n    print(f\"with python {platform.python_version()} on {platform.node()}\", file=f)\n    print(f\"build system info: {platform.platform()}\", file=f)\n\n# Clean local physics directory (!_ is to keep __init__.py)\nfor f in Path(f\"{package_name}/physics\").glob(\"[!_]*\"):\n    f.unlink()\n\nfrom skbuild import setup\n\nsetup(\n    packages=[\n        package_name,\n        f\"{package_name}.physics\",\n        f\"{package_name}.ghosts\",\n        f\"{package_name}.io\",\n        f\"{package_name}.linalg\",\n        f\"{package_name}.petrophysics\",\n        f\"{package_name}.petrophysics.models\",\n        f\"{package_name}.properties\",\n        f\"{package_name}.properties.water2ph\",\n        f\"{package_name}.schemes\",\n        f\"{package_name}.simulation\",\n        f\"{package_name}.utils\",\n        f\"{package_name}.wells\",\n    ],\n    package_data={\n        package_name: [build_info_file],\n    },\n)\n",
    "pyproject.toml": "[build-system]\r\nrequires = [\"scikit-build\", \"numpy\", \"wheel\", \"setuptools>=61\", \"setuptools_scm>=6.2\"]\r\nbuild-backend = \"setuptools.build_meta\"\r\n\r\n[tool.setuptools_scm]\r\nwrite_to = \"ComPASS/_version.py\"\r\n",
    "setup.cfg": "[metadata]\nname = ComPASS\nauthor = BRGM/INRIA and various contributors\nauthor_email = compass@brgm.fr\ndescription = A parallel multiphase multicomponents simulator.\nlong_description = file: README.rst\nlicense = GPLv3/CeCILLv2.1\nurl= https://charms.gitlabpages.inria.fr/ComPASS\n\n\n[options]\npython_requires = >=3.7\n# we don't add mpi4py and petsc4py so as not to trigger compilations\ninstall_requires =\n    click\n    numpy>=1.21\n    numba!=0.55.2\n    inept<0.2\n    MeshTools\n    pyyaml\n    sortedcontainers\n    verstr\n    vtkwriters\n# packages must be listed in setup.py to be intercepted by scikit-build\n# cf. https://scikit-build.readthedocs.io/en/latest/usage.html#setuptools-options\n"
  },
  "segevfiner/pybpf_asm": {
    "setup.py": "# pybpf_asm - Python BPF Assembler\n# Copyright (C) 2022  Segev Finer\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License version 2 as\n# published by the Free Software Foundation\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nimport re\nfrom setuptools import find_packages\nfrom skbuild import setup\n\n\nwith open(\"bpf_asm/__init__.py\", \"r\", encoding=\"utf-8\") as f:\n    version = re.search(r'(?m)^__version__ = \"([a-zA-Z0-9.-]+)\"', f.read()).group(1)\n\nwith open(\"README.rst\", \"r\", encoding=\"utf-8\") as f:\n    long_description = f.read()\n\n\nsetup(\n    name=\"bpf_asm\",\n    version=version,\n    author=\"Segev Finer\",\n    author_email=\"segev208@gmail.com\",\n    description=\"Python BPF Assembler\",\n    long_description=long_description,\n    long_description_content_type=\"text/x-rst\",\n    url=\"https://github.com/segevfiner/pybpf_asm\",\n    project_urls={\n        \"Documentation\": \"https://segevfiner.github.io/pybpf_asm/\",\n        \"Issue Tracker\": \"https://github.com/segevfiner/pybpf_asm/issues\",\n    },\n    license=\"GPL-2.0-only\",\n    classifiers=[\n        \"Development Status :: 3 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: System :: Networking :: Monitoring\",\n        \"License :: OSI Approved :: GNU General Public License v2 (GPLv2)\",\n        \"Programming Language :: Cython\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n    ],\n    keywords=\"bpf\",\n    zip_safe=False,\n    packages=find_packages(),\n    entry_points={\n        \"console_scripts\": [\n            \"pybpf_asm = bpf_asm.__main__:main\"\n        ],\n    },\n    python_requires='>=3.6',\n    extras_require={\n        \"dev\": [\n            \"flake8\",\n            \"pytest\",\n            \"sphinx==5.*\"\n        ],\n    }\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build>=0.13.1\", \"cmake\", \"ninja\", \"cython\"]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "tdegeus/GooseFEM": {
    "setup.py": "from pathlib import Path\n\nfrom setuptools_scm import get_version\nfrom skbuild import setup\n\nproject_name = \"GooseFEM\"\n\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\nsetup(\n    name=project_name,\n    description=\"Finite element meshes, quadrature, and assembly tools\",\n    long_description=long_description,\n    version=get_version(),\n    license=\"GPLv3\",\n    author=\"Tom de Geus\",\n    author_email=\"tom@geus.me\",\n    url=f\"https://github.com/tdegeus/{project_name}\",\n    packages=[f\"{project_name}\"],\n    package_dir={\"\": \"python\"},\n    cmake_install_dir=f\"python/{project_name}\",\n    cmake_minimum_required_version=\"3.13\",\n)\n"
  },
  "MeasureTransport/MParT": {
    "setup.py": "from skbuild import setup\n\nimport os, sys, site\nimport warnings\n\ndef get_install_locations():\n    \"\"\"Return the installation directory, or '' if no directory could be found \n\n       Adapted from stack overflow post https://stackoverflow.com/a/36205159\n    \"\"\"\n    \n    if '--user' in sys.argv:\n        paths = (site.getusersitepackages(),)\n    else:\n        py_version = f'{sys.version_info[0]}.{sys.version_info[1]}'\n        paths = [\n            sys.prefix + f'/lib/python{py_version}/dist-packages/',\n            sys.prefix + f'/lib/python{py_version}/site-packages/',\n            sys.prefix + f'/local/lib/python{py_version}/dist-packages/',\n            sys.prefix + f'/local/lib/python{py_version}/site-packages/',\n            f'/Library/Frameworks/Python.framework/Versions/{py_version}/lib/python{py_version}/site-packages/'\n        ]\n\n    for path in paths:\n        if os.path.exists(path):\n            parts = path.split('/')\n            lib_indices = [index for index, item in enumerate(parts) if item == 'lib']\n            return path, '/'.join(parts[0:(lib_indices[-1]+1)])\n        \n    return ''\n\nsite_folder, lib_folder = get_install_locations()\n\n\nsetup(\n    packages=['mpart'],\n    package_dir={'mpart': 'bindings/python/package'},\n    package_data={'mpart':['**/*pympart*']},\n    include_package_data=True,\n    cmake_args=['-DKokkos_ENABLE_THREADS:BOOL=ON', f'-DSKBUILD_LIB_RPATH={lib_folder}', f'-DSKBUILD_SITE_PATH={site_folder}', '-DPYTHON_INSTALL_SUFFIX=bindings/python/package/', '-DMPART_JULIA:BOOL=OFF', '-DMPART_MATLAB:BOOL=OFF', '-DMPART_BUILD_TESTS:BOOL=OFF', '-DMPART_PYTHON:BOOL=ON', '-DPYTHON_INSTALL_PREFIX=']\n)",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\",\n    \"scikit-build>=0.13\",\n    \"cmake\",\n    \"ninja\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"MParT\"\nauthors = [\n    {name = \"Matthew Parno\"},\n]\nlicense={file=\"LICENSE.txt\"}\nreadme=\"README.md\"\nrequires-python = \">=3.7\"\ndescription=\"A Monotone Parameterization Toolkit\"\nversion=\"2.0.2\"\nkeywords=[\"Measure Transport\", \"Monotone\", \"Transport Map\", \"Isotonic Regression\", \"Triangular\", \"Knothe-Rosenblatt\"]\n\n[project.urls]\nDocumentation = \"https://measuretransport.github.io/MParT/\"\nSource = \"https://github.com/MeasureTransport/MParT\"\n"
  },
  "InsightSoftwareConsortium/ITKMeshToPolyData": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-meshtopolydata',\n    version='0.10.0',\n    author='Insight Software Consortium',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKMeshToPolyData',\n    description=r'Convert an ITK Mesh to a simple data structure compatible with vtkPolyData.',\n    long_description='ITK is an open-source, cross-platform library that provides developers with an extensive suite of software tools for image analysis. Developed through extreme programming methodologies, ITK employs leading-edge algorithms for registering and segmenting multidimensional scientific images.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk-core>=5.3.0',\n        r'numpy',\n    ]\n    )\n"
  },
  "kratsg/pylibmagic": {
    "setup.py": "#!/usr/bin/env python\n# Copyright (c) 2022, Giordon Stark\n#\n# Distributed under the 3-clause BSD license, see accompanying file LICENSE\n# or https://github.com/kratsg/pylibmagic for details.\n\nfrom __future__ import annotations\n\nfrom skbuild import setup  # isort:skip\n\nsetup(\n    packages=[\"pylibmagic\"],\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/pylibmagic\",\n    include_package_data=False,  # see scikit-build/scikit-build#680\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"setuptools_scm[toml]>=3.4\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"src/pylibmagic/_version.py\"\n\n\n[tool.cibuildwheel]\ntest-extras = [\"test\"]\ntest-command = \"pytest {project}/tests\"\narchs = [\"auto64\"]\nbefore-all = \"yum install autoconf automake\"\n\n[[tool.cibuildwheel.overrides]]\nselect = \"*-musllinux*\"\nbefore-all = \"apk add autoconf automake\"\n\n[[tool.cibuildwheel.overrides]]\nselect = \"*-macosx*\"\nbefore-all = \"brew install autoconf automake libtool\"\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\naddopts = [\"-ra\", \"--showlocals\", \"--strict-markers\", \"--strict-config\", \"-m\", \"not isolate\"]\nxfail_strict = true\nfilterwarnings = [\"error\"]\ntestpaths = [\n    \"tests\",\n]\nmarkers = [\n    \"isolate\",\n]\nlog_cli_level = \"INFO\"\n\n\n[tool.pycln]\nall = true\n\n[tool.mypy]\nfiles = \"src\"\npython_version = \"3.7\"\nwarn_unused_configs = true\nstrict = true\nshow_error_codes = true\nenable_error_code = [\"ignore-without-code\", \"redundant-expr\", \"truthy-bool\"]\nwarn_unreachable = true\n\n[tool.ruff]\nselect = [\n  \"E\", \"F\", \"W\", # flake8\n  \"B\",  \"B904\",  # flake8-bugbear\n  \"I\",           # isort\n  \"ARG\",         # flake8-unused-arguments\n  \"C4\",          # flake8-comprehensions\n  \"EM\",          # flake8-errmsg\n  \"ICN\",         # flake8-import-conventions\n  \"ISC\",         # flake8-implicit-str-concat\n  \"PGH\",         # pygrep-hooks\n  \"PIE\",         # flake8-pie\n  \"PL\",          # pylint\n  \"PT\",          # flake8-pytest-style\n  \"PTH\",         # flake8-use-pathlib\n  \"RET\",         # flake8-return\n  \"RUF\",         # Ruff-specific\n  \"SIM\",         # flake8-simplify\n  \"T20\",         # flake8-print\n  \"UP\",          # pyupgrade\n  \"YTT\",         # flake8-2020\n]\nextend-ignore = [\"PLR\", \"E501\"]\ntarget-version = \"py37\"\ntyping-modules = [\"mapyde._compat.typing\"]\nsrc = [\"src\"]\nunfixable = [\"T20\", \"F841\"]\nexclude = []\nisort.required-imports = [\"from __future__ import annotations\"]\n\n[tool.ruff.per-file-ignores]\n\"tests/**\" = [\"T20\"]\n\"noxfile.py\" = [\"T20\"]\n\n[tool.pylint]\nmaster.py-version = \"3.7\"\nmaster.ignore-paths= [\"src/pylibmagic/_version.py\"]\nreports.output-format = \"colorized\"\nsimilarities.ignore-imports = \"yes\"\nmessages_control.disable = [\n  \"design\",\n  \"fixme\",\n  \"line-too-long\",\n  \"wrong-import-position\",\n]\n",
    "setup.cfg": "[metadata]\nname = pylibmagic\ndescription = scikit-build project with CMake for compiling libmagic\nlong_description = file: README.rst\nlong_description_content_type = text/x-rst\nurl = https://github.com/kratsg/pylibmagic\nauthor = Giordon Stark\nauthor_email = kratsg@gmail.com\nmaintainer = Giordon Stark\nmaintainer_email = kratsg@gmail.com\nlicense = BSD-3-Clause\nlicense_file = LICENSE\nplatforms =\n    Any\nclassifiers =\n    Development Status :: 1 - Planning\n    Intended Audience :: Developers\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: BSD License\n    Operating System :: OS Independent\n    Programming Language :: Python\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3 :: Only\n    Programming Language :: Python :: 3.7\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Topic :: Scientific/Engineering\nproject_urls =\n    Documentation = https://pylibmagic.readthedocs.io/\n    Bug Tracker = https://github.com/kratsg/pylibmagic/issues\n    Discussions = https://github.com/kratsg/pylibmagic/discussions\n    Changelog = https://github.com/kratsg/pylibmagic/releases\n\n[options]\npackages = find:\ninstall_requires =\n    importlib-resources;python_version < \"3.9\"\n    typing-extensions>=3.7;python_version<'3.8'\npython_requires = >=3.7\ninclude_package_data = True\npackage_dir =\n    = src\n\n[options.packages.find]\nwhere = src\n\n[options.extras_require]\ndev =\n    pytest>=6\n    pytest-cov>=3\n    tbump>=6.7.0\n    twine\ndocs =\n    Sphinx>=4.0\n    myst-parser>=0.13\n    sphinx-book-theme>=0.1.0\n    sphinx-copybutton\ntest =\n    pytest>=6\n    pytest-cov>=3\n    python-magic\n"
  },
  "phcerdan/SGEXT": {
    "deploy/setup.py": "\n# Generated using: python setup_py_configure.py 'sgext'\n\nfrom __future__ import print_function\nfrom os import sys, path\nfrom skbuild import setup\n\nsys.path.append(path.dirname(path.dirname(path.abspath(__file__))))\nfrom sgextVersion import get_versions\n\n# this_directory = path.abspath(path.dirname(__file__))\n# sgext_readme_path = path.join(this_directory, 'SGEXT-source', 'SGEXT', 'README.md')\n# if path.exists(sgext_readme_path):\n#     with open(sgext_readme_path, encoding='utf-8') as f:\n#         long_description = f.read()\n# else:\n#     with open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n#         long_description = f.read()\n\nlong_description= r'SGEXT is an open-source, cross-platform library for ' \\\n                   'skeletonization of vascular/filaments images and tools for the posterior ' \\\n                   'graph analysis, using a spatial graph as an encriched graph with geometric ' \\\n                   'information.'\nsetup(\n    name='sgext',\n    version=get_versions()['package-version'],\n    author='Pablo Hernandez-Cerdan',\n    author_email='pablo.hernandez.cerdan@outlook.com',\n    packages=['sgext'],\n    package_dir={'sgext': 'sgext'},\n    package_data={\n        'sgext': ['tables/*.zlib']\n    },\n    cmake_source_dir='../',\n    cmake_args=[\n        '-DSG_BUILD_TESTING:BOOL=OFF',\n        '-DSG_MODULE_ANALYZE:BOOL=ON',\n        '-DSG_MODULE_COMPARE:BOOL=ON',  # VTK\n        '-DSG_MODULE_LOCATE:BOOL=ON',  # VTK\n        '-DSG_MODULE_GENERATE:BOOL=ON', # C++17, optional TBB (recommended)\n        '-DSG_MODULE_DYNAMICS:BOOL=ON', # C++17\n        '-DSG_MODULE_SCRIPTS:BOOL=ON',  # ITK\n        '-DSG_BUILD_CLI:BOOL=ON',  # ITK\n        '-DSG_MODULE_VISUALIZE:BOOL=ON',  # VTK\n        '-DSG_MODULE_VISUALIZE_WITH_QT:BOOL=OFF'  # QT\n        '-DSG_WRAP_PYTHON:BOOL=ON'\n    ],\n    cmake_install_target=\"sgext-install-runtime\",\n    py_modules=[\n        'sgextVersion',\n    ],\n    download_url=r'https://github.com/phcerdan/SGEXT',\n    description=r'SGEXT is an open-source toolkit for skeletonization and graph analysis',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    classifiers=[\n        \"License :: OSI Approved :: GNU General Public License v3 (GPLv3)\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='GPLv3',\n    keywords=r'SGEXT thinning skeletonization graph complex-networks imaging',\n    url=r'https://github.com/phcerdan/SGEXT',\n    install_requires=[\n    ]\n    )\n"
  },
  "tlestang/septembrse_example": {
    "setup.py": "\"\"\"This is a minimal setup.py to be able to use scikit-build\n\nhttps://scikit-build.readthedocs.io/en/latest/\n\nProject metadata including build-time requirements are declared in the\npyproject.toml file, following PEP621\n(https://peps.python.org/pep-0621/).\n\n2022-11-25: Package location location still needs to be passed trough\nscikit-build.setup() instead of the pyproject.toml file, as it is\nprocessed by scikit-build.\n\n\"\"\"\nfrom skbuild import setup\n\nsetup(\n    package_dir={'': 'src'},\n    packages=[\"example_pkg\"],\n    cmake_install_dir=\"src/example_pkg\",\n)\n",
    "pyproject.toml": "[project]\nname = \"septembrse\"\nversion = \"0.0.2\"\nlicense = {text = \"GPLv3\"}\ndescription = \"A simple example package for the walkthrough\"\nauthors = [\n  {email = \"t.lestang@imperial.ac.uk\"},\n  {name = \"Thibault Lestang\"}\n]\n[project.urls]\nrepository=\"https://github.com/tlestang/septembrse_example\"\n[project.scripts]\nseptembrse = \"example_pkg.dot_prod:main\"\n[build-system]\nrequires = [\n  \"setuptools>=42\",\n  \"scikit-build\",\n  \"cmake\",\n  \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "KitwareMedical/HASI": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-hasi',\n    version='0.3.0',\n    author='Kitware Medical',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/KitwareMedical/HASI',\n    description=r'High-throughput Applications for Skeletal Imaging',\n    long_description='Web browser-based High-Throughput Applications for Skeletal Imaging (HASI). Automated biomarker computation pipeline, visualization tools, and data management based on the powerful, open source Insight Toolkit (ITK), Visualization Toolkit for JavaScript, and Girder Data Management System to provide image-based metrics of osteoarthritis and related diseases.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.3.0',\n        r'itk-boneenhancement',\n        r'itk-ioscanco'\n    ]\n    )\n"
  },
  "freebsd/freebsd-ports-haskell": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "daanzu/wenet_active_grammar": {
    "setup.py": "#\n# This file is part of wenet_active_grammar.\n# (c) Copyright 2021 by David Zurow\n# Licensed under the AGPL-3.0; see LICENSE file.\n#\n\nfrom setuptools import find_packages\nimport datetime, os, re, subprocess\n\nfrom skbuild import setup\n\n\n# Force wheel to be platform specific\n# https://stackoverflow.com/questions/45150304/how-to-force-a-python-wheel-to-be-platform-specific-when-building-it\n# https://github.com/Yelp/dumb-init/blob/48db0c0d0ecb4598d1a6400710445b85d67616bf/setup.py#L11-L27\n# https://github.com/google/or-tools/issues/616#issuecomment-371480314\ntry:\n    from wheel.bdist_wheel import bdist_wheel as bdist_wheel\n    class bdist_wheel_impure(bdist_wheel):\n\n        def finalize_options(self):\n            bdist_wheel.finalize_options(self)\n            # Mark us as not a pure python package\n            self.root_is_pure = False\n\n        def get_tag(self):\n            python, abi, plat = bdist_wheel.get_tag(self)\n            # We don't contain any python source\n            python, abi = 'py2.py3', 'none'\n            return python, abi, plat\n\n    from setuptools.command.install import install\n    class install_platlib(install):\n        def finalize_options(self):\n            install.finalize_options(self)\n            self.install_lib = self.install_platlib\n\nexcept ImportError:\n    bdist_wheel_impure = None\n    install_platlib = None\n\n\nhere = os.path.abspath(os.path.dirname(__file__))\n\n# https://packaging.python.org/guides/single-sourcing-package-version/\ndef read(*parts):\n    with open(os.path.join(here, *parts), 'r') as fp:\n        return fp.read()\n\ndef find_version(*file_paths):\n    version_file = read(*file_paths)\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\nversion = find_version('src', 'wenet_active_grammar', '__init__.py')\nif version.endswith('dev0'):\n    version = version[:-1] + datetime.datetime.now().strftime('%Y%m%d%H%M%S')\n\nwith open(os.path.join(here, 'README.md')) as f:\n    long_description = f.read()\n\nif not os.path.exists('native/wenet/runtime/server/x86/CMakeLists.txt'):\n    subprocess.check_call(['git', 'submodule', 'update', '--init', 'native/wenet'])\n\n\nsetup(\n    cmdclass={\n        'bdist_wheel': bdist_wheel_impure,\n        'install': install_platlib,\n    },\n    # cmake_args=['-DCMAKE_PREFIX_PATH=' + torch_cmake_prefix_path],\n\n    name='wenet_active_grammar',\n    version=version,\n    description='Simple Python library, distributed via binary wheels with few direct dependencies, for easily using wav2vec 2.0 models for speech recognition.',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://github.com/daanzu/wenet_active_grammar',\n    author='David Zurow',\n    author_email='daanzu@gmail.com',\n    license='AGPL-3.0',\n    # For a list of valid classifiers, see https://pypi.org/classifiers/\n    classifiers=[\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        'Development Status :: 4 - Beta',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: GNU Affero General Public License v3',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n    ],\n    # keywords='speech recognition',\n    packages=find_packages('src'),\n    package_dir={'': 'src'},\n    # py_modules=[splitext(basename(path))[0] for path in glob('src/*.py')],\n    package_data={\n        # 'package_name': ['glob_patterns_to_install'],\n        'wenet_active_grammar': ['libwenet_stt_lib.so', 'libwenet_stt_lib.dylib', '*.dll'],\n        '': ['LICENSE'],\n    },\n    zip_safe=False,\n    cmake_process_manifest_hook=(lambda cmake_manifest: []),  # We manually copy out the files we care about from the cmake build, so ignore everything else that is installed in/by cmake.\n    python_requires='>=3.6, <4',\n    install_requires=[\n        'cffi ~= 1.12',\n        'numpy ~= 1.16, != 1.19.4',\n        'six',\n    ],\n    extras_require={\n        # 'dev': ['check-manifest'],\n        'test': ['pytest'],\n    },\n    project_urls={\n        'Bug Reports': 'https://github.com/daanzu/wenet_active_grammar/issues',\n        'Funding': 'https://github.com/sponsors/daanzu',\n        # 'Say Thanks!': 'http://saythanks.io/to/example',\n        'Source': 'https://github.com/daanzu/wenet_active_grammar/',\n    },\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build~=0.10.0\", \"cmake>=3.15\", \"ninja\", \"torch~=1.9.0\"]\n",
    "setup.cfg": "[metadata]\n# This includes the license file(s) in the wheel.\n# https://wheel.readthedocs.io/en/stable/user_guide.html#including-license-files-in-the-generated-wheel-file\nlicense_files = LICENSE\n\n[bdist_wheel]\n# This flag says to generate wheels that support both Python 2 and Python\n# 3. If your code will not run unchanged on both Python 2 and 3, you will\n# need to generate separate wheels for each Python version that you\n# support. Removing this line (or setting universal to 0) will prevent\n# bdist_wheel from trying to make a universal wheel. For more see:\n# https://packaging.python.org/guides/distributing-packages-using-setuptools/#wheels\n# universal=1\n"
  },
  "ofmla/seiscope_opt_toolbox_w_ctypes": {
    "setup.py": "import os\nimport sys\nfrom skbuild import setup  # This line replaces 'from setuptools import setup'\nsys.path.insert(0, os.path.dirname(__file__))\nimport versioneer\n\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nconfiguration = {\n    'name': 'sotb-wrapper',\n    'packages': [\"sotb_wrapper\"],\n    'package_dir': {'sotb-wrapper': 'sotb_wrapper'},\n    'version': versioneer.get_version(),\n    'cmdclass': versioneer.get_cmdclass(),\n    'description': \"wrapper to call fortran routines from SEISCOPE optimization toolbox\",\n    'long_description': long_description,\n    'long_description_content_type': 'text/markdown',\n    'url': 'https://github.com/ofmla/seiscope_opt_toolbox_w_ctypes',\n    'author': \"Oscar Mojica\",\n    'author_email': 'o_mojical@hotmail.com',\n    'package_data': {'sotb-wrapper': ['libsotb.so', 'test_*'], },\n    'cmake_args': [\"-DSKBUILD=ON\"],\n    'license': 'MIT',\n    'install_requires': ['numpy>=1.20'],\n    'setup_requires': ['versioneer'],\n    'zip_safe': False\n}\n\nsetup(**configuration)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"fypp\", \"ninja; platform_system!='Windows'\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.coverage.run]\nbranch = true\nomit = [\"*/site-packages/sotb_wrapper/_version.py\"]\n\n[tool.coverage.paths]\nsource = [\"sotb_wrapper\", \"*/site-packages/sotb_wrapper\"]\n\n[tool.coverage.report]\nshow_missing = true\n\n[tool.isort]\nprofile = \"black\"\nmulti_line_output = 3\nforce_sort_within_sections = true\norder_by_type = false\ngroup_by_package = true\nlexicographical = true\n\n[tool.mypy]\ndisallow_any_explicit = false\ndisallow_any_generics = false\nallow_redefinition = true\ncheck_untyped_defs = true\ndisallow_untyped_calls = true\ndisallow_subclassing_any = true\nfollow_imports = \"silent\"\nignore_errors = false\nignore_missing_imports = true\nimplicit_reexport = false\nstrict_optional = true\nstrict_equality = true\nno_implicit_optional = true\nlocal_partial_types = true\nwarn_no_return = true\nwarn_unused_ignores = true\nwarn_redundant_casts = true\nwarn_return_any = true\nwarn_unused_configs = true\nwarn_unreachable = true\nshow_traceback = true\n[[tool.mypy.overrides]]\nmodule = \"numpy.*\"\nallow_untyped_calls = true\n",
    "setup.cfg": "[flake8]\nexclude = .github, _version.py\nselect = ANN,C,E,F,W,I,BLK,B,B9,D,DAR\nignore = ANN002,ANN003,ANN101,E203,E226,E501,E722,E731,E741,F403,F405,W503,W504,W605,D105,D107,DAR203\nmax-line-length = 90\nmax-complexity = 10\napplication-import-names = sotb_wrapper,tests\nimport-order-style = google\ndocstring-convention = google\nstrictness = short\nper-file-ignores =\n\tsotb_wrapper/examples/*:ANN\n    test/*:S101,ANN\n    noxfile.py:ANN\n    setup.py:D100,BLK100\nextend-exclude = .nox\nbuiltins =\n\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run 'versioneer.py setup' after changing this section, and commit the\n# resulting files.\n\n[versioneer]\nVCS = git\nstyle = pep440\nversionfile_source = sotb_wrapper/_version.py\nversionfile_build = sotb_wrapper/_version.py\ntag_prefix =\n\n"
  },
  "hombit/freddi": {
    "setup.py": "#!/usr/bin/env python\n\nfrom skbuild import setup\n\n\nwith open('Readme.md') as fh:\n    readme = fh.read()\n\n\nsetup(\n    name='freddi',\n    version='2.0.0b2',\n    url='http://xray.sai.msu.ru/~malanchev/freddi/',\n    license='GPLv3',\n    author='Konstantin Malanchev',\n    author_email='malanchev@sai.msu.ru',\n    description='Compute FRED light curves of LMXBs outbursts',\n    long_description=readme,\n    long_description_content_type='text/markdown',\n    package_dir={'': 'python'},\n    packages=['freddi'],\n    install_requires=['numpy'],\n    setup_requires=['numpy'],\n    python_requires='>=3.7',\n    classifiers=[\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3 :: Only',\n        'Topic :: Scientific/Engineering :: Physics',\n    ],\n    keywords='science astrophysics accretion',\n)\n\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\", \"numpy\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.pytest.ini_options]\nminversion = \"6.0\"\ntestpaths = [\n    \"python/test/\",\n]\n"
  },
  "miquelmassot/g2o-python": {
    "setup.py": "import io\nimport os\nimport os.path\nimport skbuild\nfrom skbuild import cmaker\n\n\ndef main():\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    cmake_source_dir = \"g2o\"\n\n    install_requires = [\n        'numpy',\n        'scikit-build',\n    ]\n\n    # Fix g2o/python/CMakeLists.txt file, install pybind11 to \".\"\n    with open(os.path.join(cmake_source_dir, \"python/CMakeLists.txt\"), \"r\") as file:\n        filedata = file.read()\n        filedata = filedata.replace(\n            \"install(TARGETS g2opy LIBRARY DESTINATION g2opy)\",\n            \"install(TARGETS g2opy LIBRARY DESTINATION g2o)\"\n        )\n    with open(os.path.join(cmake_source_dir, \"python/CMakeLists.txt\"), \"w\") as file:\n        file.write(filedata)\n\n    # Fix g2o/CMakeLists.txt file, remove the lines\n    #   set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${g2o_LIBRARY_OUTPUT_DIRECTORY})\n    #   set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${g2o_LIBRARY_OUTPUT_DIRECTORY})\n    #   set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${g2o_RUNTIME_OUTPUT_DIRECTORY})\n    with open(os.path.join(cmake_source_dir, \"CMakeLists.txt\"), \"r\") as file:\n        filedata = file.read()\n        filedata = filedata.replace(\n            \"set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${g2o_LIBRARY_OUTPUT_DIRECTORY})\",\n            \"\",\n        )\n        filedata = filedata.replace(\n            \"set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${g2o_LIBRARY_OUTPUT_DIRECTORY})\",\n            \"\",\n        )\n        filedata = filedata.replace(\n            \"set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${g2o_RUNTIME_OUTPUT_DIRECTORY})\",\n            \"\",\n        )\n    with open(os.path.join(cmake_source_dir, \"CMakeLists.txt\"), \"w\") as file:\n        file.write(filedata)\n\n    # Add __init__.py at g2o root folder to be able to write in python:\n    #   import g2o\n    with open(os.path.join(cmake_source_dir, \"__init__.py\"), \"w\") as file:\n        file.write(\"from .g2opy import *  # noqa: F401\")\n\n    cmake_args = [\n        # See g2o/CMakeLists.txt for options and defaults\n        \"-DBUILD_SHARED_LIBS=OFF\",\n        \"-DG2O_USE_OPENGL=OFF\",\n        \"-DG2O_BUILD_EXAMPLES=OFF\",\n        \"-DG2O_BUILD_APPS=OFF\",\n        \"-DG2O_BUILD_PYTHON=ON\",\n        \"-DCMAKE_POSITION_INDEPENDENT_CODE=ON\",\n    ]\n\n    # https://github.com/scikit-build/scikit-build/issues/479\n    if \"CMAKE_ARGS\" in os.environ:\n        import shlex\n\n        cmake_args.extend(shlex.split(os.environ[\"CMAKE_ARGS\"]))\n        del shlex\n\n    skbuild.setup(\n        name=\"g2o-python\",\n        version=\"0.0.11\",\n        url=\"https://github.com/miquelmassot/g2o-python\",\n        license=\"MIT\",\n        description=\"Wrapper package for G2O python bindings.\",\n        long_description=io.open(\"README.md\", encoding=\"utf-8\").read(),\n        long_description_content_type=\"text/markdown\",\n        maintainer=\"Miquel Massot\",\n        packages=[\"g2o\"],\n        ext_modules=EmptyListWithLength(),\n        install_requires=install_requires,\n        python_requires=\">=3.6\",\n        classifiers=[\n            \"Development Status :: 5 - Production/Stable\",\n            \"Environment :: Console\",\n            \"Intended Audience :: Developers\",\n            \"Intended Audience :: Education\",\n            \"Intended Audience :: Information Technology\",\n            \"Intended Audience :: Science/Research\",\n            \"License :: OSI Approved :: MIT License\",\n            \"Operating System :: MacOS\",\n            \"Operating System :: Microsoft :: Windows\",\n            \"Operating System :: POSIX\",\n            \"Operating System :: Unix\",\n            \"Programming Language :: Python\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: 3 :: Only\",\n            \"Programming Language :: Python :: 3.6\",\n            \"Programming Language :: Python :: 3.7\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n            \"Programming Language :: C++\",\n            \"Programming Language :: Python :: Implementation :: CPython\",\n            \"Topic :: Scientific/Engineering\",\n            \"Topic :: Software Development\",\n        ],\n        cmake_args=cmake_args,\n        cmake_source_dir=cmake_source_dir,\n    )\n\n\n# This creates a list which is empty but returns a length of 1.\n# Should make the wheel a binary distribution and platlib compliant.\nclass EmptyListWithLength(list):\n    def __len__(self):\n        return 1\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools\", \n  \"wheel\",\n  \"cmake\", \n  \"pip\",\n  \"scikit-build\",\n  \"numpy\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel.macos]\nbefore-build= \"brew install eigen\"\n\n[tool.cibuildwheel.windows]\nbefore-build = \"choco install eigen\"\n\n[tool.cibuildwheel.linux]\nbefore-build = \"yum install -y eigen3-devel\"\n"
  },
  "mayeut/patchelf-pypi": {
    "setup.py": "#!/usr/bin/env python\n\nimport os\nfrom stat import ST_MODE\n\nfrom setuptools import Command\nfrom setuptools_scm import get_version\nfrom skbuild import setup\nfrom wheel.bdist_wheel import bdist_wheel as _bdist_wheel\n\n\nclass bdist_wheel(_bdist_wheel):\n    def finalize_options(self):\n        _bdist_wheel.finalize_options(self)\n        self.root_is_pure = False\n\n    def get_tag(self):\n        python, abi, plat = _bdist_wheel.get_tag(self)\n        python, abi = \"py2.py3\", \"none\"\n        if os.environ.get(\"CIBUILDWHEEL\", \"0\") == \"1\":\n            assert plat.startswith(\"linux_\")\n            arch = plat[6:]\n            tags = []\n            if arch in {\"i686\", \"x86_64\"}:\n                tags = [\"manylinux_2_5_{arch}\", \"manylinux1_{arch}\"]\n            else:\n                tags = [\"manylinux_2_17_{arch}\", \"manylinux2014_{arch}\"]\n            tags.append(\"musllinux_1_1_{arch}\")\n            plat = \".\".join([tag.format(arch=arch) for tag in tags])\n        return python, abi, plat\n\n\nclass build_scripts(Command):\n    user_options = [\n        ('build-dir=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps\"),\n        ('executable=', 'e', \"specify final destination interpreter path\"),\n        ]\n\n    boolean_options = ['force']\n\n    def initialize_options(self):\n        self.build_dir = None\n        self.scripts = None\n        self.force = None\n        self.executable = None\n        self.outfiles = None\n\n    def finalize_options(self):\n        self.set_undefined_options('build',\n                                   ('build_scripts', 'build_dir'),\n                                   ('force', 'force'),\n                                   ('executable', 'executable'))\n        self.scripts = self.distribution.scripts\n\n    def get_source_files(self):\n        return self.scripts\n\n    def run(self):\n        if not self.scripts:\n            return\n        self.copy_scripts()\n\n    def copy_scripts(self):\n        self.mkpath(self.build_dir)\n        outfiles = []\n        updated_files = []\n        for script in self.scripts:\n            outfile = os.path.join(self.build_dir, os.path.basename(script))\n            outfiles.append(outfile)\n            updated_files.append(outfile)\n            self.copy_file(script, outfile)\n\n        if os.name == 'posix':\n            for file in outfiles:\n                if not self.dry_run:\n                    oldmode = os.stat(file)[ST_MODE] & 0o7777\n                    newmode = (oldmode | 0o555) & 0o7777\n                    if newmode != oldmode:\n                        os.chmod(file, newmode)\n        return outfiles, updated_files\n\n\nwith open(\"README.rst\") as fp:\n    readme = fp.read()\n\ncmdclass = {\"bdist_wheel\": bdist_wheel, \"build_scripts\": build_scripts}\n\nsetup(\n    name=\"patchelf\",\n\n    maintainer=\"Matthieu Darbois\",\n    maintainer_email=\"mayeut@users.noreply.github.com\",\n\n    version=get_version(),\n    cmdclass=cmdclass,\n\n    scripts=[\"bin/patchelf\"],\n\n    url=\"https://github.com/NixOS/patchelf\",\n    project_urls={\n        \"Source Code\": \"https://github.com/mayeut/patchelf-pypi\",\n        \"Bug Tracker\": \"https://github.com/mayeut/patchelf-pypi/issues\",\n    },\n\n    description=(\n        \"A small utility to modify the dynamic linker and RPATH of ELF \"\n        \"executables.\"\n    ),\n    long_description=readme,\n    long_description_content_type=\"text/x-rst\",\n    classifiers=[\n        (\n            \"License :: OSI Approved :: GNU General Public License v3 or \"\n            \"later (GPLv3+)\"\n        ),\n        \"Programming Language :: C\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python\",\n        \"Operating System :: POSIX :: Linux\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Topic :: Software Development :: Build Tools\",\n    ],\n\n    license=\"GPL-3.0-or-later\",\n    license_files=[\"COPYING\", \"LICENSE\"],\n    keywords=\"patchelf auditwheel elf manylinux musllinux\",\n\n    extras_require={\"test\": [\"pytest\", \"importlib-metadata\"]},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"scikit-build>=0.12\",\n    \"setuptools>=42\",\n    \"setuptools_scm>=5\",\n    \"wheel\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.cibuildwheel]\nbuild = \"cp311-musllinux*\"\nbuild-verbosity = 3\nrepair-wheel-command = \"cp {wheel} {dest_dir}/\"\ntest-extras = \"test\"\ntest-command = \"pytest {project}/tests\"\nmusllinux-x86_64-image = \"patchelf_build_x86_64\"\nmusllinux-i686-image = \"patchelf_build_i686\"\nmusllinux-aarch64-image = \"patchelf_build_aarch64\"\nmusllinux-ppc64le-image = \"patchelf_build_ppc64le\"\nmusllinux-s390x-image = \"patchelf_build_s390x\"\n\n[tool.cibuildwheel.linux.environment]\nCXXFLAGS = \"-D_FORTIFY_SOURCE=2 -fstack-protector-strong -Wformat -Werror=format-security -O2 -static\"\n"
  },
  "astro-informatics/so3": {
    "setup.py": "from pathlib import Path\n\nfrom skbuild import setup\n\ncmake_args = [\n    \"-DBUILD_TESTING:BOOL=OFF\",\n    \"-Dconan_deps=ON\",\n    \"-DCMAKE_POSITION_INDEPENDENT_CODE=ON\",\n]\n\nsetup(\n    name=\"so3\",\n    version=\"1.3.6\",\n    author=\"Jason McEwen\",\n    install_requires=[\"numpy\", \"scipy\"],\n    extras_require={\n        \"dev\": [\n            \"setuptools\",\n            \"wheel\",\n            \"scikit-build\",\n            \"cmake\",\n            \"ninja\",\n            \"cython\",\n            \"conan\",\n            \"black\",\n            \"pytest\",\n        ]\n    },\n    description=\"Fast and exact Wigner Transforms\",\n    url=\"http://astro-informatics.github.io/so3/\",\n    package_dir={\"so3\": \"src/so3\"},\n    cmake_args=cmake_args,\n    cmake_languages=(\"C\",),\n    license=\"GPL-3\",\n    packages=[\"so3\"],\n    long_description=Path(__file__).with_name(\"README.md\").read_text(),\n    long_description_content_type=\"text/markdown\",\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools\", \"wheel\", \"scikit-build\", \"cmake>=3.12\", \"ninja\", \"cython\",\n    \"oldest-supported-numpy\", \"conan<2\"\n]\n\n[tool.isort]\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nensure_newline_before_comments = true\nline_length = 88\n                                      \n[tool.pylint.messages_control]\ndisable = \"C0330, C0326\"\n                                      \n[tool.pylint.format]\nmax-line-length = 88\n",
    "setup.cfg": "[bumpversion]\ncurrent_version = 1.3.6\ncommit = False\ntag = False\nparse = (?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)(rc(?P<rc>\\d+))?\nserialize = \n\t{major}.{minor}.{patch}rc{rc}\n\t{major}.{minor}.{patch}\n\n[bumpversion:file:setup.py]\n\n[bumpversion:file:makefile]\n\n[bumpversion:file:CMakelists.txt]\n\n[bumpversion:file:.github/workflows/python.yml]\n\n[flake8]\nmax-line-length = 88\nextend-ignore = E203, W503\nexclude = \n\t.tox,\n\t.git,\n\tbuild,\n\t__pycache__,\n\tdocs/,\n\n[pycodestyle]\nmax-line-length = 88\nignore = E203\n"
  },
  "Nicholaswogan/photochem": {
    "setup.py": "from skbuild import setup\nfrom setuptools import find_namespace_packages\nfrom os import path\n\nthis_directory = path.abspath(path.dirname(__file__))\nwith open(path.join(this_directory, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nwith open(\"CMakeLists.txt\",'r') as fil:\n    lines = fil.readlines()\n    for line in lines:\n        if line.startswith(\"project(Photochem\"):\n            version = line.split('\"')[1]\n            break\n            \nsetup(\n    name=\"photochem\",\n    packages=find_namespace_packages(),\n    python_requires='>=3.6',\n    version=version,\n    license=\"GNU General Public License v3.0\",\n    install_requires=['numpy','scipy','pyyaml', 'numba'], \n    author='Nicholas Wogan',\n    author_email = 'nicholaswogan@gmail.com',\n    description = \"Photochemical model of planet's atmospheres.\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url = \"https://github.com/Nicholaswogan/Photochem\",\n    include_package_data=True,\n    cmake_args=['-DSKBUILD=ON',\\\n                '-DBUILD_PYTHON_PHOTOCHEM=ON',\\\n                '-DBUILD_EXECUTABLES=OFF',\\\n                '-DBUILD_WITH_OPENMP=ON']\n)\n\n\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools>=42\", \"wheel\", \"scikit-build\", \"cmake>=3.12\", \"ninja\", \"numpy\", \"cython\"]\n"
  },
  "tbrekalo/mini": {
    "setup.py": "import sys\nfrom skbuild import setup\n\ntry:\n    from skbuild import setup\n    import nanobind\nexcept ImportError:\n    print(\"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n          \"install .'. If you wish to run the setup script directly, you must \"\n          \"first install the build dependencies listed in pyproject.toml!\",\n          file=sys.stderr)\n    raise\n\nsetup(\n    name=\"minipy\",\n    version=\"1.4.0\",\n    author=\"Tvrtko Brekalo\",\n    author_email=\"brekalo.tvrtko@gmail.com\",\n    description=\"Minimizer extraction utility library as described in minimap paper\",\n    url=\"https://github.com/tbrekalo/mini\",\n    license=\"BSD\",\n    packages=['minipy'],\n    package_dir={'': 'src'},\n    cmake_install_dir=\"src/minipy\",\n    include_package_data=True,\n    python_requires=\">=3.8\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"cmake>=3.17\",\n  \"nanobind\",\n  \"ninja; platform_system!='Windows'\",\n  \"scikit-build==0.14.0\",\n  \"setuptools>=42\",\n  \"wheel\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"minipy\"\nversion = \"1.4.0\"\ndescription = \"Minimizer extraction utility library as described in minimap paper\"\nreadme = \"README.md\"\nauthors = [\n    {name = \"Tvrtko Brekalo\", email=\"brekalo.tvrtko@gmail.com\"},\n]\n\nrequires-python = \">=3.8\"\n"
  },
  "KitwareMedical/itkARGUS_DARPA_POCUS_AI": {
    "itkARGUS/setup.py": "# -*- coding: utf-8 -*-\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-argus',\n    version='0.1.0',\n    author='itkARGUS',\n    author_email='itk+community@discourse.itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/KitwareMedical/AnatomicRecon-POCUS-AI',\n    description=r'Anatomic Reconstruction for Generalized UltraSound (ARGUS) library',\n    long_description='Contains C++ methods that are compiled and wrapped into python for use in the ARGUS project at Kitware.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.2.0.post3'\n    ]\n    )\n"
  },
  "aimgui/aimgui": {
    "pkg/aimnodes/setup.py": "import sys\nimport setuptools\nfrom skbuild import setup\n\nfrom aimnodes_setup.install import install\nfrom aimnodes_setup.develop import develop\n\n#INSTALL_REQUIRES = [ 'pybind11', \"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n\nsetup(\n    name             = 'aimnodes',\n    description      = 'Advanced ImNodes',\n    version          = '0.1.0',\n    url              = 'http://github.com/aimgui/aimgui',\n    license          = 'MIT',\n    author           = 'kfields',\n    packages         = setuptools.find_packages(exclude=[\"__aimgen__\"]),\n    #package_data={'aimgui': ['*.so']},\n    #ext_modules      = [module],\n    #setup_requires   = ['pybind11', \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"],\n    #install_requires=INSTALL_REQUIRES,\n    cmdclass = {\n        'install': install,\n        'develop': develop\n    },\n)\n",
    "pkg/aimnodes/pyproject.toml": "[tool.poetry]\nname = \"aimnodes\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Kurtis Fields <kurtisfields@gmail.com>\"]\n\n[tool.poetry.dependencies]\npython = \">=3.8,<3.12\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.2.0\"\naimgen = {path = \"../aimgen\",  develop = true}\nscikit-build = \"^0.16.2\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\", \"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"poetry.core.masonry.api\"\n",
    "pkg/aimgui/setup.py": "import sys\nimport setuptools\nfrom skbuild import setup\n\nfrom aimgui_setup.install import install\nfrom aimgui_setup.develop import develop\n\n#INSTALL_REQUIRES = [ 'pybind11', \"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n\nsetup(\n    name             = 'aimgui',\n    description      = 'Advanced ImGui',\n    version          = '0.1.0',\n    url              = 'http://github.com/aimgui/aimgui',\n    license          = 'MIT',\n    author           = 'kfields',\n    packages         = setuptools.find_packages(exclude=[\"__aimgen__\"]),\n    #package_data={'aimgui': ['*.so']},\n    #ext_modules      = [module],\n    #setup_requires   = ['pybind11', \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"],\n    #install_requires=INSTALL_REQUIRES,\n    cmdclass = {\n        'install': install,\n        'develop': develop\n    },\n)\n",
    "pkg/aimgui/pyproject.toml": "[tool.poetry]\nname = \"aimgui\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Kurtis Fields <kurtisfields@gmail.com>\"]\n\n[tool.poetry.dependencies]\npython = \">=3.8,<3.12\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.2.0\"\naimgen = {path = \"../aimgen\",  develop = true}\nscikit-build = \"^0.16.2\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\", \"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"poetry.masonry.api\"\n",
    "setup.py": "import sys\nimport setuptools\nfrom skbuild import setup\n\nsetup(\n    name             = 'aimgui',\n    description      = 'Python ImGui/Bgfx integration',\n    version          = '0.1.0',\n    url              = 'http://github.com/aimgui/aimgui',\n    license          = 'MIT',\n    author           = 'kfields',\n    packages         = setuptools.find_packages(exclude=[\"__aimgen__\"]),\n    #package_data={'aimgui': ['*.so']},\n    #ext_modules      = [module],\n    #setup_requires   = ['pybind11', \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"],\n    #install_requires=INSTALL_REQUIRES,\n)\n",
    "pyproject.toml": "[tool.poetry]\nname = \"aimgui-root\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Kurtis Fields <kurtisfields@gmail.com>\"]\n\n[tool.poetry.dependencies]\npython = \">=3.8,<3.12\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.2.0\"\naimgen = {path = \"./pkg/aimgen\",  develop = true}\nscikit-build = \"^0.16.2\"\ncmake = \"^3.24.3\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\", \"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"poetry.masonry.api\"\n",
    "pkg/aimplot/setup.py": "import sys, os\nimport setuptools\nfrom skbuild import setup\n\nfrom aimplot_setup.install import install\nfrom aimplot_setup.develop import develop\n\nsetup(\n    name             = 'aimplot',\n    description      = 'Advanced ImPlot',\n    version          = '0.1.0',\n    url              = 'http://github.com/aimgui/aimgui',\n    license          = 'MIT',\n    author           = 'kfields',\n    packages         = setuptools.find_packages(exclude=[\"__aimgen__\"]),\n    cmdclass = {\n        'install': install,\n        'develop': develop\n    },\n)\n",
    "pkg/aimplot/pyproject.toml": "[tool.poetry]\nname = \"aimplot\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Kurtis Fields <kurtisfields@gmail.com>\"]\n\n[tool.poetry.dependencies]\npython = \">=3.8,<3.12\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.2.0\"\naimgen = {path = \"../aimgen\",  develop = true}\nscikit-build = \"^0.16.2\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\", \"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\nbuild-backend = \"poetry.core.masonry.api\"\n"
  },
  "InsightSoftwareConsortium/ITKThinShellDemons": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-thinshelldemons',\n    version='0.1.1',\n    author='Pranjal Sahu',\n    author_email='pranjal.sahu@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKThinShellDemons',\n    description=r'Thin Shell Demons for Surface to Surface Registration',\n    long_description='Thin SHell Demons for Surface to Surface Registration',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.3rc3'\n    ]\n    )\n"
  },
  "dune-project/dune-localfunctions": {
    "setup.py": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\nimport os, sys\ntry:\n    from dune.packagemetadata import metaData\nexcept ImportError:\n    from packagemetadata import metaData\nfrom skbuild import setup\nsetup(**metaData()[1])\n",
    "pyproject.toml": "# SPDX-FileCopyrightText: Copyright \u00a9 DUNE Project contributors, see file LICENSE.md in module root\n# SPDX-License-Identifier: LicenseRef-GPL-2.0-only-with-DUNE-exception\n\n[build-system]\nrequires = ['dune-geometry@git+https://gitlab.dune-project.org/core/dune-geometry.git', 'pip', 'setuptools', 'wheel', 'scikit-build', 'cmake', 'ninja', 'requests']\nbuild-backend = 'setuptools.build_meta'\n"
  },
  "python-packaging-tutorial/hello-cpp": {
    "setup.py": "import sys\n\nfrom skbuild import setup\n\n# Require pytest-runner only when running tests\npytest_runner = (['pytest-runner>=2.0,<3dev']\n                 if any(arg in sys.argv for arg in ('pytest', 'test'))\n                 else [])\n\nsetup_requires = pytest_runner\n\nsetup(\n    name=\"hello-cpp\",\n    version=\"1.2.3\",\n    description=\"a minimal example package (cpp version)\",\n    author='The scikit-build team',\n    license=\"MIT\",\n    packages=['hello'],\n    tests_require=['pytest'],\n    setup_requires=setup_requires\n)\n"
  },
  "Zirias/zfbsd-ports": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  },
  "InsightSoftwareConsortium/ITKNDReg": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-ndreg',\n    version='0.2.1',\n    author='Neurodata',\n    author_email='vikramc@jhmi.edu',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKNDReg',\n    description=r'This is the Neurodata open-source Python package that performs affine and deformable (LDDMM) image registration.',\n    long_description='Easiest way to use',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk>=5.2rc3'\n    ]\n    )\n"
  },
  "bdilday/pychadwick": {
    "setup.py": "import subprocess\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ModuleNotFoundError:\n    subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"scikit-build\"])\n    from skbuild import setup\n\nfrom setuptools import find_packages\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\nsetup(\n    name=\"pychadwick\",\n    version=\"0.5.0\",\n    author=\"Ben Dilday\",\n    author_email=\"ben.dilday.phd@gmail.com\",\n    description=\"Python bindings to the Chadwick library\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/bdilday/pychadwick\",\n    packages=find_packages(),\n    cmake_install_dir=\"pychadwick/lib\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: C\",\n        \"License :: OSI Approved :: GNU General Public License v2 (GPLv2)\",\n        \"Operating System :: OS Independent\",\n    ],\n    install_requires=[\"scikit-build\", \"ninja\", \"cmake\", \"wheel\", \"setuptools\", \"pandas>=1.0.4\", \"requests\"],\n    entry_points={\"console_scripts\": [\"pycwevent=pychadwick.cli.pycwevent:main\"]},\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n",
    "setup.cfg": "[bumpversion]\ncurrent_version = 0.5.0\n\n[flake8]\nmax-line-length = 90\n\n"
  },
  "GalaxyHunters/VIVID3D": {
    "setup.py": "import os\nimport re\nimport subprocess\nimport sys\n\nfrom skbuild import setup\n\nfrom pathlib import Path\nthis_directory = Path(__file__).parent\nlong_description = (this_directory / \"README.md\").read_text()\n\nabout = {}\nwith open(\"src/vivid3d/_details.py\") as fp:\n    exec(fp.read(), about)\n\nsetup(\n    name=\"vivid3d\",\n    version=about['__version__'],\n    packages=['vivid3d', 'vivid3d.viewer'],\n    package_dir={'': 'src'},\n    package_data={'vivid3d.viewer': [\"template.html\"]},\n    #include_package_data=True,\n    cmake_install_dir='src/vivid3d',\n    author='GalaxyHuntersIL',\n    author_email='galaxyhuntersil@gmail.com',\n    url='https://galaxyhuntersil.wixsite.com/website/vivid',\n    project_urls={\n        \"Documentation\": \"https://vivid.readthedocs.io/en/latest/\",\n        \"Bug Tracker\": \"https://github.com/GalaxyHunters/Vivid/issues\",\n        \"Source Code\": \"https://github.com/GalaxyHunters/Vivid\",\n    },\n    description='A 3D visualisation tool for simulations',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    zip_safe=False,\n    extras_require={\"test\": [\"pytest>=6.0\"]},\n    python_requires=\">=3.7\",\n    keywords=[\"3d\", \"mesh\", \"visualization\", \"simulation\", \"particles\"],\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Programming Language :: C++\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Topic :: Software Development\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Multimedia :: Graphics :: 3D Modeling\",\n        \"Typing :: Typed\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\",\n    ]\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=61.0\",\n    \"scikit-build>=0.15.0\",\n    \"cmake>=3.24.1.1\",\n    \"ninja>=1.10.2.4; platform_system!='Windows'\",\n    \"python-dev-tools>=2022.5.27\"\n]\nbuild-backend = \"setuptools.build_meta\"\n"
  },
  "BartoszBartmanski/StoSpa2": {
    "setup.py": "\nimport os\nimport platform\nfrom skbuild import setup\n\n\n# Read in the version number\nwith open(\"version\", \"r\") as fh:\n    version = fh.read().strip()\n\n# Read in the description\nwith open(os.path.join(\"pystospa\", \"README.md\"), \"r\") as fh:\n    long_description = fh.read()\n\ncmake_args = []\nif platform.system() == \"Darwin\":\n    cmake_args.append(\"-DCMAKE_CXX_FLAGS=-stdlib=libc++\")\n\n# Run the installation\nsetup(\n    name='pystospa',\n    version=version,\n    author='Bartosz Bartmanski',\n    author_email='bartoszbartmanski@gmail.com',\n    description='A python binding of C++ package for stochastic simulations of spatially extended systems',\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    platforms=[\"Linux\"],\n    cmake_args=cmake_args,\n    packages=['pystospa'],\n    setup_requires=[\"setuptools\", \"wheel\", \"cmake >= 3.5\"],\n    zip_safe=False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\", \"ninja\"]\n",
    "setup.cfg": "# Inside of setup.cfg\n[metadata]\ndescription-file = README.md\n"
  },
  "equinor/ecl3": {
    "python/setup.py": "#!/usr/bin/env python3\n\nimport os\nimport skbuild\nimport setuptools\n\nclass get_pybind_include(object):\n    def __init__(self, user=False):\n        self.user = user\n\n    def __str__(self):\n        # postpone importing pybind11 until building actually happens\n        import pybind11\n        return pybind11.get_include(self.user)\n\ndef src(x):\n    root = os.path.dirname( __file__ )\n    return os.path.abspath(os.path.join(root, x))\n\ndef getversion():\n    pkgversion = { 'version': '0.0.0' }\n    versionfile = 'ecl3/version.py'\n\n    if not os.path.exists(versionfile):\n        return {\n            'use_scm_version': {\n                # look for git in ../\n                'relative_to' : src('.'),\n                # write to ./python\n                'write_to'    : os.path.join(src(''), versionfile),\n            }\n        }\n\n    import ast\n    with open(versionfile) as f:\n        root = ast.parse(f.read())\n\n    for node in ast.walk(root):\n        if not isinstance(node, ast.Assign): continue\n        if len(node.targets) == 1 and node.targets[0].id == 'version':\n            pkgversion['version'] = node.value.s\n\n    return pkgversion\n\npybind_includes = [\n    str(get_pybind_include()),\n    str(get_pybind_include(user = True))\n]\n\nskbuild.setup(\n    name = 'ecl3',\n    description = 'ecl3',\n    long_description = 'ecl3',\n    url = 'https://github.com/equinor/ecl3',\n    packages = [\n        'ecl3',\n        'ecl3.summary',\n    ],\n    license = 'LGPL-3.0',\n    platforms = 'any',\n    install_requires = ['numpy'],\n    setup_requires = [\n        'setuptools >= 28',\n        'pybind11 >= 2.2',\n        'setuptools_scm',\n        'pytest-runner',\n    ],\n    tests_require = [\n        'pytest',\n        'hypothesis',\n        'path.py',\n    ],\n    # we're building with the pybind11 fetched from pip. Since we don't rely on\n    # a cmake-installed pybind there's also no find_package(pybind11) -\n    # instead, the get include dirs from the package and give directly from\n    # here\n    cmake_args = [\n        '-DPYBIND11_INCLUDE_DIRS=' + ';'.join(pybind_includes),\n        # we can safely pass OSX_DEPLOYMENT_TARGET as it's ignored on\n        # everything not OS X. We depend on C++11, which makes our minimum\n        # supported OS X release 10.9\n        '-DCMAKE_OSX_DEPLOYMENT_TARGET=10.9',\n    ],\n    # skbuild's test imples develop, which is pretty obnoxious instead, use a\n    # manually integrated pytest.\n    cmdclass = { 'test': setuptools.command.test.test },\n    **getversion()\n)\n",
    "python/setup.cfg": "[aliases]\ntest = pytest\n"
  },
  "upmem/dpu_kmeans": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nimport sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\nfrom setuptools_scm import get_version\n\nVERSION = get_version(local_scheme=\"no-local-version\")\nVERSION = \"\".join([c for c in VERSION if c.isdigit() or c == \".\"])\n\n# compilation of the host library\nsetup(\n    use_scm_version={\n        \"root\": \".\",\n        \"relative_to\": __file__,\n    },\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/dpu_kmeans\",\n    include_package_data=True,\n    install_requires=[\n        \"numpy\",\n        \"scikit-learn\",\n        \"importlib_resources;python_version<'3.9'\",\n        \"xxhash\",\n    ],\n    extras_require={\n        \"test\": [\"pytest\"],\n        \"benchmarks\": [\"pytest\", \"pandas\", \"pyarrow\"],\n    },\n    zip_safe=False,\n    cmake_args=[\n        \"-DNR_TASKLETS=16\",  # number of parallel tasklets on each DPU\n        f\"-DVERSION={VERSION}\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"pybind11>=2.7.1\",\n    \"cmake>=3.21\",\n    \"scikit-build>=0.12\",\n    \"ninja\",\n    \"pkgconfig\",\n    \"setuptools_scm>=6.2\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n",
    "setup.cfg": "[metadata]\nname = dpu_kmeans\ndescription = A package for the k-means algorithm on DPU.\nlong_description = file: README.md\nlong_description_content_type = text/markdown\nlicense = MIT\nlicense_files = LICENSE\nurl = https://github.com/upmem/dpu_kmeans\nauthor = Sylvan Brocard\nauthor_email = sylvan.brocard@gmail.com\n"
  },
  "airsim/trademgen": {
    "setup.py": "\nimport os, sys, setuptools\nfrom skbuild import setup\nfrom pathlib import Path\n\n# Home directory for TraDemGen, assumed to be the parent directory\n# of this setup.py file\ntdg_dir = Path(__file__).resolve().parents[1]\n\n# Installation directories of other Travel Market Simulator compoenents\n# are assumed to be ../../install/component, as if installed by\n# MetaSim (https://github.com/airsim/metasim).\n# If that is not the case, adapt the paths to the components\n# in the CMake arguments below\ninstall_dir = tdg_dir.parent / 'install'\n\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup (\n    name='trademgen',\n    version='1.0.6-1',\n    author='Denis Arnaud',\n    author_email='denis.arnaud_pypi@m4x.org',\n    description=('''Simple Python wrapper for AirInv'''),\n    license='MIT',\n    keywords='api python airline inventory package',\n    url='https://github.com/airsim/airinv',\n    packages=setuptools.find_packages(),\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n    ],\n    cmake_args = [\n        '-DINSTALL_DOC:BOOL=OFF',\n        '-DRUN_GCOV:BOOL=OFF',\n        '-DLIB_SUFFIX=',\n        f'-DWITH_STDAIR_PREFIX={install_dir}/stdair',\n        f'-DWITH_SEVMGR_PREFIX={install_dir}/sevmgr'\n      ] + (\n      ['-DREADLINE_ROOT=/usr/local/opt/portable-readline',\n       '-DREADLINE_INCLUDE_DIR=/usr/local/opt/portable-readline/include',\n       '-DREADLINE_LIBRARY=/usr/local/opt/libedit/lib/libedit.dylib',\n       '-DICU_ROOT=/usr/local/opt/icu4c'] if sys.platform.startswith(\"darwin\") else []\n      )\n)\n\n"
  },
  "InsightSoftwareConsortium/ITKArrayFire": {
    "setup.py": "from __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-arrayfire',\n    version='0.0.1',\n    author='Insight Software Consortium',\n    author_email='community@itk.org',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKArrayFire',\n    description=r'ArrayFire-backed ITK pipelines',\n    long_description='ITK is an open-source, cross-platform library that '\n                     'provides developers with an extensive suite of software '\n                     'tools for image analysis. ArrayFire is a high'\n                     'performance software library for parallel computing with'\n                     'an easy-to-use API. Its array based function set makes'\n                     'parallel programming more accessible.',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK InsightToolkit',\n    url=r'https://itk.org/',\n    install_requires=[\n        r'itk'\n    ]\n    )\n"
  },
  "classner/forpy": {
    "setup.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"The setup script for the forpy project.\"\"\"\nfrom __future__ import print_function\n\nimport platform\nimport subprocess\nimport sys\nimport unittest\n\ntry:\n    from skbuild import setup\nexcept:  # pylint: disable=bare-except\n    print(\n        \"This package requires `scikit-build` for setup. Trying to install it...\"\n    )\n    try:\n        subprocess.check_call(\n            [sys.executable, '-m', 'pip', 'install', 'scikit-build'])\n    except:  # pylint: disable=bare-except\n        print(\n            \"Automatic installation failed. Please install `scikit-build` and \"\n        )\n        print(\"rerun the package setup!\")\nfrom skbuild import setup  # isort:skip\n\n# Parse the version string.\nwith open(\"CMakeLists.txt\", 'r') as inf:\n    for line in inf:\n        if 'forpy_VERSION_MAJOR' in line:\n            ver_major = line[line.find(\"forpy_VERSION_MAJOR\") + 20:line.find(\n                \")\")]\n        if 'forpy_VERSION_MINOR' in line:\n            ver_minor = line[line.find(\"forpy_VERSION_MINOR\") + 20:line.find(\n                \")\")]\n        if 'forpy_VERSION_PATCH' in line:\n            ver_patch = line[line.find(\"forpy_VERSION_PATCH\") + 20:line.find(\n                \")\")]\n            break\nVERSION = ver_major + '.' + ver_minor + '.' + ver_patch\n\ntry:\n    subprocess.check_call([\"cmake\", \"--version\"])\nexcept:  # pylint: disable=bare-except\n    try:\n        subprocess.check_call(\n            [sys.executable, '-m', 'pip', 'install', 'cmake'])\n    except:  # pylint: disable=bare-except\n        print(\"Automatic installation failed. Please install `cmake` and \")\n        print(\"rerun the package setup!\")\n\n\ndef python_test_suite():\n    \"\"\"Discover all python tests.\"\"\"\n    test_loader = unittest.TestLoader()\n    test_suite = test_loader.discover('test/python', pattern='*.py')\n    return test_suite\n\n\nif platform.system().lower() == 'linux':\n    CORE_LIB_FE = '.so'\n    FORPY_LIB_FE = '.so'\nelif platform.system().lower() == 'darwin':\n    CORE_LIB_FE = '.dylib'\n    FORPY_LIB_FE = '.so'\nelse:\n    CORE_LIB_FE = '.dll'\n    FORPY_LIB_FE = '.dll'\n\nsetup(\n    name='forpy',\n    author='Christoph Lassner',\n    author_email='mail@christophlassner.de',\n    url='https://github.com/classner/forpy',\n    download_url='https://github.com/classner/forpy/tarball/v{}'.format(\n        VERSION),\n    keywords='random forests decision machine learning',\n    classifiers=[],\n    data_files=[('lib/python{}.{}/site-packages'.format(\n        sys.version_info[0], sys.version_info[1]), [\n            'libforpy_core{}'.format(CORE_LIB_FE),\n            'forpy{}'.format(FORPY_LIB_FE)\n        ])],\n    cmake_source_dir='.',\n    cmake_install_dir='',\n    cmake_args=[\n        '-DWITH_PYTHON=On',\n        '-DPYTHON_EXECUTABLE=' + sys.executable,\n    ],\n    test_suite='setup.python_test_suite',\n    setup_requires=['numpy', 'scikit-build'],\n    install_requires=['numpy', 'scipy', 'matplotlib', 'sklearn'],\n    version=VERSION,\n    license='BSD 2-clause')\n",
    "setup.cfg": "[metadata]\ndescription-file = README.md\n"
  },
  "OliverBScott/align-it": {
    "setup.py": "\"\"\"setup script for building + installing python wrappers.\"\"\"\nimport pathlib\nimport sys\nimport os\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, pip 10 or greater is required,\\n\"\n        \" or you will need to install the PEP 518 requirements\"\n        \" in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nfrom setuptools import find_packages\nfrom distutils import sysconfig\n\n# Find rdkit headers (assumes using a conda environment)\nincludes = pathlib.Path(sysconfig.get_python_inc()).parent\nrdkit_include = includes / 'rdkit'\n\n# Raise error if headers not found\nif not rdkit_include.exists():\n    raise RuntimeError(f\"Could not find rdkit include headers at {rdkit_include},\"\n                       f\" check that rdkit is installed correctly.\")\n\n# Get conda libs\nconda_prefix = os.getenv(\"CONDA_PREFIX\")\nif not conda_prefix:\n    conda_prefix = os.getenv(\"MINICONDAPATH\")\nif not conda_prefix:\n    raise RuntimeError(\"Could not get environment variable CONDA_PREFIX\")\nconda_prefix = pathlib.Path(conda_prefix)\nconda_libs = conda_prefix / 'lib'\n\n# CMake's arguments (use rdkit and of course build wrappers)\nCMAKE_ARGUMENTS = [\n    \"-DBUILD_RDKIT_SUPPORT=ON\",\n    \"-DBUILD_PYTHON_SUPPORT=ON\",\n    f\"-DRDKIT_INCLUDE_DIR={rdkit_include}/\",\n    f\"-DCONDA_LIB_DIR={conda_libs}/\",\n]\n\nsetup(\n    name=\"pyalignit\",\n    version=\"1.0.4\",\n    description=\"Python wrappers for the Align-it\u2122 tool from Silicos-it\",\n    url=\"https://github.com/OliverBScott/align-it\",\n    author=\"OliverBScott\",\n    license=\"GPLv3\",\n    packages=find_packages(),\n    cmake_install_dir=\"pyalignit\",\n    include_package_data=True,\n    extras_require={\"test\": [\"pytest\"]},\n    python_requires=\">=3.6\",\n    install_requires=[\"numpy\"],\n    cmake_args=CMAKE_ARGUMENTS,\n    cmake_minimum_required_version=\"3.14\"\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"cmake>=3.21\",\n    \"scikit-build>=0.12\",\n    \"numpy\",\n    \"ninja\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\""
  },
  "brentyi/jax_cuda_boilerplate": {
    "setup.py": "# Modified from:\n# > https://github.com/wjakob/nanobind_example\n\nimport pathlib\nimport sys\n\ntry:\n    import nanobind\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"The preferred way to invoke 'setup.py' is via pip, as in 'pip \"\n        \"install .'. If you wish to run the setup script directly, you must \"\n        \"first install the build dependencies listed in pyproject.toml!\",\n        file=sys.stderr,\n    )\n    raise\n\npackage_name = \"jax_cuda_boilerplate\"\n\nsetup(\n    name=package_name,\n    author=\"brentyi\",\n    author_email=\"brentyi@berkeley.edu\",\n    url=\"https://github.com/brentyi/jax_cuda_boilerplate\",\n    long_description=pathlib.Path(\"README.md\").read_text(),\n    long_description_content_type=\"text/markdown\",\n    license=\"BSD\",\n    packages=[package_name],\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/jax_cuda_boilerplate\",\n    include_package_data=True,\n    package_data={package_name: [\"py.typed\", \"**/*.pyi\"]},\n    python_requires=\">=3.8\",\n    install_requires=[\n        \"jax>=0.3.20\",\n        \"jaxlib\",\n        \"dcargs\",\n    ],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n    \"setuptools>=42\",\n    \"wheel\",\n    \"scikit-build==0.14.0\",\n    \"cmake>=3.18\",\n    \"nanobind @ git+https://github.com/brentyi/nanobind.git@master\",\n    \"ninja; platform_system!='Windows'\",\n    \"mypy\"\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.isort]\nprofile = \"black\"\n\n[tool.mypy]\npython_version = \"3.8\"\nignore_missing_imports = true\nwarn_unused_configs = true\n"
  },
  "MRChemSoft/vampyr": {
    "setup.py": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom pathlib import Path\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\n\ndef version_from_file(rel_path):\n    here = Path(__file__).parent\n    f = here / rel_path\n    with f.open(\"r\") as fp:\n        return fp.read().strip()\n\n\nsetup(\n    version=version_from_file(\"VERSION\"),\n    packages=[\"vampyr\"],\n    package_dir={\"\": \"src\"},\n    cmake_args=[\n        \"-DPYMOD_INSTALL_FULLDIR:STRING=src/vampyr\",\n    ],\n)\n",
    "pyproject.toml": "[tool.isort]\nprofile = \"black\"\n\n[tool.pytest.ini_options]\ntestpaths = [ \"tests\" ]\naddopts = \"-rws\"\nnorecursedirs = [\n  \"env\",\n  \".direnv\",\n  \"venv\",\n  \".env\",\n  \".venv\",\n  \"docs\",\n  \".eggs\",\n  \".git\",\n]\n\n[build-system]\nrequires = [\n  \"pybind11[global]>=2.6\",\n  \"setuptools>=46.4.0\",\n  \"wheel\",\n  \"scikit-build>=0.13\",\n  \"cmake>=3.17\",\n  \"ninja; platform_system!='Windows'\",\n]\n\nbuild-backend = \"setuptools.build_meta\"\n",
    "setup.cfg": "[metadata]\nname = vampyr\ndescription = The Very Accurate Multiresolution Python Routines (VAMPyR) package is a high level Python interface to the MRCPP code.\nlicense = LGPLv3+\nlicense_files =\n   LICENSE\nauthor = Magnar Bj\u00f8rgve\nurl = https://vampyr.readthedocs.io/en/latest/\nclassifiers =\n    Development Status :: 3 - Alpha\n    Intended Audience :: Education\n    Intended Audience :: Science/Research\n    License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)\n    Programming Language :: Python\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3.9\n    Programming Language :: Python :: 3.10\n    Programming Language :: Python :: 3.11\n    Programming Language :: C++\n    Topic :: Scientific/Engineering :: Chemistry\n\n[options]\npython_requires = >= 3.8\n\nsetup_requires =\n    pybind11-global >= 2.6\n    setuptools >=46.4.0\n    wheel\n    scikit-build >=0.13\n    cmake >= 3.17\n    ninja; platform_system!='Windows'\n\ninstall_requires =\n    numpy >= 1.15.0\n\ntest_suite =\n    tests\n\n[options.extras_require]\ndocs =\n    myst_nb\n    sphinx\n    sphinx_book_theme\n    sphinx_thebe\n    sphinxcontrib_bibtex\n\ntest =\n    pytest\n    pytest-cov\n\ndev =\n    %(docs)s\n    %(test)s\n    black\n    isort\n\n[flake8]\nmax-line-length = 88\nexclude = docs/conf.py\n# these error codes interfere with Black\nignore = E203, E231, W503, W504\nselect = C,E,F,W,B\n"
  },
  "InsightSoftwareConsortium/ITKVkFFTBackend": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print(\"scikit-build is required to build from source.\", file=sys.stderr)\n    print(\"Please run:\", file=sys.stderr)\n    print(\"\", file=sys.stderr)\n    print(\"  python -m pip install scikit-build\")\n    sys.exit(1)\n\nsetup(\n    name=\"itk-vkfft\",\n    version=\"0.2.0\",\n    author=\"Insight Software Consortium\",\n    author_email=\"itk+community@discourse.itk.org\",\n    packages=[\"itk\"],\n    package_dir={\"itk\": \"itk\"},\n    download_url=r\"https://github.com/InsightSoftwareConsortium/ITKVkFFTBackend\",\n    description=r\"VkFFT backends for ITK FFT classes.\",\n    long_description=\"ITK is an open-source, cross-platform library that provides developers with an extensive suite of software tools for image analysis. Developed through extreme programming methodologies, ITK employs leading-edge algorithms for registering and segmenting multidimensional scientific images.\",\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\",\n    ],\n    license=\"Apache\",\n    keywords=\"ITK InsightToolkit\",\n    url=r\"https://itk.org/\",\n    install_requires=[r\"itk>=5.3.0\"],\n)\n"
  },
  "hiddenSymmetries/VMEC2000": {
    "setup.py": "#!/usr/bin/env python3\nimport sys\nimport json\nimport argparse\nimport setuptools\nimport pathlib\nimport os\n\nfrom os.path import basename, splitext\nfrom glob import glob\n\nprint(\"system.platform is {}\".format(sys.platform))\nif (sys.platform == \"darwin\"):\n    from distutils import sysconfig\n    vars = sysconfig.get_config_vars()\n    vars['LDSHARED'] = vars['LDSHARED'].replace('-bundle', '-dynamiclib')\n\nfrom skbuild import setup\n\nfldr_path = pathlib.Path(__file__).parent.absolute()\n\nwith open(os.path.join(fldr_path, 'cmake_config_file.json')) as fp:\n    d = json.load(fp)\n\nclass EmptyListWithLength(list):\n    def __len__(self):\n        return 1\n\nsetup(\n    name=\"vmec\",\n    version=\"0.0.4\",\n    license=\"MIT\",\n    url=\"https://github.com/hiddenSymmetries/VMEC2000\",\n    packages=['vmec'],\n    package_dir={'': 'python'},\n    install_requires=['f90wrap'],\n    python_requires=\">=3.6\",\n    ext_modules=EmptyListWithLength(),\n    description=\"Python wrapper for VMEC2000\",\n    maintainer=\"Bharat Medasani\",\n    maintainer_email=\"mbkumar@gmail.com\",\n    author=\"Ben Faber, Matt Landreman, Bharat Medasani, Caoxiang Zhu (developers of python extension only)\",\n    classifiers=[\n        \"Development Status :: 1 - Alpha\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Information Technology\",\n        \"Intended Audience :: Science/Research\",\n        \"Intended Audience :: Nuclear Fusion Community\",\n        \"Operating System :: MacOS\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Fortran\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Nuclear Fusion\",\n        \"Topic :: Scientific/Engineering :: Nuclear Fusion :: Stellarator Research\",\n        \"Topic :: Scientific/Engineering :: Optimization\",\n        \"Topic :: Software Development\",],\n    cmake_args=d['cmake_args'],\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\"setuptools\", \"wheel\", \"scikit-build\", \"cmake\",  \"ninja\", \"numpy\", \"f90wrap\"]\n"
  },
  "romankempt/hetbuilder": {
    "setup.py": "#!/usr/bin/env python\nimport re\nfrom setuptools import find_packages\nfrom pathlib import Path\nimport os\nimport sys\n\nVERSIONFILE = \"hetbuilder/__init__.py\"\nverstrline = open(VERSIONFILE, \"rt\").read()\nVSRE = r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\"\nmo = re.search(VSRE, verstrline, re.M)\nif mo:\n    version = mo.group(1)\nelse:\n    raise RuntimeError(\"Unable to find version string in %s.\" % (VERSIONFILE,))\n\n\ntry:\n    import skbuild\n    from skbuild import setup\nexcept ImportError:\n    print(\n        \"Please update pip, you need pip 10 or greater,\\n\"\n        \" or you need to install the PEP 518 requirements in pyproject.toml yourself\",\n        file=sys.stderr,\n    )\n    raise\n\nprint(\"Scikit-build version:\", skbuild.__version__)\n\n\n# read the contents of your README file\nfrom os import path\n\nthis_directory = path.abspath(path.dirname(__file__))\nwith open(path.join(this_directory, \"README.md\"), encoding=\"utf-8\") as f:\n    long_description = f.read()\n\nsetup(\n    name=\"hetbuilder\",\n    version=version,\n    author=\"Roman Kempt\",\n    author_email=\"roman.kempt@tu-dresden.de\",\n    description=\"A tool to build heterostructure interfaces based on coincidence lattice theory.\",\n    long_description=long_description,\n    license=\"MIT\",\n    url=\"https://github.com/romankempt/hetbuilder.git\",\n    download_url=\"https://github.com/romankempt/hetbuilder.git\",\n    packages=find_packages(),\n    package_data={\"\": [\"*.xyz\", \"CMakeLists.txt\"]},\n    # package_dir={\"\": \"\"},\n    cmake_install_dir=\"hetbuilder\",\n    include_package_data=True,\n    scripts=[\"bin/hetbuilder\"],\n    install_requires=[\n        \"numpy\",\n        \"scipy\",\n        \"spglib\",\n        \"matplotlib\",\n        \"ase\",\n        \"networkx\",\n        \"pretty_errors\",\n        \"rich\",\n        \"typer\",\n        # \"pybind11\",\n    ],\n    classifiers=[\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: C++\",\n        \"Topic :: Scientific/Engineering :: Chemistry\",\n        \"Topic :: Scientific/Engineering :: Physics\",\n    ],\n    cmake_args=[\n        \"-DCMAKE_BUILD_TYPE={}\".format(\"RELEASE\"),  # not used on MSVC, but no harm,\n    ],\n    zip_safe=False,\n)\n",
    "pyproject.toml": "[build-system]\nrequires = [\n  \"setuptools>=42\",\n  \"wheel\",\n  \"scikit-build\",\n  \"cmake\",\n  \"pybind11\",\n  \"pybind11-global\",\n  \"numpy\",\n  \"spglib\",\n  \"ninja; platform_system!='Windows'\"\n]\nbuild-backend = \"setuptools.build_meta\"",
    "setup.cfg": "[metadata]\ndescription_file = README.md\nlong_description = file: README.md\nlong_description_content_type = text/markdown\n"
  },
  "InsightSoftwareConsortium/ITKSplitComponents": {
    "setup.py": "# -*- coding: utf-8 -*-\nfrom __future__ import print_function\nfrom os import sys\n\ntry:\n    from skbuild import setup\nexcept ImportError:\n    print('scikit-build is required to build from source.', file=sys.stderr)\n    print('Please run:', file=sys.stderr)\n    print('', file=sys.stderr)\n    print('  python -m pip install scikit-build')\n    sys.exit(1)\n\nsetup(\n    name='itk-splitcomponents',\n    version='2.1.0',\n    author='Matthew M. McCormick',\n    author_email='matt.mccormick@kitware.com',\n    packages=['itk'],\n    package_dir={'itk': 'itk'},\n    download_url=r'https://github.com/InsightSoftwareConsortium/ITKSplitComponents',\n    description=r'ITK filters to split a multi-component pixel image into component-wise scalar images',\n    long_description='itk-splitcomponents provides a class that takes an image '\n                     'with multi-component pixels and outputs a scalar image '\n                     'for each component. This can be useful when examining '\n                     'images of vectors, tensors, etc.\\n'\n                     'Please refer to:\\n'\n                     'M. McCormick, \"An ITK Class that Splits Multi-Component Images.\", '\n                     'Insight Journal, July-December 2010, https://hdl.handle.net/10380/3230',\n    classifiers=[\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: C++\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Scientific/Engineering\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n        \"Topic :: Software Development :: Libraries\",\n        \"Operating System :: Android\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Unix\",\n        \"Operating System :: MacOS\"\n        ],\n    license='Apache',\n    keywords='ITK Higher-order Derivative Gradient',\n    url=r'https://github.com/InsightSoftwareConsortium/ITKSplitComponents',\n    install_requires=[\n        r'itk>=5.3.0'\n    ]\n    )\n"
  },
  "equinor/scikit-build-example": {
    "setup.py": "#!/usr/bin/env python3\n\nimport skbuild\nskbuild.setup(\n    name = 'my-package',\n    description = 'Example package with scikit-build',\n    url = 'https://github.com/equinor/scikit-build-example',\n    packages = [\n        'my_package',\n    ],\n    license = 'BSD',\n    platforms = 'any',\n    install_requires = [\n    ],\n    setup_requires = [\n        'setuptools_scm',\n    ],\n    tests_require = [\n    ],\n    cmake_args = [\n        # we can safely pass OSX_DEPLOYMENT_TARGET as it's ignored on\n        # everything not OS X. We depend on C++11, which makes our minimum\n        # supported OS X release 10.9\n        '-DCMAKE_OSX_DEPLOYMENT_TARGET=10.9',\n    ],\n    use_scm_version = True,\n)\n"
  },
  "dfm/workflows": {
    "test-projects/binary/setup.py": "from skbuild import setup\nfrom setuptools import find_packages\n\nsetup(\n    packages=find_packages(where=\"src\"),\n    package_dir={\"\": \"src\"},\n    cmake_install_dir=\"src/binary_test_project\",\n    include_package_data=True,\n)\n",
    "test-projects/binary/pyproject.toml": "[project]\nversion = \"1.0.0\"\nname = \"binary-test-project\"\ndescription = \"None\"\nauthors = [\n    { name=\"Dan Foreman-Mackey\", email=\"foreman.mackey@gmail.com\" },\n]\nreadme = \"README.md\"\nrequires-python = \">=3.7\"\nlicense = { file = \"LICENSE\" }\nclassifiers = [\n    \"Operating System :: OS Independent\",\n    \"Programming Language :: Python :: 3\",\n    \"Development Status :: 4 - Beta\",\n    \"License :: OSI Approved :: Apache Software License\",\n]\ndependencies = [\n]\n\n[project.urls]\n\"Homepage\" = \"https://binary-test-project.readthedocs.io\"\n\"Source\" = \"https://github.com/dfm/binary-test-project\"\n\"Bug Tracker\" = \"https://github.com/dfm/binary-test-project/issues\"\n\n[project.optional-dependencies]\ntest = [\n    \"pytest\",\n]\ndocs = [\n]\n\n[build-system]\nrequires = [\n    \"setuptools>=61.0\",\n    \"wheel\",\n    \"pybind11>=2.6\",\n    \"scikit-build\",\n    \"cmake\",\n    \"ninja; platform_system!='Windows'\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nwrite_to = \"src/binary_test_project/version.py\"\n\n[tool.black]\nline-length = 79\n\n[tool.isort]\nskip_glob = []\nline_length = 79\nmulti_line_output = 3\ninclude_trailing_comma = true\nforce_grid_wrap = 0\nuse_parentheses = true\nknown_first_party = [\"binary_test_project\"]\n\n[tool.coverage.run]\nparallel = true\nbranch = true\nsource = [\"binary_test_project\"]\nomit = [\n    \"docs/*\",\n    \"tests/*\",\n    \"*/binary_test_project/binary_test_project_version.py\",\n]\n\n[tool.coverage.paths]\nsource = [\"src\", \"*/site-packages\"]\n\n[tool.coverage.report]\nshow_missing = true\n"
  },
  "iory/pySDFGen": {
    "setup.py": "from __future__ import print_function\n\nimport shlex\nimport subprocess\nimport sys\n\nfrom setuptools import find_packages\n\n\nversion = '0.1.9'\n\n\nif sys.argv[-1] == 'release':\n    # Release via github-actions.\n    commands = [\n        'git tag v{:s}'.format(version),\n        'git push origin master --tag',\n    ]\n    for cmd in commands:\n        print('+ {}'.format(cmd))\n        subprocess.check_call(shlex.split(cmd))\n    sys.exit(0)\n\nsetup_requires = [\n]\n\ninstall_requires = [\n    'trimesh>=3.5.20'\n]\n\nsetup_params = dict(\n    name=\"pysdfgen\",\n    version=version,\n    description=\"SDFGen for Python\",\n    author='iory',\n    author_email='ab.ioryz@gmail.com',\n    url='https://github.com/iory/pySDFGen',\n    long_description=open('README.md').read(),\n    long_description_content_type='text/markdown',\n    license=\"MIT\",\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Intended Audience :: Developers',\n        'Natural Language :: English',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 2.7',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: Implementation :: CPython',\n    ],\n    packages=find_packages(),\n    setup_requires=setup_requires,\n    install_requires=install_requires,\n    include_package_data=True,\n)\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef install_packages(*requirements):\n    # No more convenient way until PEP 518 is implemented;\n    # setuptools only handles eggs\n    subprocess.check_call(\n        [sys.executable, \"-m\", \"pip\", \"install\"] + list(requirements)\n    )\n\n\n# https://github.com/skvark/opencv-python/blob/master/setup.py\ndef get_or_install_skbuild():\n    \"\"\"If a package is already installed, build against it. If not, install\n\n    \"\"\"\n    # Do not import 3rd-party modules into the current process\n    import json\n    js_packages = json.loads(\n        # valid names & versions are ASCII as per PEP 440\n        subprocess.check_output(\n            [sys.executable,\n             \"-m\", \"pip\", \"list\", \"--format\", \"json\",\n             \"--disable-pip-version-check\"]).decode('ascii'))\n    if \"scikit-build\" not in js_packages:\n        install_packages(\"scikit-build!=0.16.0\")\n\n\ndef main():\n    get_or_install_skbuild()\n    import skbuild  # NOQA\n\n    skbuild.setup(**setup_params)\n\n\nif __name__ == '__main__':\n    main()\n",
    "setup.cfg": "[flake8]\nexclude = .?*, src/, build, docs, SDFGen\nignore =\n    # E741: ambiguous variable name\n    E741\n    # W503: line break before binary operator\n    W503\n\n[isort]\nforce_single_line = true\nforce_sort_within_sections = true\nlexicographical = true\norder_by_type = false\nlines_after_imports = 2\n"
  },
  "yzgyyang/freebsd-ports": {
    "x11-fonts/py-afdko/files/patch-setup.py": "--- setup.py.orig\t2022-02-24 19:28:27 UTC\n+++ setup.py\n@@ -8,31 +8,10 @@ from distutils.dep_util import newer\n from distutils.util import convert_path\n from distutils.util import get_platform\n \n+from setuptools import setup\n import setuptools.command.install\n \n-from skbuild import setup\n \n-try:\n-    from wheel.bdist_wheel import bdist_wheel\n-\n-    class CustomBDistWheel(bdist_wheel):\n-        \"\"\"Mark the wheel as python 3, yet platform-specific,\n-        since it contains native C executables.\n-        \"\"\"\n-\n-        def finalize_options(self):\n-            bdist_wheel.finalize_options(self)\n-            self.root_is_pure = False\n-\n-        def get_tag(self):\n-            return ('py3', 'none',) + bdist_wheel.get_tag(self)[2:]\n-\n-except ImportError:\n-    print(\"afdko: setup.py requires that the Python package 'wheel' be \"\n-          \"installed. Try the command 'pip install wheel'.\")\n-    sys.exit(1)\n-\n-\n class InstallPlatlib(setuptools.command.install.install):\n     \"\"\"This is to force installing all the modules to the non-pure, platform-\n     specific lib directory, even though we haven't defined any 'ext_modules'.\n@@ -194,24 +173,17 @@ def main():\n           zip_safe=False,\n           python_requires='>=3.7',\n           setup_requires=[\n-              'wheel',\n               'setuptools_scm',\n-              'scikit-build',\n-              'cmake',\n-              'ninja'\n           ],\n           tests_require=[\n               'pytest',\n           ],\n           install_requires=_get_requirements(),\n-          scripts=_get_scripts(),\n           entry_points={\n               'console_scripts': _get_console_scripts(),\n           },\n           cmdclass={\n               'build_scripts': CustomBuildScripts,\n-              'bdist_wheel': CustomBDistWheel,\n-              'install': InstallPlatlib,\n           },\n           )\n \n"
  }
}
